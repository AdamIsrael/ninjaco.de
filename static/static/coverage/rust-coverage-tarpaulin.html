<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","adam","src","rust-gedcom","benches","parse_gedcom.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\nuse gedcom_rs::parse::parse_gedcom;\n\nuse std::time::Duration;\n\nconst FILENAME: \u0026str = \"data/complete.ged\";\n\nfn criterion_benchmark(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"parse-gedcom\");\n    group.measurement_time(Duration::from_secs(30));\n\n    // TODO: Benchmark individual types?\n    group.bench_function(\"parse gedcom\", |b| b.iter(|| parse_gedcom(FILENAME)));\n    group.finish();\n}\n\ncriterion_group!(benches, criterion_benchmark);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","lib.rs"],"content":"pub mod parse;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","main.rs"],"content":"extern crate gedcom_rs;\n\nuse gedcom_rs::parse::parse_gedcom;\n\nuse std::env;\n\nfn main() {\n    let args: Vec\u003cString\u003e = env::args().collect();\n    match args.len() {\n        1 =\u003e usage(\"Missing filename.\"),\n        s if s \u003e 2 =\u003e usage(\u0026format!(\"Found more args than expected: {:?}\", \u0026args[1..])),\n        _ =\u003e (),\n    };\n\n    let filename = \u0026args[1];\n\n    if filename == \"--help\" || filename == \"-h\" {\n        usage(\"\");\n    }\n\n    let gedcom = parse_gedcom(filename);\n\n    // TODO: print a pretty summary of the gedcom. Use `tabled` crate?\n    println!(\"{:#?}\", gedcom);\n}\n\nfn usage(msg: \u0026str) {\n    if !msg.is_empty() {\n        println!(\"{msg}\");\n    }\n    println!(\"Usage: gedcom-test ./path/to/gedcom.ged\");\n    std::process::exit(0x0100);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_complete_gedcom() {\n        let gedcom = parse_gedcom(\"./data/complete.ged\");\n\n        // Test the header\n        // println!(\"Gedcom: {:?}\", gedcom.header);\n        // Test the copyright header\n        assert!(gedcom.header.copyright.is_some());\n        let copyright = gedcom.header.copyright.unwrap();\n        assert!(\n            copyright == \"© 1997 by H. Eichmann, parts © 1999-2000 by J. A. Nairn.\".to_string()\n        );\n\n        // Test the note field\n        assert!(gedcom.header.note.is_some());\n        let note = gedcom.header.note.unwrap();\n        assert!(note.starts_with(\"This file demonstrates all tags that are allowed in GEDCOM 5.5.\"));\n        assert!(note.ends_with(\"GEDCOM 5.5 specs on the Internet at \u003chttp://homepages.rootsweb.com/~pmcbride/gedcom/55gctoc.htm\u003e.\"));\n    }\n\n    // #[test]\n    // /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    // /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    // fn newline_in_note() {\n    //     let data = vec![\n    //         \"0 @S313871942@ SOUR\",\n    //         \"1 TITL Germany, Lutheran Baptisms, Marriages, and Burials, 1567-1945\",\n    //         \"1 AUTH Ancestry.com\",\n    //         \"1 PUBL Ancestry.com Operations, Inc.\",\n    //         \"1 NOTE \u003cp\u003eMikrofilm Sammlung.  Familysearch.org\u003c/p\u003e\",\n    //         \"\u003cp\u003eOriginale:  Lutherische Kirchenbücher, 1567-1945. Various sources.\u003c/p\u003e\",\n    //         \"1 _APID 1,61250::0\",\n    //     ];\n\n    //     // assert_eq!(expected, line(\"\\r\")(\"0 HEAD\\r\").unwrap());\n    //     // assert_eq!(expected, line(\"\\n\")(\"0 HEAD\\n\").unwrap());\n    //     // assert_eq!(expected, line(\"\\r\\n\")(\"0 HEAD\\r\\n\").unwrap());\n    // }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":16},{"path":["/","Users","adam","src","rust-gedcom","src","parse.rs"],"content":"// use crate::types::{Address, Line, Source};\n// use super::types::Line;\nuse super::types::*;\n\nuse std::fs::File;\n\nuse std::io::{self, BufRead};\nuse std::path::Path;\n\nuse winnow::prelude::*;\n\n/// This is pretty much a kludge to strip out U+FEFF, a Zero Width No-Break Space\n/// https://www.compart.com/en/unicode/U+FEFF\n///\n/// So far, I've only seen this with one GEDCOM, as the starting byte.\n// pub fn zero_with_no_break_space(input: \u0026mut \u0026str) -\u003e PResult\u003c\u0026str\u003e {\n//     if input.starts_with('\\u{FEFF}') {\n//         let parser = tag(\"\\u{FEFF}\");\n\n//         parser.parse_next(input)\n//     } else {\n//         Ok(\"\")\n//     }\n// }\n\n/// Read the next tag's value and any continuations\npub fn get_tag_value(input: \u0026mut \u0026str) -\u003e PResult\u003cOption\u003cString\u003e\u003e {\n    let mut line = Line::parse(input).unwrap();\n\n    // Seed the value with the initial value\n    let mut text: String = line.value.to_string();\n\n    line = Line::peek(input).unwrap();\n    while line.tag == \"CONC\" || line.tag == \"CONT\" {\n        // consume\n        line = Line::parse(input).unwrap();\n\n        if line.tag == \"CONT\" {\n            text += \"\\n\";\n        }\n        text += line.value;\n\n        // peek ahead\n        line = Line::peek(input).unwrap();\n    }\n\n    Ok(Some(text))\n}\n\n/// Parse the buffer if the CONC tag is found and return the resulting string.\n// pub fn conc(input: \u0026mut \u0026str) -\u003e PResult\u003cOption\u003cString\u003e\u003e {\n//     let line = Line::parse(input).unwrap();\n\n//     if line.tag == \"CONC\" {\n//         Ok(Some(line.value.to_string()))\n//     } else {\n//         Ok(None)\n//     }\n// }\n\n/// Parse the buffer if the CONT tag is found and return the resulting string.\n/// TODO: Refactor this. It should handle CONT and CONC.\n// pub fn cont(input: \u0026mut \u0026str) -\u003e PResult\u003cOption\u003cString\u003e\u003e {\n//     let line = Line::parse(input).unwrap();\n\n//     if line.tag == \"CONT\" {\n//         Ok(Some(line.value.to_string()))\n//     } else {\n//         Ok(None)\n//     }\n// }\n\n/// Parse a GEDCOM file\npub fn parse_gedcom(filename: \u0026str) -\u003e Gedcom {\n    // Initialize an empty gedcom\n    let mut gedcom = Gedcom {\n        header: Header {\n            encoding: None,\n            copyright: None,\n            date: None,\n            destination: None,\n            gedcom_version: None,\n            language: None,\n            filename: None,\n            note: None,\n            source: None,\n            submitter: None,\n            submission: None,\n        },\n        individuals: vec![],\n    };\n\n    if let Ok(lines) = read_lines(filename) {\n        // Consumes the iterator, returns an (Optional) String\n\n        // Read through the lines and build a buffer of \u003crecords\u003e, each starting\n        // with a zero and ending with the last line before the next. Then feed that\n        // buffer to a nom parser to split it into Lines?\n\n        // This is kind of like a buffered read, specific to the GEDCOM format\n        // We read into the buffer until we hit a new record, and then parse that\n        // record into a struct.\n        let mut record: String = String::new();\n\n        for mut buffer in lines.flatten() {\n            // Strip off any leading Zero Width No-Break Space\n            if buffer.strip_prefix('\\u{FEFF}').is_some() {\n                buffer.remove(0);\n            }\n            // println!(\"Buffer: \\n'{}'\", buffer);\n            // record = buffer.clone() + \"\\n\";\n\n            if let Some(ch) = buffer.chars().next() {\n                if ch == '0' \u0026\u0026 !record.is_empty() {\n                    let mut input: \u0026str = record.as_str();\n\n                    // Peek at the first line in the record so we know how\n                    // to parse it.\n                    let line = Line::peek(\u0026mut input).unwrap();\n                    // println!(\"Got a line: {:?}\", line);\n                    match line.tag {\n                        \"HEAD\" =\u003e {\n                            // println!(\"Parsing HEAD: \\n{}\", input);\n                            gedcom.header = Header::parse(input.to_string());\n                        }\n                        \"INDI\" =\u003e {\n                            let indi = Individual::parse(\u0026mut input);\n                            // TODO: Remove the if. This is just to clean up the output for debugging.\n                            // if indi.xref.clone().unwrap() == \"@I1@\" {\n                            gedcom.individuals.push(indi);\n                            // }\n                        }\n                        \"SOUR\" =\u003e {}\n                        \"REPO\" =\u003e {}\n                        \"OBJE\" =\u003e {\n                            // let obj = Object::parse(buff);\n                            // println!(\"{:?}\", obj);\n                        }\n                        \"FAM\" =\u003e {}\n                        \"SUBM\" =\u003e {\n                            // // The record of the submitter of the family tree\n                            // // Not always present (it exists in complete.ged)\n                            // if let Some(ref subm) = gedcom.header.submitter {\n                            //     if let Some(xref) = \u0026subm.xref {\n                            //         gedcom.header.submitter =\n                            //             Submitter::find_by_xref(buff, xref.to_string());\n                            //     }\n                            // }\n                        }\n                        _ =\u003e {}\n                    };\n\n                    record.clear();\n                }\n                record = record + \u0026buffer.clone() + \"\\n\";\n            }\n        }\n        // TODO: families\n        // TODO: repositories\n        // TODO: sources\n        // TODO: multimedia\n    }\n    gedcom\n}\n\n// The output is wrapped in a Result to allow matching on errors\n// Returns an Iterator to the Reader of the lines of the file.\n// https://doc.rust-lang.org/rust-by-example/std_misc/file/read_lines.html\nfn read_lines\u003cP\u003e(filename: P) -\u003e io::Result\u003cio::Lines\u003cio::BufReader\u003cFile\u003e\u003e\u003e\nwhere\n    P: AsRef\u003cPath\u003e,\n{\n    let file = File::open(filename)?;\n    Ok(io::BufReader::new(file).lines())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_get_tag_value() {\n        let mut input = \"3 ADDR 1300 West Traverse Parkway\\n4 CONT Lehi, UT 84043 \\n4 CONC USA\";\n        let output = \"1300 West Traverse Parkway\\nLehi, UT 84043 USA\";\n\n        let res = get_tag_value(\u0026mut input).unwrap();\n        if let Some(value) = res {\n            assert!(output == value);\n        }\n        assert!(input.len() == 0);\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":149},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":149},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":149},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":149},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":582},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":111},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":149},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1955},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1956},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3910},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":77},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1955},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":39,"coverable":40},{"path":["/","Users","adam","src","rust-gedcom","src","types","address.rs"],"content":"use super::Line;\nuse crate::parse;\n\nuse winnow::prelude::*;\n\n#[derive(Debug, Default, PartialEq, Clone)]\npub struct Address {\n    pub addr1: Option\u003cString\u003e,\n    pub addr2: Option\u003cString\u003e,\n    pub addr3: Option\u003cString\u003e,\n    pub city: Option\u003cString\u003e,\n    pub state: Option\u003cString\u003e,\n    pub postal_code: Option\u003cString\u003e,\n    pub country: Option\u003cString\u003e,\n    pub phone: Vec\u003cString\u003e,\n    pub email: Vec\u003cString\u003e,\n    pub fax: Vec\u003cString\u003e,\n    pub www: Vec\u003cString\u003e,\n}\n\nimpl Address {\n    pub fn parse(buffer: \u0026mut \u0026str) -\u003e PResult\u003cAddress\u003e {\n        let mut address = Address {\n            addr1: None,\n            addr2: None,\n            addr3: None,\n            city: None,\n            state: None,\n            postal_code: None,\n            country: None,\n            phone: vec![],\n            email: vec![],\n            fax: vec![],\n            www: vec![],\n        };\n\n        let mut line = Line::peek(buffer).unwrap();\n        let min_level = line.level;\n\n        // Only iterate through the ADDR records\n        while line.level \u003e= min_level {\n            line = Line::peek(buffer).unwrap();\n\n            let mut consume = true;\n            match line.tag {\n                \"ADDR\" =\u003e {\n                    address.addr1 = parse::get_tag_value(buffer).unwrap();\n                    // println!(\"Input after get_tag_value: \\n'{}'\", buffer);\n                    consume = false;\n                }\n                \"ADR1\" =\u003e {\n                    address.addr1 = Some(line.value.to_string());\n                }\n                \"ADR2\" =\u003e {\n                    address.addr2 = Some(line.value.to_string());\n                }\n                \"ADR3\" =\u003e {\n                    address.addr3 = Some(line.value.to_string());\n                }\n                \"CONT\" =\u003e {} // Ignore, it's a special case handled by ADDR\n                \"CONC\" =\u003e {} // Ignore, it's a special case handled by ADDR\n                \"CITY\" =\u003e {\n                    address.city = Some(line.value.to_string());\n                }\n                \"STAE\" =\u003e {\n                    address.state = Some(line.value.to_string());\n                }\n                \"POST\" =\u003e {\n                    address.postal_code = Some(line.value.to_string());\n                }\n                \"CTRY\" =\u003e {\n                    address.country = Some(line.value.to_string());\n                }\n                \"PHON\" =\u003e {\n                    address.phone.push(line.value.to_string());\n                }\n                \"EMAIL\" =\u003e {\n                    address.email.push(line.value.to_string());\n                }\n                \"FAX\" =\u003e {\n                    address.fax.push(line.value.to_string());\n                }\n                \"WWW\" =\u003e {\n                    address.www.push(line.value.to_string());\n                }\n                _ =\u003e {\n                    // We've hit a non-address tag, so break out of the loop\n                    break;\n                }\n            }\n            // println!(\"Buffer before: {}\", buffer.len());\n            if consume {\n                Line::parse(buffer).unwrap();\n            }\n            // println!(\"Buffer after: {}\", buffer.len());\n            // (buffer, _) = Line::parse(buffer).unwrap();\n\n            // Grab the next line, if there is one, or short-circuit the loop\n            line = Line::peek(buffer).unwrap();\n            // (_, line) = Line::peek(buffer).unwrap();\n        }\n        Ok(address)\n    }\n}\n\n/// Parse the Address entity\n///\n/// This could be formatted one of three (valid) ways:\n///\n/// ```\n/// /*\n/// 3 ADDR 1300 West Traverse Parkway\n/// 4 CONT Lehi, UT  84043\n/// 4 CONT USA\n/// */\n/// ```\n///\n/// or:\n///\n/// ```\n/// /*\n/// 3 ADDR 1300 West Traverse Parkway\n/// 4 CONT Lehi, UT  84043\n/// 4 CONC USA\n/// */\n/// ```\n///\n/// or:\n///\n/// ```\n/// /*\n/// 3 ADDR\n/// 4 ADR1 RSAC Software\n/// 4 ADR2 7108 South Pine Cone Street\n/// 4 ADR3 Ste 1\n/// 4 CITY Salt Lake City\n/// 4 STAE UT\n/// 4 POST 84121\n/// 4 CTRY USA\n/// */\n/// ```\n///\n/// Why did I do it this way, vs implementing `parse` on the Address?\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_addr_tag() {\n        let mut data = \"3 ADDR\\n\";\n        let line = Line::parse(\u0026mut data).unwrap();\n\n        // let (str, line) = Line::parse(\u0026data).unwrap();\n\n        assert!(data.len() == 0);\n        assert!(line.level == 3);\n        assert!(line.xref == \"\");\n        assert!(line.tag == \"ADDR\");\n        assert!(line.value == \"\");\n    }\n\n    #[test]\n    fn parse_adr1_tag() {\n        let mut data = \"4 ADR1 RSAC Software\\n\";\n        let line = Line::parse(\u0026mut data).unwrap();\n\n        assert!(data.is_empty());\n        assert!(line.level == 4);\n        assert!(line.xref == \"\");\n        assert!(line.tag == \"ADR1\");\n        assert!(line.value == \"RSAC Software\");\n    }\n\n    #[test]\n    fn parse_full_address() {\n        let data = vec![\n            \"3 ADDR\",\n            \"4 ADR1 RSAC Software\",\n            \"4 ADR2 7108 South Pine Cone Street\",\n            \"4 ADR3 Ste 1\",\n            \"4 CITY Salt Lake City\",\n            \"4 STAE UT\",\n            \"4 POST 84121\",\n            \"4 CTRY USA\",\n            \"3 PHON +1-801-942-7768\",\n            \"3 PHON +1-801-555-1212\",\n            \"3 PHON +1-801-942-1148\",\n            \"3 EMAIL a@@example.com\",\n            \"3 EMAIL b@@example.com\",\n            \"3 EMAIL c@@example.com\",\n            \"3 FAX +1-801-942-7768\",\n            \"3 FAX +1-801-555-1212\",\n            \"3 FAX +1-801-942-1148\",\n            \"3 WWW https://www.example.com\",\n            \"3 WWW https://www.example.org\",\n            \"3 WWW https://www.example.net\",\n        ];\n\n        let input = data.join(\"\\n\");\n        let mut record = input.as_str();\n\n        let addr = Address::parse(\u0026mut record).unwrap();\n\n        assert!(addr.addr1 == Some(\"RSAC Software\".to_string()));\n        assert!(addr.addr2 == Some(\"7108 South Pine Cone Street\".to_string()));\n        assert!(addr.addr3 == Some(\"Ste 1\".to_string()));\n        assert!(addr.city == Some(\"Salt Lake City\".to_string()));\n        assert!(addr.state == Some(\"UT\".to_string()));\n        assert!(addr.postal_code == Some(\"84121\".to_string()));\n        assert!(addr.country == Some(\"USA\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-942-7768\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-555-1212\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.email.contains(\u0026\"a@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"b@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"c@@example.com\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.com\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.org\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.net\".to_string()));\n    }\n\n    #[test]\n    fn parse_full_address2() {\n        let data = vec![\n            \"1 ADDR\",\n            \"2 ADR1 RSAC Software\",\n            \"2 ADR2 7108 South Pine Cone Street\",\n            \"2 ADR3 Ste 1\",\n            \"2 CITY Salt Lake City\",\n            \"2 STAE UT\",\n            \"2 POST 84121\",\n            \"2 CTRY USA\",\n            \"1 PHON +1-801-942-7768\",\n            \"1 PHON +1-801-555-1212\",\n            \"1 PHON +1-801-942-1148\",\n            \"1 EMAIL a@@example.com\",\n            \"1 EMAIL b@@example.com\",\n            \"1 EMAIL c@@example.com\",\n            \"1 FAX +1-801-942-7768\",\n            \"1 FAX +1-801-555-1212\",\n            \"1 FAX +1-801-942-1148\",\n            \"1 WWW https://www.example.com\",\n            \"1 WWW https://www.example.org\",\n            \"1 WWW https://www.example.net\",\n        ]\n        .join(\"\\n\");\n\n        let mut record = data.as_str();\n        let addr = Address::parse(\u0026mut record).unwrap();\n\n        // println!(\"addr1: {:?}\", addr.addr1);\n        assert!(addr.addr1 == Some(\"RSAC Software\".to_string()));\n        assert!(addr.addr2 == Some(\"7108 South Pine Cone Street\".to_string()));\n        assert!(addr.addr3 == Some(\"Ste 1\".to_string()));\n        assert!(addr.city == Some(\"Salt Lake City\".to_string()));\n        assert!(addr.state == Some(\"UT\".to_string()));\n        assert!(addr.postal_code == Some(\"84121\".to_string()));\n        assert!(addr.country == Some(\"USA\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-942-7768\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-555-1212\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.email.contains(\u0026\"a@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"b@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"c@@example.com\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.com\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.org\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.net\".to_string()));\n    }\n\n    #[test]\n    /// Test the address block as used by Ancestry\n    fn parse_addr_cont() {\n        let data = vec![\n            \"3 ADDR 1300 West Traverse Parkway\",\n            \"4 CONT Lehi, UT  84043\",\n            \"4 CONT USA\",\n            \"3 PHON +1-801-942-7768\",\n            \"3 PHON +1-801-555-1212\",\n            \"3 PHON +1-801-942-1148\",\n        ]\n        .join(\"\\n\");\n\n        let mut record = data.as_str();\n        let address = Address::parse(\u0026mut record);\n        let addr = address.unwrap();\n\n        assert!(addr.addr1 == Some(\"1300 West Traverse Parkway\\nLehi, UT  84043\\nUSA\".to_string()));\n\n        assert!(addr.phone.contains(\u0026\"+1-801-942-7768\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-555-1212\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-942-1148\".to_string()));\n    }\n\n    #[test]\n    /// Test the address block as used by Ancestry\n    fn parse_addr_conc() {\n        let data = vec![\n            \"3 ADDR 1300 West Traverse Parkway\",\n            \"4 CONT Lehi, UT 84043 \",\n            \"4 CONC USA\",\n        ]\n        .join(\"\\n\");\n\n        let mut record = data.as_str();\n        let address = Address::parse(\u0026mut record);\n        let addr = address.unwrap();\n        assert!(addr.addr1 == Some(\"1300 West Traverse Parkway\\nLehi, UT 84043 USA\".to_string()));\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":219},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":211},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":211},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":211},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":209},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":183},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":170},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":171},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":153},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":123},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":378},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":179},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":199},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":20},"fn_name":null}],"covered":43,"coverable":43},{"path":["/","Users","adam","src","rust-gedcom","src","types","adopted_by.rs"],"content":"use std::str::FromStr;\n\n// ADOPTED_BY_WHICH_PARENT:= {Size=1:4}\n// [ HUSB | WIFE | BOTH ]\n// A code which shows which parent in the associated family record adopted this person.\n// Where:\n// HUSB = The HUSBand in the associated family adopted this person.\n// WIFE = The WIFE in the associated family adopted this person.\n// BOTH = Both HUSBand and WIFE adopted this person.\n\n#[derive(Default, Debug, PartialEq, Clone)]\n/// Which parent in the associated family record adopted this person.\npub enum AdoptedBy {\n    #[default]\n    /// Both HUSBand and WIFE adopted this person.\n    Both,\n    /// The HUSBand in the associated family adopted this person.\n    Husband,\n    // The WIFE in the associated family adopted this person.\n    Wife,\n}\n\nimpl FromStr for AdoptedBy {\n    type Err = ();\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cAdoptedBy, Self::Err\u003e {\n        match input {\n            \"BOTH\" =\u003e Ok(AdoptedBy::Both),\n            \"HUSB\" =\u003e Ok(AdoptedBy::Husband),\n            \"WIFE\" =\u003e Ok(AdoptedBy::Wife),\n            _ =\u003e Err(()),\n        }\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":6},{"path":["/","Users","adam","src","rust-gedcom","src","types","corporation.rs"],"content":"use super::Line;\nuse crate::types::Address;\n\n// +1 SOUR \u003cAPPROVED_SYSTEM_ID\u003e\n//     +2 VERS \u003cVERSION_NUMBER\u003e\n//     +2 NAME \u003cNAME_OF_PRODUCT\u003e\n//     +2 CORP \u003cNAME_OF_BUSINESS\u003e\n//         +3 \u003c\u003cADDRESS_STRUCTURE\u003e\u003e\n//     +2 DATA \u003cNAME_OF_SOURCE_DATA\u003e\n//         +3 DATE \u003cPUBLICATION_DATE\u003e\n//         +3 COPR \u003cCOPYRIGHT_SOURCE_DATA\u003e\n//         +4 [CONT|CONC]\u003cCOPYRIGHT_SOURCE_DATA\u003e\n\n#[derive(Clone, Debug, Default, PartialEq)]\npub struct Corporation {\n    pub name: Option\u003cString\u003e,\n    pub address: Option\u003cAddress\u003e,\n}\n\nimpl Corporation {\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cCorporation\u003e) {\n        let mut corp: Corporation = Corporation {\n            name: None,\n            address: None,\n        };\n\n        let mut line: Line = Line::peek(\u0026mut buffer).unwrap();\n\n        // Verify we have a CORP record\n        // line = Line::peek(\u0026mut buffer).unwrap();\n        if line.level == 2 \u0026\u0026 line.tag == \"CORP\" {\n            line = Line::parse(\u0026mut buffer).unwrap();\n            // (buffer, line) = Line::parse(buffer).unwrap();\n            corp.name = Some(line.value.to_string());\n\n            // Check if the next line contains an address struct\n            line = Line::peek(\u0026mut buffer).unwrap();\n\n            if line.level == 3 \u0026\u0026 line.tag == \"ADDR\" {\n                corp.address = Some(Address::parse(\u0026mut buffer).unwrap());\n            }\n        }\n\n        (buffer, Some(corp))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::types::corporation::Corporation;\n\n    #[test]\n    fn parse_corp() {\n        let data = vec![\n            \"2 CORP RSAC Software\",\n            \"3 ADDR\",\n            \"4 ADR1 RSAC Software\",\n            \"4 ADR2 7108 South Pine Cone Street\",\n            \"4 ADR3 Ste 1\",\n            \"4 CITY Salt Lake City\",\n            \"4 STAE UT\",\n            \"4 POST 84121\",\n            \"4 CTRY USA\",\n            \"3 PHON +1-801-942-7768\",\n            \"3 PHON +1-801-555-1212\",\n            \"3 PHON +1-801-942-1148\",\n            \"3 EMAIL a@@example.com\",\n            \"3 EMAIL b@@example.com\",\n            \"3 EMAIL c@@example.com\",\n            \"3 FAX +1-801-942-7768\",\n            \"3 FAX +1-801-555-1212\",\n            \"3 FAX +1-801-942-1148\",\n            \"3 WWW https://www.example.com\",\n            \"3 WWW https://www.example.org\",\n            \"3 WWW https://www.example.net\",\n        ];\n\n        let (_data, _corp) = Corporation::parse(data.join(\"\\n\").as_str());\n        let corp = _corp.unwrap();\n\n        assert!(Some(\"RSAC Software\".to_string()) == corp.name);\n\n        let addr = corp.address.unwrap();\n\n        assert!(Some(\"RSAC Software\".to_string()) == addr.addr1);\n        assert!(Some(\"7108 South Pine Cone Street\".to_string()) == addr.addr2);\n        assert!(Some(\"Ste 1\".to_string()) == addr.addr3);\n        assert!(Some(\"Salt Lake City\".to_string()) == addr.city);\n        assert!(Some(\"UT\".to_string()) == addr.state);\n        assert!(Some(\"84121\".to_string()) == addr.postal_code);\n        assert!(Some(\"USA\".to_string()) == addr.country);\n        assert!(addr.phone.contains(\u0026\"+1-801-942-7768\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-555-1212\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.email.contains(\u0026\"a@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"b@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"c@@example.com\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.com\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.org\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.net\".to_string()));\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","Users","adam","src","rust-gedcom","src","types","datetime.rs"],"content":"use super::Line;\n// use crate::parse;\n\n// +1 DATE \u003cTRANSMISSION_DATE\u003e\n// +2 TIME \u003cTIME_VALUE\u003e\n#[derive(Debug, Clone, PartialEq)]\npub struct DateTime {\n    pub date: Option\u003cString\u003e,\n    pub time: Option\u003cString\u003e,\n}\n\nimpl DateTime {\n    /// Parse the current line(s) for a date/time\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cDateTime\u003e) {\n        let mut dt = DateTime {\n            date: None,\n            time: None,\n        };\n        let mut line: Line;\n\n        line = Line::peek(\u0026mut buffer).unwrap();\n\n        if line.tag == \"DATE\" {\n            let parent_level = line.level;\n\n            // Consume the line\n            line = Line::parse(\u0026mut buffer).unwrap();\n            dt.date = Some(line.value.to_string());\n\n            // Check to see if we have time as a child of the date record\n            line = Line::peek(\u0026mut buffer).unwrap();\n            if line.level == parent_level + 1 \u0026\u0026 line.tag == \"TIME\" {\n                // Consume the line\n                line = Line::parse(\u0026mut buffer).unwrap();\n                dt.time = Some(line.value.to_string());\n            }\n        }\n\n        (buffer, Some(dt))\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","Users","adam","src","rust-gedcom","src","types","event.rs"],"content":"/// This is a template of a Type\nuse crate::parse;\nuse crate::types::{Address, Line, Object, Place, SourceCitation};\n\nuse winnow::prelude::*;\n\n// The GEDCOM specification of this type\n//\n// EVENT_DETAIL:=\n// n TYPE \u003cEVENT_OR_FACT_CLASSIFICATION\u003e {0:1} p.49\n// n DATE \u003cDATE_VALUE\u003e {0:1} p.47, 46\n// n \u003c\u003cPLACE_STRUCTURE\u003e\u003e {0:1} p.38\n// n \u003c\u003cADDRESS_STRUCTURE\u003e\u003e {0:1} p.31\n// n AGNC \u003cRESPONSIBLE_AGENCY\u003e {0:1} p.60\n// n RELI \u003cRELIGIOUS_AFFILIATION\u003e {0:1} p.60\n// n CAUS \u003cCAUSE_OF_EVENT\u003e {0:1} p.43\n// n RESN \u003cRESTRICTION_NOTICE\u003e {0:1} p.60\n// n \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// n \u003c\u003cSOURCE_CITATION\u003e\u003e {0:M} p.39\n// n \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n\n#[derive(Clone, Debug, Default)]\npub struct EventDetail {\n    pub r#type: Option\u003cString\u003e,\n    pub date: Option\u003cString\u003e,\n    pub place: Option\u003cPlace\u003e,\n    pub address: Option\u003cAddress\u003e,\n    pub agency: Option\u003cString\u003e,\n    pub religion: Option\u003cString\u003e,\n    pub cause: Option\u003cString\u003e,\n    pub restriction_notice: Option\u003cString\u003e,\n    pub note: Option\u003cString\u003e,\n    pub sources: Vec\u003cSourceCitation\u003e,\n    pub media: Vec\u003cObject\u003e,\n}\n\nimpl EventDetail {\n    /// Parse\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cEventDetail\u003e {\n        let mut event = EventDetail {\n            r#type: None,\n            date: None,\n            place: None,\n            address: None,\n            agency: None,\n            religion: None,\n            cause: None,\n            restriction_notice: None,\n            note: None,\n            sources: vec![],\n            media: vec![],\n        };\n\n        // Parse the first line, i.e., \"1 BAPM\",\n        let line = Line::parse(record).unwrap();\n        let level = line.level;\n\n        while !record.is_empty() {\n            let mut parse = true;\n            let line = Line::peek(record).unwrap();\n            if line.level \u003c= level {\n                break;\n            }\n\n            match line.tag {\n                \"ADDR\" =\u003e {\n                    event.address = Some(Address::parse(record).unwrap());\n                    parse = false;\n                }\n                \"AGNC\" =\u003e {\n                    event.agency = Some(line.value.to_string());\n                }\n                \"CAUS\" =\u003e {\n                    event.cause = Some(line.value.to_string());\n                }\n                \"DATE\" =\u003e {\n                    event.date = Some(line.value.to_string());\n                }\n                \"NOTE\" =\u003e {\n                    event.note = parse::get_tag_value(record).unwrap();\n                    parse = false;\n                }\n                \"OBJE\" =\u003e {\n                    let obj = Object {\n                        xref: line.value.to_string(),\n                    };\n                    event.media.push(obj);\n                }\n                \"PLAC\" =\u003e {\n                    event.place = Some(Place::parse(record).unwrap());\n                    parse = false;\n                }\n                \"RELI\" =\u003e {\n                    event.religion = Some(line.value.to_string());\n                }\n                \"SOUR\" =\u003e {\n                    let sc = SourceCitation::parse(record).unwrap();\n                    event.sources.push(sc);\n                    parse = false;\n                }\n                \"TYPE\" =\u003e {\n                    event.r#type = Some(line.value.to_string());\n                }\n                _ =\u003e {}\n            }\n\n            if parse {\n                Line::parse(record).unwrap();\n            }\n        }\n\n        Ok(event)\n    }\n}\n\n// +1 EVEN \u003cEVENT_TYPE_CITED_FROM\u003e\n// +2 ROLE \u003cROLE_IN_EVENT\u003e\n//\n// \"3 EVEN BIRT\",\n// \"4 ROLE CHIL\",\n\n#[derive(Clone, Debug, Default)]\npub struct EventTypeCitedFrom {\n    pub r#type: Option\u003cString\u003e,\n    pub role: Option\u003cString\u003e,\n}\n\nimpl EventTypeCitedFrom {\n    /// Parse\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cEventTypeCitedFrom\u003e {\n        let mut event = EventTypeCitedFrom {\n            r#type: None,\n            role: None,\n        };\n        let level = Line::peek(record).unwrap().level;\n\n        while !record.is_empty() {\n            let mut line = Line::parse(record).unwrap();\n            match line.tag {\n                \"EVEN\" =\u003e {\n                    event.r#type = Some(line.value.to_string());\n                }\n                \"ROLE\" =\u003e {\n                    event.role = Some(line.value.to_string());\n                }\n                _ =\u003e {}\n            }\n\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            line = Line::peek(record).unwrap();\n            if line.level == level {\n                break;\n            }\n        }\n\n        Ok(event)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_event_detail() {\n        let data = vec![\n            \"1 BAPM\",\n            \"2 DATE ABT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 AGE 3m\",\n            \"2 TYPE BAPM\",\n            \"2 ADDR\",\n            \"3 ADR1 Church Name\",\n            \"3 ADR2 Street Address\",\n            \"3 CITY City Name\",\n            \"3 POST zip\",\n            \"3 CTRY Country\",\n            \"2 CAUS Birth\",\n            \"2 AGNC The Church\",\n            \"2 OBJE @M8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample baptism Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A baptism source note.\",\n            \"2 NOTE A baptism event note (the event of baptism (not LDS), performed in infancy or later. See also BAPL and CHR).\",\n            \"1 CHR\",\n            \"2 DATE CAL 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample CHR Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening Source note.\",\n            \"2 NOTE Christening event note (the religious event (not LDS) of baptizing and/or naming a \",\n            \"3 CONC child).\",\n            \"2 FAMC @F3@\",\n        ].join(\"\\n\");\n        let mut record = data.as_str();\n        let detail = EventDetail::parse(\u0026mut record).unwrap();\n\n        assert!(detail.date.is_some());\n        assert!(detail.date.unwrap() == \"ABT 31 DEC 1997\");\n    }\n\n    #[test]\n    fn parse_event_type_cited_from() {\n        let data = vec![\"3 EVEN BIRT\", \"4 ROLE CHIL\"];\n\n        let input = data.join(\"\\n\");\n        let mut record = input.as_str();\n        let event_type = EventTypeCitedFrom::parse(\u0026mut record).unwrap();\n\n        assert!(event_type.r#type.is_some());\n        assert!(event_type.r#type.unwrap() == \"BIRT\");\n\n        assert!(event_type.role.is_some());\n        assert!(event_type.role.unwrap() == \"CHIL\");\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":199},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":199},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":199},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":209},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":188},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":207},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":107},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":77},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":307},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":109},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":54,"coverable":55},{"path":["/","Users","adam","src","rust-gedcom","src","types","family.rs"],"content":"use std::str::FromStr;\n\nuse crate::{\n    parse,\n    types::{AdoptedBy, Line, Note, Pedigree},\n};\n\n// use super::pedigree;\n\n// TODO: implement full parsing of the family record\n// TODO: Need to create a trait? to find_by_xref that can be used in these\n// types of structs, to find the type of object in a vec of the types.\n\n// FAM_RECORD:=\n// n @\u003cXREF:FAM\u003e@ FAM {1:1}\n// +1 RESN \u003cRESTRICTION_NOTICE\u003e {0:1) p.60\n// +1 \u003c\u003cFAMILY_EVENT_STRUCTURE\u003e\u003e {0:M} p.32\n// +1 HUSB @\u003cXREF:INDI\u003e@ {0:1} p.25\n// +1 WIFE @\u003cXREF:INDI\u003e@ {0:1} p.25\n// +1 CHIL @\u003cXREF:INDI\u003e@ {0:M} p.25\n// +1 NCHI \u003cCOUNT_OF_CHILDREN\u003e {0:1} p.44\n// +1 SUBM @\u003cXREF:SUBM\u003e@ {0:M} p.28\n// +1 \u003c\u003cLDS_SPOUSE_SEALING\u003e\u003e {0:M} p.36\n// +1 REFN \u003cUSER_REFERENCE_NUMBER\u003e {0:M} p.63, 64\n// 25\n// +2 TYPE \u003cUSER_REFERENCE_TYPE\u003e {0:1} p.64\n// +1 RIN \u003cAUTOMATED_RECORD_ID\u003e {0:1} p.43\n// +1 \u003c\u003cCHANGE_DATE\u003e\u003e {0:1} p.31\n// +1 \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// +1 \u003c\u003cSOURCE_CITATION\u003e\u003e {0:M} p.39\n// +1 \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n\n#[derive(Debug, Clone, PartialEq)]\n/// The Family structure\npub struct Family {\n    pub adopted_by: Option\u003cAdoptedBy\u003e,\n    pub xref: String,\n    pub notes: Vec\u003cNote\u003e,\n    pub pedigree: Option\u003cPedigree\u003e,\n}\n\nimpl Family {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e Family {\n        let mut family = Family {\n            adopted_by: None,\n            xref: \"\".to_string(),\n            notes: vec![],\n            pedigree: None,\n        };\n\n        let line = Line::peek(record).unwrap();\n        let level = line.level;\n        let tag = line.tag;\n\n        // If we're at the top of the record, consume the line\n        if tag == \"FAMC\" || tag == \"FAMS\" {\n            // Capture the xref\n            family.xref = line.value.to_string();\n            Line::parse(record).unwrap();\n        }\n\n        while !record.is_empty() {\n            let mut consume = true;\n            let line = Line::peek(record).unwrap();\n\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            if line.level \u003c= level {\n                break;\n            }\n\n            match line.tag {\n                \"NOTE\" =\u003e {\n                    if let Some(note) = parse::get_tag_value(record).unwrap() {\n                        family.notes.push(Note { note: Some(note) });\n                    }\n                    consume = false;\n                }\n                \"PEDI\" =\u003e {\n                    let pedigree = Pedigree::from_str(line.value).unwrap();\n                    family.pedigree = Some(pedigree);\n                }\n                \"ADOP\" =\u003e {\n                    let adopted_by = AdoptedBy::from_str(line.value).unwrap();\n                    family.adopted_by = Some(adopted_by);\n                }\n                _ =\u003e {}\n            }\n\n            if consume {\n                Line::parse(record).unwrap();\n            }\n        }\n\n        family\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    fn parse_family() {\n        let data = vec![\n            \"1 FAMS @F4@\",\n            \"1 FAMC @F2@\",\n            \"2 NOTE Note about this link to his parents family record.\",\n            \"2 NOTE Another note about this link to his parents family record\",\n            \"1 FAMC @F3@\",\n            \"2 PEDI adopted\",\n            \"2 NOTE Note about the link to his adoptive parents family record.\",\n        ]\n        .join(\"\\n\");\n        let mut record = data.as_str();\n\n        // First family\n        let family = Family::parse(\u0026mut record);\n        assert!(family.xref == \"@F4@\");\n\n        // Second family\n        let family = Family::parse(\u0026mut record);\n        assert!(family.xref == \"@F2@\");\n\n        let notes = family.notes;\n        assert!(\n            notes[0].note.as_ref().unwrap() == \"Note about this link to his parents family record.\"\n        );\n        assert!(\n            notes[1].note.as_ref().unwrap()\n                == \"Another note about this link to his parents family record\"\n        );\n\n        // Third family\n        let family = Family::parse(\u0026mut record);\n        assert!(family.xref == \"@F3@\");\n        assert!(family.pedigree.unwrap() == Pedigree::Adopted);\n\n        let notes = family.notes;\n        assert!(\n            notes[0].note.as_ref().unwrap()\n                == \"Note about the link to his adoptive parents family record.\"\n        );\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":27},"fn_name":null}],"covered":27,"coverable":28},{"path":["/","Users","adam","src","rust-gedcom","src","types","gedc.rs"],"content":"use super::Line;\n// use crate::parse;\n\n#[derive(Debug, Default, PartialEq)]\n// pub enum Form {\n//     LineageLinked,\n//     EventLineageLinked,\n//     Unknown,\n// }\npub struct Form {\n    pub name: Option\u003cString\u003e,\n    pub version: Option\u003cString\u003e,\n}\nimpl Form {\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cForm\u003e) {\n        let mut form = Form {\n            name: None,\n            version: None,\n        };\n\n        let mut line: Line;\n\n        line = Line::peek(\u0026mut buffer).unwrap();\n\n        if line.tag == \"FORM\" {\n            line = Line::parse(\u0026mut buffer).unwrap();\n\n            form.name = Some(line.value.to_string());\n\n            while !buffer.is_empty() {\n                // Peek the next line\n                line = Line::peek(\u0026mut buffer).unwrap();\n                match line.tag {\n                    \"VERS\" =\u003e {\n                        // consume the line\n                        line = Line::parse(\u0026mut buffer).unwrap();\n                        form.version = Some(line.value.to_string());\n                    }\n                    _ =\u003e {\n                        // panic!(\"Unknown tag: {}\", line.tag);\n                        break;\n                    }\n                }\n            }\n        }\n\n        (buffer, Some(form))\n    }\n}\n\n#[derive(Debug, Default, PartialEq)]\npub struct Gedc {\n    /// The version of this Gedcom file.\n    pub version: Option\u003cString\u003e,\n\n    /// The GEDCOM form used to construct this transmission.\n    pub form: Option\u003cForm\u003e,\n}\nimpl Gedc {\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cGedc\u003e) {\n        let mut gedc = Gedc {\n            version: None,\n            form: None,\n        };\n        let mut line: Line;\n\n        line = Line::peek(\u0026mut buffer).unwrap();\n\n        if line.tag == \"GEDC\" {\n            Line::parse(\u0026mut buffer).unwrap();\n\n            while !buffer.is_empty() {\n                // Peek the next line\n                line = Line::peek(\u0026mut buffer).unwrap();\n                match line.tag {\n                    \"FORM\" =\u003e {\n                        (buffer, gedc.form) = Form::parse(buffer);\n                    }\n                    \"VERS\" =\u003e {\n                        // consume the line\n                        line = Line::parse(\u0026mut buffer).unwrap();\n                        gedc.version = Some(line.value.to_string());\n                    }\n                    _ =\u003e {\n                        // panic!(\"Unknown tag: {}\", line.tag);\n                        break;\n                    }\n                }\n            }\n        }\n\n        (buffer, Some(gedc))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Gedc;\n\n    #[test]\n    fn parse() {\n        let data = vec![\n            \"1 GEDC\",\n            \"2 VERS 5.5.5\",\n            \"2 FORM LINEAGE-LINKED\",\n            \"3 VERS 5.5.5\",\n        ];\n\n        let (_data, _gedc) = Gedc::parse(\u0026data.join(\"\\n\"));\n        let gedc = _gedc.unwrap();\n        let form = gedc.form.unwrap();\n\n        assert!(gedc.version == Some(\"5.5.5\".to_string()));\n\n        assert!(form.name == Some(\"LINEAGE-LINKED\".to_string()));\n        assert!(form.version == Some(\"5.5.5\".to_string()));\n\n        // // verify that the entire buffer has been consumed\n        // assert!(_data.is_empty())\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":29,"coverable":29},{"path":["/","Users","adam","src","rust-gedcom","src","types","header.rs"],"content":"use crate::parse;\n// use crate::types::corporation;\n// use crate::types::Copyright;\n// use crate::types::Note;\nuse crate::types::{Source, Submitter};\n\nuse super::DateTime;\nuse super::Gedc;\nuse super::Line;\n\n/*\nHEADER:= n HEAD\n+1 SOUR \u003cAPPROVED_SYSTEM_ID\u003e\n    +2 VERS \u003cVERSION_NUMBER\u003e\n    +2 NAME \u003cNAME_OF_PRODUCT\u003e\n    +2 CORP \u003cNAME_OF_BUSINESS\u003e\n        +3 \u003c\u003cADDRESS_STRUCTURE\u003e\u003e\n    +2 DATA \u003cNAME_OF_SOURCE_DATA\u003e\n        +3 DATE \u003cPUBLICATION_DATE\u003e\n        +3 COPR \u003cCOPYRIGHT_SOURCE_DATA\u003e\n        +4 [CONT|CONC]\u003cCOPYRIGHT_SOURCE_DATA\u003e\n+1 DEST \u003cRECEIVING_SYSTEM_NAME\u003e\n+1 DATE \u003cTRANSMISSION_DATE\u003e\n    +2 TIME \u003cTIME_VALUE\u003e\n+1 SUBM @\u003cXREF:SUBM\u003e@\n+1 SUBN @\u003cXREF:SUBN\u003e@\n+1 FILE \u003cFILE_NAME\u003e\n+1 COPR \u003cCOPYRIGHT_GEDCOM_FILE\u003e +1 GEDC\n    +2 VERS \u003cVERSION_NUMBER\u003e\n    +2 FORM \u003cGEDCOM_FORM\u003e +1 CHAR \u003cCHARACTER_SET\u003e\n    +2 VERS \u003cVERSION_NUMBER\u003e +1 LANG \u003cLANGUAGE_OF_TEXT\u003e +1 PLAC\n    +2 FORM \u003cPLACE_HIERARCHY\u003e\n+1 NOTE \u003cGEDCOM_CONTENT_DESCRIPTION\u003e\n    +2 [CONC|CONT] \u003cGEDCOM_CONTENT_DESCRIPTION\u003e\n*/\n\n#[derive(Debug, Default)]\n#[cfg_attr(feature = \"json\", derive(Serialize, Deserialize))]\npub struct Header {\n    pub encoding: Option\u003cString\u003e,\n    pub copyright: Option\u003cString\u003e,\n    pub date: Option\u003cDateTime\u003e,\n    pub destination: Option\u003cString\u003e,\n    pub gedcom_version: Option\u003cGedc\u003e,\n    pub language: Option\u003cString\u003e,\n    pub filename: Option\u003cString\u003e,\n    pub note: Option\u003cString\u003e,\n    pub source: Option\u003cSource\u003e,\n    pub submitter: Option\u003cSubmitter\u003e,\n    pub submission: Option\u003cString\u003e,\n}\n\nimpl Header {\n    pub fn parse(mut record: String) -\u003e Header {\n        let mut header = Header {\n            encoding: None,\n            copyright: None,\n            // corporation: None,\n            date: None,\n            destination: None,\n            gedcom_version: None,\n            language: None,\n            filename: None,\n            note: None,\n            source: None,\n            submitter: None,\n            submission: None,\n        };\n\n        // do parser stuff here\n        while !record.is_empty() {\n            let mut buffer: \u0026str = record.as_str();\n            let line = Line::peek(\u0026mut buffer).unwrap();\n\n            // Inspect the top-level tags only.\n            if line.level == 0 \u0026\u0026 line.tag == \"HEAD\" {\n                // Consume the line\n                // println!(\"Consuming HEAD\");\n                // (buffer, _) = Line::parse(\u0026record).unwrap();\n                Line::parse(\u0026mut buffer).unwrap();\n            } else if line.level == 1 {\n                // println!(\"Found an inner tag: {}\", line.tag);\n                match line.tag {\n                    \"CHAR\" =\u003e {\n                        header.encoding = Some(line.value.to_string());\n                        // (buffer, _) = Line::parse(\u0026record).unwrap();\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"COPR\" =\u003e {\n                        // println!(\"Input before copyright: '{}'\", buffer);\n                        header.copyright = parse::get_tag_value(\u0026mut buffer).unwrap();\n                        // println!(\"Input after copyright: '{}'\", buffer);\n                        // (buffer, header.copyright) = parse::get_tag_value(\u0026record).unwrap();\n\n                        // header.copyright = Some(line.value.unwrap_or(\"\").to_string());\n                        // (buffer, _) = Line::parse(\u0026record).unwrap();\n                        // (buffer, header.copyright) = Copyright::parse(\u0026record);\n                    }\n                    // \"CORP\" =\u003e {\n                    //     println!(\"parsing CORP\");\n                    //     (buffer, header.corporation) = corporation::Corporation::parse(\u0026record);\n                    // }\n                    \"DATE\" =\u003e {\n                        // We're doing lazy parsing of the date, because parsing\n                        // date strings is hard. For now.\n                        (buffer, header.date) = DateTime::parse(\u0026record);\n                    }\n                    \"DEST\" =\u003e {\n                        header.destination = Some(line.value.to_string());\n                        // (buffer, _) = Line::parse(\u0026record).unwrap();\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"FILE\" =\u003e {\n                        header.filename = Some(line.value.to_string());\n                        // (buffer, _) = Line::parse(\u0026record).unwrap();\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"GEDC\" =\u003e {\n                        (buffer, header.gedcom_version) = Gedc::parse(\u0026record);\n                    }\n                    \"LANG\" =\u003e {\n                        header.language = Some(line.value.to_string());\n                        // (buffer, _) = Line::parse(\u0026record).unwrap();\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"NOTE\" =\u003e {\n                        // This is just parsing the value of a line, and any\n                        // CONC/CONT that follows. Rewrite\n                        header.note = parse::get_tag_value(\u0026mut buffer).unwrap();\n                        // (buffer, header.note) = parse::get_tag_value(\u0026record).unwrap();\n                        // let note: Option\u003cNote\u003e;\n                        // (buffer, note) = Note::parse(\u0026record);\n                        // header.note = note;\n                    }\n                    \"SOUR\" =\u003e {\n                        (buffer, header.source) = Source::parse(\u0026record);\n                    }\n                    \"SUBM\" =\u003e {\n                        (buffer, header.submitter) = Submitter::parse(\u0026record);\n                    }\n                    _ =\u003e {\n                        // println!(\"Unhandled header tag: {}\", line.tag);\n                        // (buffer, _) = Line::parse(\u0026record).unwrap();\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                };\n            } else {\n                // (buffer, _) = Line::parse(\u0026record).unwrap();\n                Line::parse(\u0026mut buffer).unwrap();\n            }\n\n            record = buffer.to_string();\n        }\n        header\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::types::{corporation::Corporation, Address, DateTime, Form};\n\n    use super::Header;\n\n    #[test]\n    fn parse_header() {\n        let data = vec![\n            \"0 HEAD\",\n            \"1 CHAR UTF-8\",\n            \"1 SOUR Ancestry.com Family Trees\",\n            \"2 DATA Name of source data\",\n            \"3 DATE 1 JAN 1998\",\n            \"3 COPR Copyright of source data\",\n            \"2 VERS (2010.3)\",\n            \"2 NAME Ancestry.com Family Trees\",\n            \"2 CORP Ancestry.com\",\n            \"3 ADDR\",\n            \"4 ADR1 Example Software\",\n            \"4 ADR2 123 Main Street\",\n            \"4 ADR3 Ste 1\",\n            \"4 CITY Anytown\",\n            \"4 STAE IL\",\n            \"4 POST 55555\",\n            \"4 CTRY USA\",\n            \"3 PHON +1-800-555-1111\",\n            \"3 PHON +1-800-555-1212\",\n            \"3 PHON +1-800-555-1313\",\n            \"3 EMAIL a@example.com\",\n            \"3 EMAIL b@example.com\",\n            \"3 EMAIL c@example.com\",\n            \"3 FAX +1-800-555-1414\",\n            \"3 FAX +1-800-555-1515\",\n            \"3 FAX +1-800-555-1616\",\n            \"3 WWW https://www.example.com\",\n            \"3 WWW https://www.example.org\",\n            \"3 WWW https://www.example.net\",\n            \"1 SUBM @U1@\",\n            \"1 GEDC\",\n            \"2 VERS 5.5\",\n            \"2 FORM LINEAGE-LINKED\",\n            \"3 VERS 5.5\",\n            \"1 COPR A copyright statement\",\n            \"1 LANG English\",\n            \"1 DATE 1 JAN 2023\",\n            \"2 TIME 12:13:14.15\",\n            // The submitter record\n            \"0 @U1@ SUBM\",\n            \"1 NAME Adam Israel\",\n            \"1 ADDR\",\n            \"2 ADR1 Example Software\",\n            \"2 ADR2 123 Main Street\",\n            \"2 ADR3 Ste 1\",\n            \"2 CITY Anytown\",\n            \"2 STAE IL \",\n            \"2 POST 55555\",\n            \"2 CTRY USA\",\n            \"1 PHON +1-800-555-1111\",\n            \"1 PHON +1-800-555-1212\",\n            \"1 PHON +1-800-555-1313\",\n            \"1 EMAIL a@@example.com\",\n            \"1 EMAIL b@@example.com\",\n            \"1 EMAIL c@@example.com\",\n            \"1 FAX +1-800-555-1414\",\n            \"1 FAX +1-800-555-1515\",\n            \"1 FAX +1-800-555-1616\",\n            \"1 WWW https://www.example.com\",\n            \"1 WWW https://www.example.org\",\n            \"1 WWW https://www.example.net\",\n            \"1 OBJE @M1@\",\n            \"1 RIN 1\",\n            \"1 CHAN\",\n            \"2 DATE 7 SEP 2000\",\n            \"3 TIME 8:35:36\",\n        ];\n\n        let header = Header::parse(data.join(\"\\n\"));\n\n        // encoding\n        assert!(header.encoding.is_some());\n        assert!(header.encoding == Some(\"UTF-8\".to_string()));\n\n        // copyright\n        assert!(header.copyright.is_some());\n        assert!(header.copyright == Some(\"A copyright statement\".to_string()));\n\n        // source\n        assert!(header.source.is_some());\n        assert!(header.source.as_ref().unwrap().source == \"Ancestry.com Family Trees\".to_string());\n        assert!(header.source.as_ref().unwrap().version == Some(\"(2010.3)\".to_string()));\n\n        assert!(\n            header\n                .source\n                .as_ref()\n                .unwrap()\n                .data\n                .as_ref()\n                .unwrap()\n                .copyright\n                == Some(\"Copyright of source data\".to_string())\n        );\n        assert!(\n            header.source.as_ref().unwrap().data.as_ref().unwrap().date\n                == Some(DateTime {\n                    date: Some(\"1 JAN 1998\".to_string()),\n                    time: None,\n                })\n        );\n        assert!(\n            header.source.as_ref().unwrap().data.as_ref().unwrap().name\n                == Some(\"Name of source data\".to_string())\n        );\n\n        assert!(\n            header.source.as_ref().unwrap().name == Some(\"Ancestry.com Family Trees\".to_string())\n        );\n        assert!(\n            header.source.as_ref().unwrap().corporation\n                == Some(Corporation {\n                    name: Some(\"Ancestry.com\".to_string()),\n                    address: Some(Address {\n                        addr1: Some(\"Example Software\".to_string()),\n                        addr2: Some(\"123 Main Street\".to_string()),\n                        addr3: Some(\"Ste 1\".to_string()),\n                        city: Some(\"Anytown\".to_string()),\n                        state: Some(\"IL\".to_string()),\n                        postal_code: Some(\"55555\".to_string()),\n                        country: Some(\"USA\".to_string()),\n                        phone: vec![\n                            \"+1-800-555-1111\".to_string(),\n                            \"+1-800-555-1212\".to_string(),\n                            \"+1-800-555-1313\".to_string(),\n                        ],\n                        email: vec![\n                            \"a@example.com\".to_string(),\n                            \"b@example.com\".to_string(),\n                            \"c@example.com\".to_string(),\n                        ],\n                        fax: vec![\n                            \"+1-800-555-1414\".to_string(),\n                            \"+1-800-555-1515\".to_string(),\n                            \"+1-800-555-1616\".to_string(),\n                        ],\n                        www: vec![\n                            \"https://www.example.com\".to_string(),\n                            \"https://www.example.org\".to_string(),\n                            \"https://www.example.net\".to_string(),\n                        ],\n                    })\n                })\n        );\n\n        // Version\n        assert!(\n            header.gedcom_version.as_ref().unwrap().form\n                == Some(Form {\n                    name: Some(\"LINEAGE-LINKED\".to_string()),\n                    version: Some(\"5.5\".to_string()),\n                })\n        );\n        assert!(header.gedcom_version.as_ref().unwrap().version == Some(\"5.5\".to_string()));\n\n        // language\n        assert!(header.language.is_some());\n        assert!(header.language == Some(\"English\".to_string()));\n\n        // datetime\n        assert!(header.date.is_some());\n        assert!(\n            header.date\n                == Some(DateTime {\n                    date: Some(\"1 JAN 2023\".to_string()),\n                    time: Some(\"12:13:14.15\".to_string())\n                })\n        );\n\n        // submitter\n        assert!(header.submitter.is_some());\n    }\n}\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":37,"coverable":37},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","adoption.rs"],"content":"use crate::types::{Family, Line};\n\nuse winnow::prelude::*;\n\nuse super::IndividualEventDetail;\n\n// n ADOP {1:1}\n// +1 \u003c\u003cINDIVIDUAL_EVENT_DETAIL\u003e\u003e {0:1}* p.34\n// +1 FAMC @\u003cXREF:FAM\u003e@ {0:1} p.24\n//    +2 ADOP \u003cADOPTED_BY_WHICH_PARENT\u003e {0:1} p.42\n\n#[derive(Clone, Debug, Default)]\npub struct Adoption {\n    pub event: IndividualEventDetail,\n    pub family: Option\u003cFamily\u003e,\n}\n\nimpl Adoption {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cAdoption\u003e {\n        let mut adoption = Adoption {\n            event: IndividualEventDetail::new(),\n            family: None,\n        };\n\n        let line = Line::parse(record).unwrap();\n        let level = line.level;\n        let mut events: Vec\u003cString\u003e = vec![];\n\n        // Add the first line so EventDetails will parse cleanly\n        events.push(line.to_string());\n\n        while !record.is_empty() {\n            let line = Line::peek(record).unwrap();\n            if line.level \u003c= level {\n                break;\n            }\n            let mut consume = true;\n            match line.tag {\n                \"FAMC\" =\u003e {\n                    let famc = Family::parse(record);\n                    adoption.family = Some(famc);\n                    consume = false;\n                }\n                _ =\u003e {\n                    // This works right now, in this use-case, but what if a struct\n                    // composites more than one structure?\n\n                    // add the line to events, so we can parse them all at once\n                    // as part of the Event Detail\n                    events.push(line.to_string());\n                }\n            }\n            // line = Line::parse(record).unwrap();\n            if consume {\n                Line::parse(record).unwrap();\n            }\n        }\n\n        // Now parse the events\n        if !events.is_empty() {\n            // Remove the last line; it belongs to the next record\n            // println!(\"DELETE: {:?}\", events.pop());\n            let event = events.join(\"\\n\");\n            let mut event_str = event.as_str();\n            // println!(\"parsing --\\n{}\", event_str);\n            adoption.event = IndividualEventDetail::parse(\u0026mut event_str).unwrap();\n        }\n\n        Ok(adoption)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    fn parse_adoption() {\n        let data = vec![\n            \"1 BIRT\",\n            \"2 TYPE Normal\",\n            \"2 DATE 31 DEC 1965\",\n            \"2 PLAC Salt Lake City, UT, USA\",\n            \"3 FONE Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 ROMN Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 MAP\",\n            \"4 LATI N0\",\n            \"4 LONG E0\",\n            \"3 NOTE Some place notes.\",\n            \"2 ADDR\",\n            \"3 ADR1 St. Marks Hospital\",\n            \"3 CITY Salt Lake City\",\n            \"3 STAE UT\",\n            \"3 POST 84121\",\n            \"3 CTRY USA\",\n            \"2 AGNC none\",\n            \"2 RELI Religion\",\n            \"2 CAUS Conception\",\n            \"2 NOTE Some notes.\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE Some notes about this adoption source citation which are embedded in the citation \",\n            \"4 CONC structure itself.\",\n            \"3 QUAY 2\",\n            \"2 OBJE @M15@\",\n            \"2 AGE 0y\",\n            \"2 FAMC @F2@\",\n        ].join(\"\\n\");\n\n        let mut record = data.as_str();\n        let adoption = Adoption::parse(\u0026mut record).unwrap();\n\n        let mut event = adoption.event;\n        assert!(event.detail.date.is_some());\n        assert!(event.detail.r#type.is_some());\n\n        let place = event.detail.place.unwrap();\n        assert!(place.name.is_some());\n        assert!(place.note.is_some());\n        assert!(place.note.unwrap().note.unwrap() == \"Some place notes.\");\n\n        let addr = event.detail.address.unwrap();\n        assert!(addr.addr1.is_some());\n        assert!(addr.city.is_some());\n        assert!(addr.state.is_some());\n\n        assert!(event.detail.agency.is_some());\n        assert!(event.detail.agency.unwrap() == \"none\");\n\n        assert!(event.detail.religion.is_some());\n        assert!(event.detail.religion.unwrap() == \"Religion\");\n\n        assert!(event.detail.cause.is_some());\n        assert!(event.detail.cause.unwrap() == \"Conception\");\n\n        // assert!(adoption.event_type_cited_from.is_some());\n        // let event_type = adoption.event_type_cited_from.unwrap();\n        // assert!(event_type.r#type.unwrap() == \"BIRT\");\n        // assert!(event_type.role.unwrap() == \"CHIL\");\n\n        assert!(event.detail.note.is_some());\n        assert!(event.detail.note.unwrap() == \"Some notes.\");\n\n        // assert!(place.name.unwrap() == \"\");\n\n        assert!(event.detail.media.len() == 1);\n        let obje = event.detail.media.pop().unwrap();\n        assert!(obje.xref == \"@M15@\");\n\n        assert!(event.age.unwrap() == \"0y\");\n\n        assert!(adoption.family.unwrap().xref == \"@F2@\");\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":123},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":25,"coverable":25},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","birth.rs"],"content":"use crate::types::{Family, Line};\n\nuse winnow::prelude::*;\n\nuse super::IndividualEventDetail;\n\n// n [ BIRT | CHR ] [Y|\u003cNULL\u003e] {1:1}\n// +1 \u003c\u003cINDIVIDUAL_EVENT_DETAIL\u003e\u003e {0:1}* p.34\n// +1 FAMC @\u003cXREF:FAM\u003e@\n\n// EVENT_DETAIL:=\n// n TYPE \u003cEVENT_OR_FACT_CLASSIFICATION\u003e {0:1} p.49\n// n DATE \u003cDATE_VALUE\u003e {0:1} p.47, 46\n// n \u003c\u003cPLACE_STRUCTURE\u003e\u003e {0:1} p.38\n// n \u003c\u003cADDRESS_STRUCTURE\u003e\u003e {0:1} p.31\n// n AGNC \u003cRESPONSIBLE_AGENCY\u003e {0:1} p.60\n// n RELI \u003cRELIGIOUS_AFFILIATION\u003e {0:1} p.60\n// n CAUS \u003cCAUSE_OF_EVENT\u003e {0:1} p.43\n// n RESN \u003cRESTRICTION_NOTICE\u003e {0:1} p.60\n// n \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// n \u003c\u003cSOURCE_CITATION\u003e\u003e {0:M} p.39\n// n \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n// FAMILY\n\n#[derive(Clone, Debug, Default)]\npub struct Birth {\n    pub event: IndividualEventDetail,\n    // pub event_type_cited_from: Option\u003cEventTypeCitedFrom\u003e,\n    pub family: Option\u003cFamily\u003e,\n    pub preferred: bool,\n}\n\nimpl Birth {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cBirth\u003e {\n        let mut birth = Birth {\n            event: IndividualEventDetail::new(),\n            // event_type_cited_from: None,\n            family: None,\n            preferred: false,\n        };\n\n        let line = Line::parse(record).unwrap();\n        let level = line.level;\n        let mut events: Vec\u003cString\u003e = vec![];\n\n        // Add the first line so EventDetails will parse cleanly\n        events.push(line.to_string());\n\n        while !record.is_empty() {\n            let line = Line::peek(record).unwrap();\n            if line.level \u003c= level {\n                break;\n            }\n\n            match line.tag {\n                // \"AGE\" =\u003e {\n                //     birth.age = Some(line.value.to_string());\n                // }\n                \"FAMC\" =\u003e {\n                    let famc = Family {\n                        adopted_by: None,\n                        xref: line.value.to_string(),\n                        notes: vec![],\n                        pedigree: None,\n                    };\n                    birth.family = Some(famc);\n                }\n                _ =\u003e {\n                    // This works right now, in this use-case, but what if a struct\n                    // composites more than one structure?\n\n                    // add the line to events, so we can parse them all at once\n                    // as part of the Event Detail\n                    events.push(line.to_string());\n                }\n            }\n            // line = Line::parse(record).unwrap();\n\n            Line::parse(record).unwrap();\n        }\n\n        // Now parse the events\n        if !events.is_empty() {\n            // Remove the last line; it belongs to the next record\n            // println!(\"DELETE: {:?}\", events.pop());\n            let event = events.join(\"\\n\");\n            let mut event_str = event.as_str();\n            // println!(\"parsing --\\n{}\", event_str);\n            birth.event = IndividualEventDetail::parse(\u0026mut event_str).unwrap();\n        }\n\n        Ok(birth)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    fn parse_birth() {\n        let data = vec![\n            \"1 BIRT\",\n            \"2 TYPE Normal\",\n            \"2 DATE 31 DEC 1965\",\n            \"2 PLAC Salt Lake City, UT, USA\",\n            \"3 FONE Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 ROMN Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 MAP\",\n            \"4 LATI N0\",\n            \"4 LONG E0\",\n            \"3 NOTE Some place notes.\",\n            \"2 ADDR\",\n            \"3 ADR1 St. Marks Hospital\",\n            \"3 CITY Salt Lake City\",\n            \"3 STAE UT\",\n            \"3 POST 84121\",\n            \"3 CTRY USA\",\n            \"2 AGNC none\",\n            \"2 RELI Religion\",\n            \"2 CAUS Conception\",\n            \"2 NOTE Some notes.\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE Some notes about this birth source citation which are embedded in the citation \",\n            \"4 CONC structure itself.\",\n            \"3 QUAY 2\",\n            \"2 OBJE @M15@\",\n            \"2 AGE 0y\",\n            \"2 FAMC @F2@\",\n        ].join(\"\\n\");\n\n        let mut record = data.as_str();\n        let birth = Birth::parse(\u0026mut record).unwrap();\n\n        let mut event = birth.event;\n        assert!(event.detail.date.is_some());\n        assert!(event.detail.r#type.is_some());\n\n        let place = event.detail.place.unwrap();\n        assert!(place.name.is_some());\n        assert!(place.note.is_some());\n        assert!(place.note.unwrap().note.unwrap() == \"Some place notes.\");\n\n        let addr = event.detail.address.unwrap();\n        assert!(addr.addr1.is_some());\n        assert!(addr.city.is_some());\n        assert!(addr.state.is_some());\n\n        assert!(event.detail.agency.is_some());\n        assert!(event.detail.agency.unwrap() == \"none\");\n\n        assert!(event.detail.religion.is_some());\n        assert!(event.detail.religion.unwrap() == \"Religion\");\n\n        assert!(event.detail.cause.is_some());\n        assert!(event.detail.cause.unwrap() == \"Conception\");\n\n        // assert!(birth.event_type_cited_from.is_some());\n        // let event_type = birth.event_type_cited_from.unwrap();\n        // assert!(event_type.r#type.unwrap() == \"BIRT\");\n        // assert!(event_type.role.unwrap() == \"CHIL\");\n\n        assert!(event.detail.note.is_some());\n        assert!(event.detail.note.unwrap() == \"Some notes.\");\n\n        // assert!(place.name.unwrap() == \"\");\n\n        assert!(event.detail.media.len() == 1);\n        let obje = event.detail.media.pop().unwrap();\n        assert!(obje.xref == \"@M15@\");\n\n        assert!(event.age.unwrap() == \"0y\");\n\n        assert!(birth.family.unwrap().xref == \"@F2@\");\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":141},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":141},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":130},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":124},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":124},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":15},"fn_name":null}],"covered":23,"coverable":23},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","christening.rs"],"content":"use crate::types::{Family, Line};\n\nuse winnow::prelude::*;\n\nuse super::IndividualEventDetail;\n\n// n [ BIRT | CHR ] [Y|\u003cNULL\u003e] {1:1}\n// +1 \u003c\u003cINDIVIDUAL_EVENT_DETAIL\u003e\u003e {0:1}* p.34\n// +1 FAMC @\u003cXREF:FAM\u003e@\n\n#[derive(Clone, Debug, Default)]\npub struct Christening {\n    pub event: IndividualEventDetail,\n    pub family: Option\u003cFamily\u003e,\n}\n\nimpl Christening {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cChristening\u003e {\n        let mut christening = Christening {\n            event: IndividualEventDetail::new(),\n            family: None,\n        };\n\n        let line = Line::parse(record).unwrap();\n        let level = line.level;\n        let mut events: Vec\u003cString\u003e = vec![];\n\n        // Add the first line so EventDetails will parse cleanly\n        events.push(line.to_string());\n\n        while !record.is_empty() {\n            let line = Line::peek(record).unwrap();\n            if line.level \u003c= level {\n                break;\n            }\n\n            match line.tag {\n                \"FAMC\" =\u003e {\n                    let famc = Family {\n                        adopted_by: None,\n                        xref: line.value.to_string(),\n                        notes: vec![],\n                        pedigree: None,\n                    };\n                    christening.family = Some(famc);\n                }\n                _ =\u003e {\n                    // This works right now, in this use-case, but what if a struct\n                    // composites more than one structure?\n\n                    // add the line to events, so we can parse them all at once\n                    // as part of the Event Detail\n                    events.push(line.to_string());\n                }\n            }\n            // line = Line::parse(record).unwrap();\n\n            Line::parse(record).unwrap();\n        }\n\n        // Now parse the events\n        if !events.is_empty() {\n            // Remove the last line; it belongs to the next record\n            // println!(\"DELETE: {:?}\", events.pop());\n            let event = events.join(\"\\n\");\n            let mut event_str = event.as_str();\n            // println!(\"parsing --\\n{}\", event_str);\n            christening.event = IndividualEventDetail::parse(\u0026mut event_str).unwrap();\n        }\n\n        Ok(christening)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    fn parse_christening() {\n        let data = vec![\n            \"1 BIRT\",\n            \"2 TYPE Normal\",\n            \"2 DATE 31 DEC 1965\",\n            \"2 PLAC Salt Lake City, UT, USA\",\n            \"3 FONE Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 ROMN Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 MAP\",\n            \"4 LATI N0\",\n            \"4 LONG E0\",\n            \"3 NOTE Some place notes.\",\n            \"2 ADDR\",\n            \"3 ADR1 St. Marks Hospital\",\n            \"3 CITY Salt Lake City\",\n            \"3 STAE UT\",\n            \"3 POST 84121\",\n            \"3 CTRY USA\",\n            \"2 AGNC none\",\n            \"2 RELI Religion\",\n            \"2 CAUS Conception\",\n            \"2 NOTE Some notes.\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE Some notes about this christening source citation which are embedded in the citation \",\n            \"4 CONC structure itself.\",\n            \"3 QUAY 2\",\n            \"2 OBJE @M15@\",\n            \"2 AGE 0y\",\n            \"2 FAMC @F2@\",\n        ].join(\"\\n\");\n\n        let mut record = data.as_str();\n        let christening = Christening::parse(\u0026mut record).unwrap();\n\n        let mut event = christening.event;\n        assert!(event.detail.date.is_some());\n        assert!(event.detail.r#type.is_some());\n\n        let place = event.detail.place.unwrap();\n        assert!(place.name.is_some());\n        assert!(place.note.is_some());\n        assert!(place.note.unwrap().note.unwrap() == \"Some place notes.\");\n\n        let addr = event.detail.address.unwrap();\n        assert!(addr.addr1.is_some());\n        assert!(addr.city.is_some());\n        assert!(addr.state.is_some());\n\n        assert!(event.detail.agency.is_some());\n        assert!(event.detail.agency.unwrap() == \"none\");\n\n        assert!(event.detail.religion.is_some());\n        assert!(event.detail.religion.unwrap() == \"Religion\");\n\n        assert!(event.detail.cause.is_some());\n        assert!(event.detail.cause.unwrap() == \"Conception\");\n\n        // assert!(christening.event_type_cited_from.is_some());\n        // let event_type = christening.event_type_cited_from.unwrap();\n        // assert!(event_type.r#type.unwrap() == \"BIRT\");\n        // assert!(event_type.role.unwrap() == \"CHIL\");\n\n        assert!(event.detail.note.is_some());\n        assert!(event.detail.note.unwrap() == \"Some notes.\");\n\n        // assert!(place.name.unwrap() == \"\");\n\n        assert!(event.detail.media.len() == 1);\n        let obje = event.detail.media.pop().unwrap();\n        assert!(obje.xref == \"@M15@\");\n\n        assert!(event.age.unwrap() == \"0y\");\n\n        assert!(christening.family.unwrap().xref == \"@F2@\");\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":23,"coverable":23},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","death.rs"],"content":"use crate::types::{EventDetail, EventTypeCitedFrom, Family, Line};\n\nuse winnow::prelude::*;\n\n// n [ BIRT | CHR ] [Y|\u003cNULL\u003e] {1:1}\n// +1 \u003c\u003cINDIVIDUAL_EVENT_DETAIL\u003e\u003e {0:1}* p.34\n// +1 FAMC @\u003cXREF:FAM\u003e@\n\n// EVENT_DETAIL:=\n// n TYPE \u003cEVENT_OR_FACT_CLASSIFICATION\u003e {0:1} p.49\n// n DATE \u003cDATE_VALUE\u003e {0:1} p.47, 46\n// n \u003c\u003cPLACE_STRUCTURE\u003e\u003e {0:1} p.38\n// n \u003c\u003cADDRESS_STRUCTURE\u003e\u003e {0:1} p.31\n// n AGNC \u003cRESPONSIBLE_AGENCY\u003e {0:1} p.60\n// n RELI \u003cRELIGIOUS_AFFILIATION\u003e {0:1} p.60\n// n CAUS \u003cCAUSE_OF_EVENT\u003e {0:1} p.43\n// n RESN \u003cRESTRICTION_NOTICE\u003e {0:1} p.60\n// n \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// n \u003c\u003cSOURCE_CITATION\u003e\u003e {0:M} p.39\n// n \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n// FAMILY\n\n#[derive(Debug, Default)]\npub struct Death {\n    pub age: Option\u003cString\u003e,\n    pub event: Option\u003cEventDetail\u003e,\n    pub event_type_cited_from: Option\u003cEventTypeCitedFrom\u003e,\n    pub family: Option\u003cFamily\u003e,\n    pub preferred: bool,\n}\n\nimpl Death {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cDeath\u003e {\n        let mut death = Death {\n            age: None,\n            event: None,\n            event_type_cited_from: None,\n            family: None,\n            preferred: false,\n        };\n\n        let line = Line::parse(record).unwrap();\n        // TODO: This implies a death is known but the date is not.\n        // Is this effective as-is? It'll create an empty death record, so\n        // we have Some() in place, where if there is no death tag we would\n        // have None()\n        // 1 DEAT Y\n        let mut events: Vec\u003cString\u003e = vec![];\n\n        // Add the first line so EventDetails will parse cleanly\n        events.push(line.to_string());\n\n        while !record.is_empty() {\n            let line = Line::peek(record).unwrap();\n            if line.level == 1 {\n                break;\n            }\n            match line.tag {\n                \"AGE\" =\u003e {\n                    death.age = Some(line.value.to_string());\n                }\n                _ =\u003e {\n                    // This works right now, in this use-case, but what if a struct\n                    // composites more than one structure?\n\n                    // add the line to events, so we can parse them all at once\n                    // as part of the Event Detail\n                    events.push(line.to_string());\n                }\n            }\n\n            Line::parse(record).unwrap();\n        }\n\n        // Now parse the events\n        if !events.is_empty() {\n            let event = events.join(\"\\n\");\n            let mut event_str = event.as_str();\n            death.event = Some(EventDetail::parse(\u0026mut event_str).unwrap());\n        }\n\n        Ok(death)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    fn parse_death() {\n        let data = vec![\n            \"1 DEAT\",\n            \"2 DATE ABT 15 JAN 2001\",\n            \"2 PLAC New York, New York, USA\",\n            \"3 NOTE The place structure has more detail than usually used for places\",\n            \"2 AGE 76y\",\n            \"2 TYPE slow\",\n            \"2 ADDR\",\n            \"3 ADR1 at Home\",\n            \"2 CAUS Cancer\",\n            \"2 AGNC none\",\n            \"2 OBJE @M8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some death source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A death source note.\",\n            \"2 NOTE A death event note.\",\n        ]\n        .join(\"\\n\");\n\n        let mut record = data.as_str();\n        let death = Death::parse(\u0026mut record).unwrap();\n\n        let mut event = death.event.unwrap();\n        assert!(event.date.is_some());\n        assert!(event.r#type.is_some());\n\n        let place = event.place.unwrap();\n        assert!(place.name.is_some());\n        assert!(place.note.is_some());\n        assert!(\n            place.note.unwrap().note.unwrap()\n                == \"The place structure has more detail than usually used for places\"\n        );\n\n        let addr = event.address.unwrap();\n        assert!(addr.addr1.is_some());\n        assert!(addr.city.is_none());\n        assert!(addr.state.is_none());\n\n        assert!(event.agency.is_some());\n        assert!(event.agency.unwrap() == \"none\");\n\n        assert!(event.religion.is_none());\n\n        assert!(event.cause.is_some());\n        assert!(event.cause.unwrap() == \"Cancer\");\n\n        assert!(event.note.is_some());\n        assert!(event.note.unwrap() == \"A death event note.\");\n\n        assert!(event.media.len() == 1);\n        let obje = event.media.pop().unwrap();\n        assert!(obje.xref == \"@M8@\");\n\n        assert!(death.age.unwrap() == \"76y\");\n\n        assert!(death.family.is_none());\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":9},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","event.rs"],"content":"// Individual Event Detail\n// This is specific to Individual-related events such as birth or death,\n// building off of types.EventDetail\n\nuse winnow::prelude::*;\n\nuse crate::types::{EventDetail, Line};\n\n// INDIVIDUAL_EVENT_DETAIL:=\n// n \u003c\u003cEVENT_DETAIL\u003e\u003e {1:1} p.32\n// n AGE \u003cAGE_AT_EVENT\u003e {0:1} p.42\n\n#[derive(Clone, Debug, Default)]\npub struct IndividualEventDetail {\n    pub age: Option\u003cString\u003e,\n    pub detail: EventDetail,\n}\n\nimpl IndividualEventDetail {\n    /// Initialize an empty Individual Event Detail\n    pub fn new() -\u003e IndividualEventDetail {\n        IndividualEventDetail {\n            age: None,\n            detail: EventDetail {\n                r#type: None,\n                date: None,\n                place: None,\n                address: None,\n                agency: None,\n                religion: None,\n                cause: None,\n                restriction_notice: None,\n                note: None,\n                sources: vec![],\n                media: vec![],\n            },\n        }\n    }\n\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cIndividualEventDetail\u003e {\n        let mut event = IndividualEventDetail {\n            age: None,\n            detail: EventDetail {\n                r#type: None,\n                date: None,\n                place: None,\n                address: None,\n                agency: None,\n                religion: None,\n                cause: None,\n                restriction_notice: None,\n                note: None,\n                sources: vec![],\n                media: vec![],\n            },\n        };\n\n        let line = Line::parse(record).unwrap();\n        let level = line.level;\n        // [ ADOP | BIRT | BAPM | BARM | BASM |\n        // BLES | BURI | CENS | CHR | CHRA |\n        // CONF | CREM | DEAT | EMIG | FCOM |\n        // GRAD | IMMI | NATU | ORDN |\n        // RETI | PROB | WILL | EVEN ]\n        // if line.tag == \"BIRT\" || line.tag == \"BAPM\" {\n        //     Line::parse(record).unwrap();\n        // }\n        let mut events: Vec\u003cString\u003e = vec![];\n\n        // Add the first line so EventDetails will parse cleanly\n        events.push(line.to_string());\n\n        while !record.is_empty() {\n            let line = Line::peek(record).unwrap();\n            if line.level \u003c= level {\n                break;\n            }\n\n            match line.tag {\n                \"AGE\" =\u003e {\n                    event.age = Some(line.value.to_string());\n                }\n                _ =\u003e {\n                    // This works right now, in this use-case, but what if a struct\n                    // composites more than one structure?\n\n                    // add the line to events, so we can parse them all at once\n                    // as part of the Event Detail\n                    events.push(line.to_string());\n                }\n            }\n            Line::parse(record).unwrap();\n        }\n\n        // Now parse the events\n        if !events.is_empty() {\n            // Remove the last line; it belongs to the next record\n            // println!(\"DELETE: {:?}\", events.pop());\n            let event_s = events.join(\"\\n\");\n            let mut event_str = event_s.as_str();\n            // println!(\"parsing --\\n{}\", event_str);\n            event.detail = EventDetail::parse(\u0026mut event_str).unwrap();\n        }\n\n        Ok(event)\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":439},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":414},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":414},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":406},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":413},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":399},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":399},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":406},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":33},"fn_name":null}],"covered":23,"coverable":23},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","gender.rs"],"content":"use std::str::FromStr;\n\n#[derive(Default, Debug, PartialEq)]\n/// The Gender of the Individual\npub enum Gender {\n    Male,\n    Female,\n    Nonbinary,\n    #[default]\n    Unknown,\n}\n\nimpl FromStr for Gender {\n    type Err = ();\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cGender, Self::Err\u003e {\n        match input {\n            \"M\" =\u003e Ok(Gender::Male),\n            \"F\" =\u003e Ok(Gender::Female),\n            \"N\" =\u003e Ok(Gender::Nonbinary),\n            \"U\" =\u003e Ok(Gender::Unknown),\n            _ =\u003e Err(()),\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":7},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","individual.rs"],"content":"// use std::num::ParseIntError;\nuse std::str::FromStr;\n\nuse crate::types::individual::name::*;\nuse crate::types::{Family, Line};\n\nuse super::{Adoption, Birth, Christening, Death, IndividualEventDetail, Residence};\n// use super::SourceCitation;\n\n// n @XREF:INDI@ INDI\n// +1 RESN \u003cRESTRICTION_NOTICE\u003e\n// +1 \u003c\u003cPERSONAL_NAME_STRUCTURE\u003e\u003e\n// +1 SEX \u003cSEX_VALUE\u003e\n// +1 \u003c\u003cINDIVIDUAL_EVENT_STRUCTURE\u003e\u003e\n// +1 \u003c\u003cINDIVIDUAL_ATTRIBUTE_STRUCTURE\u003e\u003e +1 \u003c\u003cLDS_INDIVIDUAL_ORDINANCE\u003e\u003e\n// +1 \u003c\u003cCHILD_TO_FAMILY_LINK\u003e\u003e\n// +1 \u003c\u003cSPOUSE_TO_FAMILY_LINK\u003e\u003e\n// +1 SUBM @\u003cXREF:SUBM\u003e@\n// +1 \u003c\u003cASSOCIATION_STRUCTURE\u003e\u003e\n// +1 ALIA @\u003cXREF:INDI\u003e@\n// +1 ANCI @\u003cXREF:SUBM\u003e@\n// +1 DESI @\u003cXREF:SUBM\u003e@\n// +1 RFN \u003cPERMANENT_RECORD_FILE_NUMBER\u003e +1 AFN \u003cANCESTRAL_FILE_NUMBER\u003e\n// +1 REFN \u003cUSER_REFERENCE_NUMBER\u003e\n// +2 TYPE \u003cUSER_REFERENCE_TYPE\u003e +1 RIN \u003cAUTOMATED_RECORD_ID\u003e\n// +1 \u003c\u003cCHANGE_DATE\u003e\u003e\n// +1 \u003c\u003cNOTE_STRUCTURE\u003e\u003e\n// +1 \u003c\u003cSOURCE_CITATION\u003e\u003e +1 \u003c\u003cMULTIMEDIA_LINK\u003e\u003e\n#[derive(Debug, Default)]\npub struct Individual {\n    pub adoption: Vec\u003cAdoption\u003e,\n\n    pub birth: Vec\u003cBirth\u003e,\n    pub death: Vec\u003cDeath\u003e,\n\n    // Baptism-related fields\n    /// The event of baptism (not LDS), performed in infancy or later.\n    pub baptism: Vec\u003cIndividualEventDetail\u003e,\n    /// The ceremonial event held when a Jewish boy reaches age 13.\n    pub barmitzvah: Vec\u003cIndividualEventDetail\u003e,\n    /// The ceremonial event held when a Jewish girl reaches age 13.\n    pub basmitzvah: Vec\u003cIndividualEventDetail\u003e,\n    /// A religious event of bestowing divine care or intercession. Sometimes given in connection with anaming ceremony.\n    pub blessing: Vec\u003cIndividualEventDetail\u003e,\n\n    pub burial: Vec\u003cIndividualEventDetail\u003e,\n\n    /// The religious event (not LDS) of baptizing and/or naming a child.\n    pub christening: Vec\u003cChristening\u003e,\n\n    /// The religious event (not LDS) of baptizing and/or naming an adult person.\n    pub christening_adult: Vec\u003cChristening\u003e,\n\n    /// The religious event (not LDS) of conferring the gift of the Holy Ghost and, among protestants, full church membership.\n    pub confirmation: Vec\u003cIndividualEventDetail\u003e,\n\n    pub cremation: Vec\u003cIndividualEventDetail\u003e,\n\n    pub emigration: Vec\u003cIndividualEventDetail\u003e,\n\n    /// Generic events not covered by a specific type\n    pub events: Vec\u003cIndividualEventDetail\u003e,\n\n    pub gender: super::Gender,\n\n    pub graduation: Vec\u003cIndividualEventDetail\u003e,\n\n    pub immigration: Vec\u003cIndividualEventDetail\u003e,\n\n    pub residences: Vec\u003cResidence\u003e,\n    pub famc: Vec\u003cFamily\u003e,\n    pub fams: Vec\u003cFamily\u003e,\n\n    pub names: Vec\u003cPersonalName\u003e,\n\n    pub naturalization: Vec\u003cIndividualEventDetail\u003e,\n\n    pub probate: Vec\u003cIndividualEventDetail\u003e,\n\n    pub will: Vec\u003cIndividualEventDetail\u003e,\n\n    /// The XRef pointer associated with this individual\n    pub xref: Option\u003cString\u003e,\n}\n\n// impl\u003c'a\u003e Individual\u003c'a\u003e {\nimpl Individual {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e Individual {\n        // pub fn parse(mut record: String) -\u003e Individual {\n        let mut individual = Individual {\n            // sources: vec![],\n            adoption: vec![],\n            birth: vec![],\n            burial: vec![],\n            death: vec![],\n            baptism: vec![],\n            barmitzvah: vec![],\n            basmitzvah: vec![],\n            blessing: vec![],\n            christening: vec![],\n            christening_adult: vec![],\n            confirmation: vec![],\n            cremation: vec![],\n            emigration: vec![],\n            events: vec![],\n            famc: vec![],\n            fams: vec![],\n            gender: super::Gender::Unknown,\n            graduation: vec![],\n            immigration: vec![],\n            names: vec![],\n\n            naturalization: vec![],\n            probate: vec![],\n            residences: vec![],\n            will: vec![],\n\n            xref: None,\n        };\n\n        while !record.is_empty() {\n            let line = Line::peek(record).unwrap();\n\n            // Flag to track if we should consume the next line in record\n            let mut parse = true;\n\n            match line.level {\n                0 =\u003e {\n                    individual.xref = Some(line.xref.to_string());\n                }\n                1 =\u003e {\n                    // println!(\"TAG: {}\", line.tag);\n                    match line.tag {\n                        \"NAME\" =\u003e {\n                            let pn = PersonalName::parse(record).unwrap();\n                            individual.names.push(pn);\n                            parse = false;\n                        }\n                        \"SEX\" =\u003e {\n                            // individual.gender =\n                            //     super::Gender::from_str(line.value.unwrap_or(\"U\")).unwrap();\n                            individual.gender = super::Gender::from_str(line.value).unwrap();\n                            // println!(\"Next line: {:?}\", Line::peek(record).unwrap());\n                        }\n                        \"BIRT\" =\u003e {\n                            let mut birth = Birth::parse(record).unwrap();\n                            // The first record found is the preferred record\n                            if individual.birth.is_empty() {\n                                birth.preferred = true;\n                            }\n                            individual.birth.push(birth);\n                            parse = false;\n                        }\n                        \"DEAT\" =\u003e {\n                            // TODO: Support 1 DEAT Y\n                            let mut death = Death::parse(record).unwrap();\n                            if individual.death.is_empty() {\n                                death.preferred = true;\n                            }\n                            individual.death.push(death);\n                            parse = false;\n                        }\n                        \"FAMS\" =\u003e {\n                            let fam = Family::parse(record);\n                            individual.fams.push(fam);\n                            parse = false;\n                        }\n                        \"FAMC\" =\u003e {\n                            let fam = Family::parse(record);\n                            individual.famc.push(fam);\n                            parse = false;\n                        }\n                        // baptism\n                        \"BAPM\" =\u003e {\n                            let baptism = IndividualEventDetail::parse(record).unwrap();\n                            individual.baptism.push(baptism);\n                            parse = false;\n                        }\n                        // christening\n                        \"CHR\" =\u003e {\n                            let christening = Christening::parse(record).unwrap();\n                            individual.christening.push(christening);\n                            parse = false;\n                        }\n                        // bar mitzvah\n                        \"BARM\" =\u003e {\n                            let bar = IndividualEventDetail::parse(record).unwrap();\n                            individual.barmitzvah.push(bar);\n                            parse = false;\n                        }\n                        // bas mitzvah\n                        \"BASM\" =\u003e {\n                            let bar = IndividualEventDetail::parse(record).unwrap();\n                            individual.basmitzvah.push(bar);\n                            parse = false;\n                        }\n                        // blessing\n                        \"BLES\" =\u003e {\n                            // TODO: Need to add tests for this\n                            let blessing = IndividualEventDetail::parse(record).unwrap();\n                            individual.blessing.push(blessing);\n                            parse = false;\n                        }\n                        // Adoption\n                        \"ADOP\" =\u003e {\n                            let adoption = Adoption::parse(record).unwrap();\n                            individual.adoption.push(adoption);\n                            parse = false;\n                        }\n                        // Adult Christening\n                        \"CHRA\" =\u003e {\n                            let christening = Christening::parse(record).unwrap();\n                            individual.christening_adult.push(christening);\n                            parse = false;\n                        }\n                        // Confirmation\n                        \"CONF\" =\u003e {\n                            let confirmation = IndividualEventDetail::parse(record).unwrap();\n                            individual.confirmation.push(confirmation);\n                            parse = false;\n                        }\n                        \"FCOM\" =\u003e {}\n                        \"GRAD\" =\u003e {}\n                        \"EMIG\" =\u003e {}\n                        \"IMMI\" =\u003e {}\n                        \"NATU\" =\u003e {}\n                        \"CENS\" =\u003e {}\n                        \"RETI\" =\u003e {}\n                        // probate\n                        \"PROB\" =\u003e {}\n                        \"BURI\" =\u003e {}\n                        \"WILL\" =\u003e {}\n                        \"CREM\" =\u003e {}\n                        // generic event\n                        \"EVEN\" =\u003e {}\n                        // residence\n                        \"RESI\" =\u003e {}\n                        // occupation\n                        \"OCCU\" =\u003e {}\n                        \"EDUC\" =\u003e {}\n                        // physical description\n                        \"DSCR\" =\u003e {}\n                        // religion\n                        \"RELI\" =\u003e {}\n                        // national identification number\n                        \"IDNO\" =\u003e {}\n                        // property/possessions\n                        \"PROP\" =\u003e {}\n                        // cast(e) name?\n                        \"CAST\" =\u003e {}\n                        // number of children\n                        \"NCHI\" =\u003e {}\n                        // number of marriages\n                        \"NMR\" =\u003e {}\n                        // nobility title\n                        \"TITL\" =\u003e {}\n                        // national or tribe origin\n                        \"NATI\" =\u003e {}\n                        \"NOTE\" =\u003e {}\n                        // source records\n                        \"SOUR\" =\u003e {}\n                        // multimedia links\n                        \"OBJE\" =\u003e {}\n                        \"ASSO\" =\u003e {}\n                        \"REFN\" =\u003e {}\n                        \"RIN\" =\u003e {}\n                        \"CHAN\" =\u003e {}\n                        _ =\u003e {\n                            println!(\"Unknown Individual tag: {:?}\", line.tag);\n                        }\n                    }\n                }\n                _ =\u003e {\n                    // println!(\"Skipping line: {:?}\", line);\n                }\n            }\n            // Consume the line\n            if parse {\n                Line::parse(record).unwrap();\n            }\n        }\n\n        individual\n    }\n}\n\n#[derive(Debug)]\n/// The type of the name.\n///\n/// Not sure when/where to use this yet but I wanted to capture it from the spec.\npub enum NameType {\n    Alias,\n    Birth,\n    Immigrant,\n    Maiden,\n    Married,\n    Other,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::{AdoptedBy, Quay};\n\n    #[test]\n    fn parse_indi_complete() {\n        let data = vec![\n            \"0 @I1@ INDI\",\n            \"1 NAME Joseph Tag /Torture/\",\n            \"2 TYPE birth\",\n            \"2 NPFX Prof.\",\n            \"2 GIVN Joseph\",\n            \"2 NICK Joe\",\n            \"2 SPFX Le\",\n            \"2 SURN Torture\",\n            \"2 NSFX Jr.\",\n            \"2 NOTE These are notes about the first NAME structure in this record. These notes are \",\n            \"3 CONC embedded in the INDIVIDUAL record itself.\",\n            \"3 CONT \",\n            \"3 CONT This name structure uses all possible tags for a personal name structure.\",\n            \"3 CONT \",\n            \"3 CONT NOTE: many applications are confused by two NAME structures.\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 55\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE @N7@\",\n            \"3 QUAY 0\",\n            \"2 FONE Joseph Tag /Torture/\",\n            \"3 TYPE user defined\",\n            \"3 NPFX Prof.\",\n            \"3 GIVN Joseph\",\n            \"3 NICK Joe\",\n            \"3 SPFX Le\",\n            \"3 SURN Torture\",\n            \"3 NSFX Jr.\",\n            \"3 NOTE Phonetisation\",\n            \"3 SOUR @S1@\",\n            \"4 PAGE 55\",\n            \"4 EVEN BIRT\",\n            \"5 ROLE CHIL\",\n            \"4 DATA\",\n            \"5 DATE 1 JAN 1900\",\n            \"5 TEXT Here is some text from the source specific to this source \",\n            \"6 CONC citation.\",\n            \"6 CONT Here is more text but on a new line.\",\n            \"4 OBJE @M8@\",\n            \"4 NOTE @N7@\",\n            \"4 QUAY 0\",\n            \"2 ROMN Joseph Tag /Torture/\",\n            \"3 TYPE user defined\",\n            \"3 NPFX Prof.\",\n            \"3 GIVN Joseph\",\n            \"3 NICK Joe\",\n            \"3 SPFX Le\",\n            \"3 SURN Torture\",\n            \"3 NSFX Jr.\",\n            \"3 NOTE Romanisation\",\n            \"3 SOUR @S1@\",\n            \"4 PAGE 55\",\n            \"4 EVEN BIRT\",\n            \"5 ROLE CHIL\",\n            \"4 DATA\",\n            \"5 DATE 1 JAN 1900\",\n            \"5 TEXT Here is some text from the source specific to this source \",\n            \"6 CONC citation.\",\n            \"6 CONT Here is more text but on a new line.\",\n            \"4 OBJE @M8@\",\n            \"4 NOTE @N7@\",\n            \"4 QUAY 0\",\n            \"1 NAME William John /Smith/\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"2 NOTE This is a second personal NAME structure in a single INDIVIDUAL record \",\n            \"3 CONC which is allowed in GEDCOM.\",\n            \"3 CONT \",\n            \"3 CONT These notes are embedded in the INDIVIDUAL record.\",\n            \"1 SEX M\",\n            \"1 BIRT\",\n            \"2 TYPE Normal\",\n            \"2 DATE 31 DEC 1965\",\n            \"2 PLAC Salt Lake City, UT, USA\",\n            \"3 FONE Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 ROMN Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 MAP\",\n            \"4 LATI N0\",\n            \"4 LONG E0\",\n            \"3 NOTE Place note\",\n            \"2 ADDR\",\n            \"3 ADR1 St. Marks Hospital\",\n            \"3 CITY Salt Lake City\",\n            \"3 STAE UT\",\n            \"3 POST 84121\",\n            \"3 CTRY USA\",\n            \"2 AGNC none\",\n            \"2 RELI Religion\",\n            \"2 CAUS Conception\",\n            \"2 NOTE @N8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE Some notes about this birth source citation which are embedded in the citation \",\n            \"4 CONC structure itself.\",\n            \"3 QUAY 2\",\n            \"2 OBJE @M15@\",\n            \"2 AGE 0y\",\n            \"2 FAMC @F2@\",\n            \"1 BIRT\",\n            \"2 TYPE Normal\",\n            \"2 DATE ABT. DEC 1965\",\n            \"1 DEAT\",\n            \"2 DATE ABT 15 JAN 2001\",\n            \"2 PLAC New York, New York, USA\",\n            \"3 NOTE The place structure has more detail than usually used for places\",\n            \"2 AGE 76y\",\n            \"2 TYPE slow\",\n            \"2 ADDR\",\n            \"3 ADR1 at Home\",\n            \"2 CAUS Cancer\",\n            \"2 AGNC none\",\n            \"2 OBJE @M8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some death source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A death source note.\",\n            \"2 NOTE A death event note.\",\n            \"1 FAMS @F1@\",\n            \"2 NOTE Note about the link to the family record with his first spouse.\",\n            \"2 NOTE Another note about the link to the family record with his first spouse.\",\n            \"1 FAMS @F4@\",\n            \"1 FAMC @F2@\",\n            \"2 NOTE Note about this link to his parents family record.\",\n            \"2 NOTE Another note about this link to his parents family record\",\n            \"1 FAMC @F3@\",\n            \"2 PEDI adopted\",\n            \"2 NOTE Note about the link to his adoptive parents family record.\",\n            \"1 BAPM\",\n            \"2 DATE ABT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 AGE 3m\",\n            \"2 TYPE BAPM\",\n            \"2 ADDR\",\n            \"3 ADR1 Church Name\",\n            \"3 ADR2 Street Address\",\n            \"3 CITY City Name\",\n            \"3 POST zip\",\n            \"3 CTRY Country\",\n            \"2 CAUS Birth\",\n            \"2 AGNC The Church\",\n            \"2 OBJE @M8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample baptism Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A baptism source note.\",\n            \"2 NOTE A baptism event note (the event of baptism (not LDS), performed in infancy or later. See also BAPL and CHR).\",\n            \"1 CHR\",\n            \"2 DATE CAL 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample CHR Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening Source note.\",\n            \"2 NOTE Christening event note (the religious event (not LDS) of baptizing and/or naming a \",\n            \"3 CONC child).\",\n            \"2 FAMC @F3@\",\n            \"1 CHR\",\n            \"2 DATE EST 30 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some christening source text.\",\n            \"5 CONT This is the second christening structure.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening Source note.\",\n            \"2 NOTE Alternative christening event note. GEDOM allows more than one of the same type \",\n            \"3 CONC of event.\",\n            \"1 BARM\",\n            \"2 DATE AFT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE BARM\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some Bar Mitzvah source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A Bar Mitzvah source note.\",\n            \"2 NOTE Bar Mitzvah event note (the ceremonial event held when a Jewish boy reaches age \",\n            \"3 CONC 13).\",\n            \"1 BASM\",\n            \"2 DATE AFT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE BASM\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some Bas Mitzvah source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A Bas Mitzvah source note.\",\n            \"2 NOTE Bas Mitzvah event note (the ceremonial event held when a Jewish girl reaches age 13, \",\n            \"3 CONC also known as \\\"Bat Mitzvah\\\").\",\n            \"1 ADOP\",\n            \"2 DATE BEF 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE ADOP\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some adoption source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An adoption source note.\",\n            \"2 NOTE Adoption event note (pertaining to creation of a child-parent relationship that does \",\n            \"3 CONC not exist biologically).\",\n            \"2 FAMC @F3@\",\n            \"3 ADOP BOTH\",\n            \"1 CHRA\",\n            \"2 DATE BET 31 DEC 1997 AND 1 FEB 1998\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHRA\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some christening source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening source note.\",\n            \"2 NOTE Adult christening event note (the religious event (not LDS) of baptizing and/or \",\n            \"3 CONC naming an adult person).\",\n            \"1 CONF\",\n            \"2 DATE BET 31 DEC 1997 AND 2 JAN 1998\",\n            \"2 PLAC The place\",\n            \"2 TYPE CONF\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some CONF Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A CONF Source note.\",\n            \"2 NOTE CONFIRMATION event note (the religious event (not LDS) of conferring the gift of the Holy Ghost and, among protestants, full church membership).\",\n            \"1 FCOM\",\n            \"2 DATE INT 31 DEC 1997 (a test)\",\n            \"2 PLAC The place\",\n            \"2 TYPE FCOM\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some first communion source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An first communion source note.\",\n            \"2 NOTE First communion event note (a religious rite, the first act of sharing in the Lord's \",\n            \"3 CONC supper as part of church worship).\",\n            \"1 GRAD\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE GRAD\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some graduation source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A graduation source note.\",\n            \"2 NOTE Graduation event note (an event of awarding educational diplomas or degrees to \",\n            \"3 CONC individuals).\",\n            \"1 EMIG\",\n            \"2 DATE 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE EMIG\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some emigration source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An emigration source note.\",\n            \"2 NOTE Emigration event note (an event of leaving one's homeland with the intent of residing \",\n            \"3 CONC elsewhere).\",\n            \"1 IMMI\",\n            \"2 DATE DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE IMMI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some immigration source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An immigration source note.\",\n            \"2 NOTE Immigration event note (an event of entering into a new locality with the intent of \",\n            \"3 CONC residing there).\",\n            \"1 NATU\",\n            \"2 DATE 1100 BCE\",\n            \"2 PLAC The place\",\n            \"2 TYPE NATU\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some naturalization source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A naturalization source note.\",\n            \"2 NOTE Naturalization event note (the event of obtaining citizenship).\",\n            \"1 CENS\",\n            \"2 DATE @#DHEBREW@ 2 TVT 5758\",\n            \"2 PLAC The place\",\n            \"2 TYPE CENS\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some census source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A census source note.\",\n            \"2 NOTE Census event note (the event of the periodic count of the population for a designated \",\n            \"3 CONC locality, such as a national or state Census).\",\n            \"1 RETI\",\n            \"2 DATE @#DFRENCH R@ 11 NIVO 0006\",\n            \"2 PLAC The place\",\n            \"2 TYPE RETI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some retirement source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A retirement source note.\",\n            \"2 NOTE Retirement event note (an event of exiting an occupational relationship with an \",\n            \"3 CONC employer after a qualifying time period).\",\n            \"1 PROB\",\n            \"2 DATE FROM @#DHEBREW@ 25 SVN 5757 TO @#DHEBREW@ 26 IYR 5757\",\n            \"2 PLAC The place\",\n            \"2 TYPE PROB\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some probate source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A probate source note.\",\n            \"2 NOTE Probate event note (an event of judicial determination of the validity of a will. May \",\n            \"3 CONC indicate several related court activities over several dates).\",\n            \"1 BURI\",\n            \"2 DATE @#DFRENCH R@ 5 VEND 0010\",\n            \"2 PLAC The place\",\n            \"2 TYPE BURI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some burial source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A burial source note.\",\n            \"2 NOTE Burial event note (the event of the proper disposing of the mortal remains of a \",\n            \"3 CONC deceased person).\",\n            \"1 WILL\",\n            \"2 DATE INT @#DHEBREW@ 2 TVT 5758 (interpreted)\",\n            \"2 PLAC The place\",\n            \"2 TYPE WILL\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some will source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A will source note.\",\n            \"2 NOTE Will event note (a legal document treated as an event, by which a person disposes of \",\n            \"3 CONC his or her estate, to take effect after death. The event date is the date the will was \",\n            \"3 CONC signed while the person was alive. See also Probate).\",\n            \"1 CREM\",\n            \"2 DATE AFT 15 JAN 2001\",\n            \"1 EVEN\",\n            \"2 DATE 5 MAY 0005\",\n            \"2 PLAC The place\",\n            \"2 TYPE EVEN\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some generic event source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A generic event source note.\",\n            \"2 NOTE Generic event note (a noteworthy happening related to an individual, a group, or an \",\n            \"3 CONC organization). The TYPE tag specifies the type of event.\",\n            \"1 RESI\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 AGE 35y\",\n            \"2 TYPE RESI\",\n            \"2 ADDR\",\n            \"3 ADR1 Special Address Line 1\",\n            \"3 ADR2 Special Address Line 2\",\n            \"3 ADR3 Special Address Line 3\",\n            \"3 CITY City Name\",\n            \"3 STAE State name\",\n            \"3 POST 0123456789\",\n            \"3 CTRY USA\",\n            \"2 PHON +1-800-555-5555\",\n            \"2 CAUS Needed housing\",\n            \"2 AGNC None\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some residence source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A residence source note.\",\n            \"2 NOTE Residence attribute note (the act of dwelling at an address for a period of time).\",\n            \"1 OCCU Occupation\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 AGE 40y\",\n            \"2 PLAC The place\",\n            \"2 TYPE OCCU\",\n            \"2 ADDR\",\n            \"3 ADR1 Work address line 1\",\n            \"3 ADR2 Work address line 2\",\n            \"3 ADR3 Work address line 3\",\n            \"3 CITY Work city\",\n            \"3 STAE Work state\",\n            \"3 POST Work post\",\n            \"3 CTRY Work country\",\n            \"2 CAUS Need for money\",\n            \"2 AGNC Employer\",\n            \"2 OBJE @M7@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some occupation source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An occupation source note.\",\n            \"2 NOTE Occupation attribute note (the type of work or profession of an individual).\",\n            \"1 OCCU Another occupation\",\n            \"2 DATE 31 DEC 1998\",\n            \"2 PLAC The place\",\n            \"2 TYPE OCCU\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some occupation source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An occupation source note.\",\n            \"2 NOTE Occupation attribute note. This is the second occupation attribute in the record.\",\n            \"1 EDUC Education\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE EDUC\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some education source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An education source note.\",\n            \"2 NOTE Education attribute note (indicator of a level of education attained).\",\n            \"1 DSCR Physical description\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE PHYS\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some physical description source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A physical description source note.\",\n            \"2 NOTE Physical description attribute note (the physical characteristics of a person, place, or \",\n            \"3 CONC thing).\",\n            \"1 RELI Religion\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE RELI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some religion source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A religion source note.\",\n            \"2 NOTE Religion attribute note (a religious denomination to which a person is affiliated or for \",\n            \"3 CONC which a record applies).\",\n            \"1 IDNO 6942\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE IDNO\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some national identification number source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An national identification number source note.\",\n            \"2 NOTE National identification number attribute note (a number assigned to identify a person \",\n            \"3 CONC within some significant external system).\",\n            \"1 PROP Possessions\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE PROP\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some possessions source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE @N11@\",\n            \"2 NOTE Possessions or property attribute note (pertaining to possessions such as real estate \",\n            \"3 CONC or other property of interest).\",\n            \"1 CAST Cast name\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CAST\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some caste name source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A caste name source note.\",\n            \"2 NOTE Caste name attribute note (the name of an individual's rank or status in society, based \",\n            \"3 CONC on racial or religious differences, or differences in wealth, inherited rank, profession, \",\n            \"3 CONC occupation, etc).\",\n            \"1 NCHI 42\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE NCHI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some number of children source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE Am number of children source note.\",\n            \"2 NOTE Number of children attribute note.\",\n            \"1 NMR 42\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE NMR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some number of marriages source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An number of marriages source note.\",\n            \"2 NOTE Number of marriages attribute note.\",\n            \"1 TITL Nobility title\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE TITL\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some title source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A title source note.\",\n            \"2 NOTE Title attribute note (a description of a specific writing or other work, such as the title \",\n            \"3 CONC of a book when used in a source context, or a formal designation used by an \",\n            \"3 CONC individual in connection with positions of royalty or other social status, \",\n            \"3 CONT such as Grand Duke).\",\n            \"1 NATI National or tribe origin\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE NATI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some nationality source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An nationality source note.\",\n            \"2 NOTE Nationality attribute note (the national heritage of an individual).\",\n            \"1 NOTE @N4@\",\n            \"1 NOTE This is a second set of notes for this single individual record. It is embedded in the \",\n            \"2 CONC INDIVIDUAL record instead of being in a separate NOTE record.\",\n            \"2 CONT \",\n            \"2 CONT These notes also have a source citation to a SOURCE record. In GEDCOM \",\n            \"2 CONC this source can only be a single line and links to a SOURCE record.\",\n            \"1 SOUR @S1@\",\n            \"2 PAGE 42\",\n            \"2 DATA\",\n            \"3 DATE 31 DEC 1900\",\n            \"3 TEXT Some sample text from the first source on this record.\",\n            \"2 QUAY 0\",\n            \"2 NOTE A source note.\",\n            \"1 SOUR @S2@\",\n            \"2 NOTE @N12@\",\n            \"1 OBJE @M7@\",\n            \"1 ASSO @I9@\",\n            \"2 RELA Has multimedia links\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample text about this source on an association.\",\n            \"2 NOTE Note on association link.\",\n            \"1 ASSO @I5@\",\n            \"2 RELA Father\",\n            \"1 REFN 01234567890123456789\",\n            \"2 TYPE reference\",\n            \"1 RIN 12\",\n            \"1 CHAN\",\n            \"2 DATE 12 FEB 2001\",\n            \"3 TIME 19:16:42\",\n        ];\n\n        let buffer = data.join(\"\\n\");\n        let mut record = buffer.as_str();\n        let mut indi = Individual::parse(\u0026mut record);\n\n        // println!(\"Names: {}\", indi.names.len());\n\n        assert_eq!(2, indi.names.len());\n        assert_eq!(Some(\"@I1@\".to_string()), indi.xref);\n\n        // Check the name.name\n        assert_eq!(\n            Some(\"Joseph Tag /Torture/\"),\n            indi.names[0].name.value.as_deref()\n        );\n        assert_eq!(Some(\"Joseph\"), indi.names[0].name.given.as_deref());\n        assert_eq!(Some(\"Torture\"), indi.names[0].name.surname.as_deref());\n        assert_eq!(Some(\"Joe\"), indi.names[0].name.nickname.as_deref());\n        assert_eq!(Some(\"Prof.\"), indi.names[0].name.prefix.as_deref());\n        assert_eq!(Some(\"Le\"), indi.names[0].name.suffix.as_deref());\n        assert_eq!(Some(\"Jr.\"), indi.names[0].name.surname_prefix.as_deref());\n        assert_eq!(Some(\"birth\"), indi.names[0].name.r#type.as_deref());\n\n        // Check the indi.names[0].romanized\n        assert_eq!(\n            Some(\"Joseph Tag /Torture/\"),\n            indi.names[0].romanized.value.as_deref()\n        );\n        assert_eq!(Some(\"Joseph\"), indi.names[0].romanized.given.as_deref());\n        assert_eq!(Some(\"Torture\"), indi.names[0].romanized.surname.as_deref());\n        assert_eq!(Some(\"Joe\"), indi.names[0].romanized.nickname.as_deref());\n        assert_eq!(Some(\"Prof.\"), indi.names[0].romanized.prefix.as_deref());\n        assert_eq!(Some(\"Le\"), indi.names[0].romanized.suffix.as_deref());\n        assert_eq!(\n            Some(\"Jr.\"),\n            indi.names[0].romanized.surname_prefix.as_deref()\n        );\n        assert_eq!(\n            Some(\"user defined\"),\n            indi.names[0].romanized.r#type.as_deref()\n        );\n\n        // Check the indi.names[0].phonetic\n        assert_eq!(\n            Some(\"Joseph Tag /Torture/\"),\n            indi.names[0].phonetic.value.as_deref()\n        );\n        assert_eq!(Some(\"Joseph\"), indi.names[0].phonetic.given.as_deref());\n        assert_eq!(Some(\"Torture\"), indi.names[0].phonetic.surname.as_deref());\n        assert_eq!(Some(\"Joe\"), indi.names[0].phonetic.nickname.as_deref());\n        assert_eq!(Some(\"Prof.\"), indi.names[0].phonetic.prefix.as_deref());\n        assert_eq!(Some(\"Le\"), indi.names[0].phonetic.suffix.as_deref());\n        assert_eq!(\n            Some(\"Jr.\"),\n            indi.names[0].phonetic.surname_prefix.as_deref()\n        );\n        assert_eq!(\n            Some(\"user defined\"),\n            indi.names[0].phonetic.r#type.as_deref()\n        );\n\n        // Birth\n        let birth = indi.birth.first().unwrap();\n        assert!(birth.preferred);\n\n        let mut event = birth.event.clone();\n\n        assert!(event.detail.r#type.unwrap() == \"Normal\");\n        assert!(event.detail.date.unwrap() == \"31 DEC 1965\");\n\n        let place = event.detail.place.unwrap();\n        assert!(place.name.unwrap() == \"Salt Lake City, UT, USA\");\n        assert!(place.note.unwrap().note.unwrap() == \"Place note\");\n\n        let place_phonetic = place.phonetic.unwrap();\n        assert!(place_phonetic.name.unwrap() == \"Salt Lake City, UT, USA\");\n        assert!(place_phonetic.r#type.unwrap() == \"user defined\");\n        let place_roman = place.roman.unwrap();\n        assert!(place_roman.name.unwrap() == \"Salt Lake City, UT, USA\");\n        assert!(place_roman.r#type.unwrap() == \"user defined\");\n        let place_map = place.map.unwrap();\n        assert!(place_map.latitude == 0.0);\n        assert!(place_map.longitude == 0.0);\n\n        let addr = event.detail.address.unwrap();\n        assert!(addr.addr1.unwrap() == \"St. Marks Hospital\");\n        assert!(addr.city.unwrap() == \"Salt Lake City\");\n        assert!(addr.state.unwrap() == \"UT\");\n        assert!(addr.postal_code.unwrap() == \"84121\");\n        assert!(addr.country.unwrap() == \"USA\");\n\n        assert!(event.detail.agency.unwrap() == \"none\");\n        assert!(event.detail.religion.unwrap() == \"Religion\");\n        assert!(event.detail.cause.unwrap() == \"Conception\");\n\n        // Good to know: notes can be an xref that refer to a top-level note,\n        // i.e, @N8@ -\u003e '0 NOTE @N8@'.\n        // I need to write some kind of resolver\n        // TODO: Convert to a Note (and add xref to Note)\n        assert!(event.detail.note.unwrap() == \"@N8@\");\n\n        let mut source = event.detail.sources.pop().unwrap();\n        assert!(source.xref.unwrap() == \"@S1@\");\n        assert!(source.page.unwrap() == 42);\n\n        let sdata = source.data.unwrap();\n        assert!(sdata.date.unwrap() == \"1 JAN 1900\");\n        assert!(sdata.text.unwrap().note.unwrap() == \"Here is some text from the source specific to this source citation.\\nHere is more text but on a new line.\");\n\n        let sevent = source.event.unwrap();\n        assert!(sevent.role.unwrap() == \"CHIL\");\n        assert!(sevent.r#type.unwrap() == \"BIRT\");\n\n        assert!(source.media.len() == 1);\n        let media = source.media.pop().unwrap();\n        assert!(media.xref == \"@M8@\");\n\n        assert!(source.note.unwrap().note.unwrap() == \"Some notes about this birth source citation which are embedded in the citation structure itself.\");\n\n        assert!(source.quay.unwrap() == Quay::Secondary);\n\n        let obje = event.detail.media.pop().unwrap();\n        assert!(obje.xref == \"@M15@\");\n\n        assert!(event.age.unwrap() == \"0y\");\n\n        assert!(birth.family.clone().unwrap().xref == \"@F2@\");\n\n        // Death\n        // \"1 DEAT\",\n        let death = indi.death.first().unwrap();\n        assert!(death.preferred);\n\n        let mut devent = death.event.clone().unwrap();\n        // \"2 DATE ABT 15 JAN 2001\",\n        assert!(devent.date.is_some());\n        assert!(devent.date.unwrap() == \"ABT 15 JAN 2001\");\n\n        // \"2 PLAC New York, New York, USA\",\n        // \"3 NOTE The place structure has more detail than usually used for places\",\n        // \"2 AGE 76y\",\n        assert!(death.age.clone().unwrap() == \"76y\");\n        // \"2 TYPE slow\",\n        assert!(devent.r#type.unwrap() == \"slow\");\n\n        // \"2 ADDR\",\n        // \"3 ADR1 at Home\",\n        assert!(devent.address.is_some());\n        let addr = devent.address.unwrap();\n        assert!(addr.addr1.unwrap() == \"at Home\");\n\n        // \"2 CAUS Cancer\",\n        assert!(devent.cause.unwrap() == \"Cancer\");\n\n        // \"2 AGNC none\",\n        assert!(devent.agency.unwrap() == \"none\");\n\n        // \"2 OBJE @M8@\",\n        assert!(devent.media.len() == 1);\n        let obj = devent.media.pop().unwrap();\n        assert!(obj.xref == \"@M8@\".to_string());\n\n        // \"2 SOUR @S1@\",\n        assert!(devent.sources.len() == 1);\n        let source = devent.sources.pop().unwrap();\n        assert!(source.xref.unwrap() == \"@S1@\");\n\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let sdata = source.data.unwrap();\n\n        // \"4 DATE 31 DEC 1900\",\n        assert!(sdata.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Some death source text.\",\n        assert!(sdata.text.unwrap().note.unwrap() == \"Some death source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE A death source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A death source note.\");\n\n        // \"2 NOTE A death event note.\",\n        assert!(devent.note.unwrap() == \"A death event note.\");\n\n        // Family links\n        // FAMS\n        assert!(indi.fams.len() == 2);\n\n        // FAMC\n        assert!(indi.famc.len() == 2);\n\n        // Baptism\n        // \"1 BAPM\",\n        let bapm = indi.baptism.pop().unwrap();\n\n        // \"2 DATE ABT 31 DEC 1997\",\n        assert!(bapm.detail.date.unwrap() == \"ABT 31 DEC 1997\");\n\n        // \"2 PLAC The place\",\n        assert!(bapm.detail.place.unwrap().name.unwrap() == \"The place\");\n\n        // \"2 AGE 3m\",\n        assert!(bapm.age.unwrap() == \"3m\");\n\n        // \"2 TYPE BAPM\",\n        assert!(bapm.detail.r#type.unwrap() == \"BAPM\");\n\n        // \"2 ADDR\",\n        let addr = bapm.detail.address.unwrap();\n\n        // \"3 ADR1 Church Name\",\n        assert!(addr.addr1.unwrap() == \"Church Name\");\n\n        // \"3 ADR2 Street Address\",\n        assert!(addr.addr2.unwrap() == \"Street Address\");\n\n        // \"3 CITY City Name\",\n        assert!(addr.city.unwrap() == \"City Name\");\n\n        // \"3 POST zip\",\n        assert!(addr.postal_code.unwrap() == \"zip\");\n\n        // \"3 CTRY Country\",\n        assert!(addr.country.unwrap() == \"Country\");\n\n        // \"2 CAUS Birth\",\n        assert!(bapm.detail.cause.unwrap() == \"Birth\");\n\n        // \"2 AGNC The Church\",\n        assert!(bapm.detail.agency.unwrap() == \"The Church\");\n\n        // \"2 OBJE @M8@\",\n        let media = bapm.detail.media;\n        assert!(media[0].xref == \"@M8@\".to_string());\n\n        // Sources\n        let mut sources = bapm.detail.sources;\n        let source = sources.pop().unwrap();\n\n        // \"2 SOUR @S1@\",\n        assert!(source.xref.unwrap() == \"@S1@\".to_string());\n\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let sdata = source.data.unwrap();\n\n        // \"4 DATE 31 DEC 1900\",\n        assert!(sdata.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Sample baptism Source text.\",\n        assert!(sdata.text.unwrap().note.unwrap() == \"Sample baptism Source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE A baptism source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A baptism source note.\");\n\n        // \"2 NOTE A baptism event note (the event of baptism (not LDS), performed in infancy or later. See also BAPL and CHR).\",\n        assert!(bapm\n            .detail\n            .note\n            .unwrap()\n            .starts_with(\"A baptism event note\"));\n\n        // Christening\n\n        // \"1 CHR\",\n        let chr = indi.christening.first().unwrap().clone();\n\n        // \"2 DATE CAL 31 DEC 1997\",\n        assert!(chr.event.detail.date.unwrap() == \"CAL 31 DEC 1997\");\n\n        // \"2 PLAC The place\",\n        assert!(chr.event.detail.place.unwrap().name.unwrap() == \"The place\");\n\n        // \"2 TYPE CHR\",\n        assert!(chr.event.detail.r#type.unwrap() == \"CHR\");\n\n        let source = chr.event.detail.sources.first().unwrap().clone();\n\n        // \"2 SOUR @S1@\",\n        assert!(source.xref.unwrap() == \"@S1@\");\n\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let data = source.data.unwrap();\n        // \"4 DATE 31 DEC 1900\",\n        assert!(data.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Sample CHR Source text.\",\n        assert!(data.text.unwrap().note.unwrap() == \"Sample CHR Source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE A christening Source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A christening Source note.\");\n\n        // \"2 NOTE Christening event note (the religious event (not LDS) of baptizing and/or naming a \",\n        // \"3 CONC child).\",\n        assert!(chr.event.detail.note.unwrap() == \"Christening event note (the religious event (not LDS) of baptizing and/or naming a child).\");\n\n        // \"2 FAMC @F3@\",\n        assert!(chr.family.unwrap().xref == \"@F3@\".to_string());\n\n        // \"1 BARM\",\n        let barm = indi.barmitzvah.first().unwrap().clone();\n        // \"2 DATE AFT 31 DEC 1997\",\n        assert!(barm.detail.date.unwrap() == \"AFT 31 DEC 1997\");\n\n        // \"2 PLAC The place\",\n        assert!(barm.detail.place.unwrap().name.unwrap() == \"The place\");\n\n        // \"2 TYPE BARM\",\n        assert!(barm.detail.r#type.unwrap() == \"BARM\");\n\n        let source = barm.detail.sources.first().unwrap().clone();\n        // \"2 SOUR @S1@\",\n        assert!(source.xref.unwrap() == \"@S1@\");\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let sdata = source.data.unwrap();\n\n        // \"4 DATE 31 DEC 1900\",\n        assert!(sdata.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Some Bar Mitzvah source text.\",\n        assert!(sdata.text.unwrap().note.unwrap() == \"Some Bar Mitzvah source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE A Bar Mitzvah source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A Bar Mitzvah source note.\");\n\n        // \"2 NOTE Bar Mitzvah event note (the ceremonial event held when a Jewish boy reaches age \",\n        // \"3 CONC 13).\",\n        assert!(barm.detail.note.unwrap() == \"Bar Mitzvah event note (the ceremonial event held when a Jewish boy reaches age 13).\");\n\n        // Baz Mitzvah\n        // \"1 BASM\",\n        let basm = indi.basmitzvah.first().unwrap().clone();\n\n        // \"2 DATE AFT 31 DEC 1997\",\n        assert!(basm.detail.date.unwrap() == \"AFT 31 DEC 1997\");\n\n        // \"2 PLAC The place\",\n        assert!(basm.detail.place.unwrap().name.unwrap() == \"The place\");\n\n        // \"2 TYPE BARM\",\n        assert!(basm.detail.r#type.unwrap() == \"BASM\");\n\n        let source = basm.detail.sources.first().unwrap().clone();\n        // \"2 SOUR @S1@\",\n        assert!(source.xref.unwrap() == \"@S1@\");\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let sdata = source.data.unwrap();\n\n        // \"4 DATE 31 DEC 1900\",\n        assert!(sdata.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Some Bar Mitzvah source text.\",\n        assert!(sdata.text.unwrap().note.unwrap() == \"Some Bas Mitzvah source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE A Bar Mitzvah source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A Bas Mitzvah source note.\");\n\n        // \"2 NOTE Bas Mitzvah event note (the ceremonial event held when a Jewish girl reaches age 13, \",\n        // \"3 CONC also known as \\\"Bat Mitzvah\\\").\",\n        assert!(basm.detail.note.unwrap() == \"Bas Mitzvah event note (the ceremonial event held when a Jewish girl reaches age 13, also known as \\\"Bat Mitzvah\\\").\");\n\n        // \"1 ADOP\",\n        let mut adoption = indi.adoption.pop().unwrap().clone();\n\n        // \"2 DATE BEF 31 DEC 1997\",\n        assert!(adoption.event.detail.date.unwrap() == \"BEF 31 DEC 1997\");\n\n        // \"2 PLAC The place\",\n        assert!(adoption.event.detail.place.unwrap().name.unwrap() == \"The place\");\n\n        // \"2 TYPE ADOP\",\n        assert!(adoption.event.detail.r#type.unwrap() == \"ADOP\");\n\n        // \"2 SOUR @S1@\",\n        let source = adoption.event.detail.sources.pop().unwrap();\n        assert!(source.xref.unwrap() == \"@S1@\");\n\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let sdata = source.data.unwrap();\n\n        // \"4 DATE 31 DEC 1900\",\n        assert!(sdata.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Some adoption source text.\",\n        assert!(sdata.text.unwrap().note.unwrap() == \"Some adoption source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE An adoption source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"An adoption source note.\");\n\n        // \"2 NOTE Adoption event note (pertaining to creation of a child-parent relationship that does \",\n        // \"3 CONC not exist biologically).\",\n        assert!(adoption.event.detail.note.unwrap() == \"Adoption event note (pertaining to creation of a child-parent relationship that does not exist biologically).\");\n\n        // \"2 FAMC @F3@\",\n        let family = adoption.family.unwrap();\n        assert!(family.xref == \"@F3@\");\n        // \"3 ADOP BOTH\",\n        assert!(family.adopted_by.is_some());\n        assert!(family.adopted_by.unwrap() == AdoptedBy::Both);\n\n        // Adult Christening\n        // \"1 CHRA\",\n        let chr = indi.christening_adult.first().unwrap().clone();\n\n        // \"2 DATE BET 31 DEC 1997 AND 1 FEB 1998\",\n        assert!(chr.event.detail.date.unwrap() == \"BET 31 DEC 1997 AND 1 FEB 1998\");\n\n        // \"2 PLAC The place\",\n        assert!(chr.event.detail.place.unwrap().name.unwrap() == \"The place\");\n        // \"2 TYPE CHRA\",\n        assert!(chr.event.detail.r#type.unwrap() == \"CHRA\");\n\n        let source = chr.event.detail.sources.first().unwrap().clone();\n        // \"2 SOUR @S1@\",\n        assert!(source.xref.unwrap() == \"@S1@\");\n\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let data = source.data.unwrap();\n        // \"4 DATE 31 DEC 1900\",\n        assert!(data.date.unwrap() == \"31 DEC 1900\");\n        // \"4 TEXT Some christening source text.\",\n        assert!(data.text.unwrap().note.unwrap() == \"Some christening source text.\");\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n        // \"3 NOTE A christening source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A christening source note.\");\n\n        // \"2 NOTE Adult christening event note (the religious event (not LDS) of baptizing and/or \",\n        // \"3 CONC naming an adult person).\",\n        assert!(chr.event.detail.note.unwrap() == \"Adult christening event note (the religious event (not LDS) of baptizing and/or naming an adult person).\");\n\n        // CONFIRMATION\n        // \"1 CONF\",\n        assert!(indi.confirmation.len() == 1);\n        let confirmation = indi.confirmation.first().unwrap().clone();\n\n        // \"2 DATE BET 31 DEC 1997 AND 2 JAN 1998\",\n        assert!(confirmation.detail.date.unwrap() == \"BET 31 DEC 1997 AND 2 JAN 1998\");\n\n        // \"2 PLAC The place\",\n        assert!(confirmation.detail.place.unwrap().name.unwrap() == \"The place\");\n\n        // \"2 TYPE CONF\",\n        assert!(confirmation.detail.r#type.unwrap() == \"CONF\");\n\n        let source = confirmation.detail.sources.first().unwrap().clone();\n\n        // \"2 SOUR @S1@\",\n        assert!(source.xref.unwrap() == \"@S1@\");\n\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let sdata = source.data.unwrap();\n\n        // \"4 DATE 31 DEC 1900\",\n        assert!(sdata.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Some CONF Source text.\",\n        assert!(sdata.text.unwrap().note.unwrap() == \"Some CONF Source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE A CONF Source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A CONF Source note.\");\n\n        // \"2 NOTE CONFIRMATION event note (the religious event (not LDS) of conferring the gift of the Holy Ghost and, among protestants, full church membership).\",\n        assert!(confirmation.detail.note.unwrap() == \"CONFIRMATION event note (the religious event (not LDS) of conferring the gift of the Holy Ghost and, among protestants, full church membership).\");\n    }\n}\n","traces":[{"line":88,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":913},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":900},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":900},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":900},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":197},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":177},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":163},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":167},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":152},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":136},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":136},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":130},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":128},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":124},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":126},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":124},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":118},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":88},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":685},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1726},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":826},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":13},"fn_name":null}],"covered":121,"coverable":126},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","mod.rs"],"content":"// Allow inception for now, until this can be refactored. It's because the parent\n// and child modules (individual.Individual) have the same name.\n#![allow(clippy::module_inception)]\n\nmod adoption;\nmod birth;\nmod christening;\nmod death;\nmod event;\nmod gender;\nmod individual;\nmod name;\nmod note;\nmod residence;\nmod source;\n\npub use adoption::Adoption;\npub use birth::Birth;\npub use christening::Christening;\npub use death::Death;\npub use event::IndividualEventDetail;\npub use gender::*;\npub use individual::*;\npub use name::*;\npub use note::*;\npub use residence::Residence;\npub use source::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","name.rs"],"content":"// use crate::parse;\nuse crate::{parse, types::Line, types::Note};\n\nuse winnow::prelude::*;\n\n// PERSONAL_NAME_PIECES:=\n// n NPFX \u003cNAME_PIECE_PREFIX\u003e\n// n GIVN \u003cNAME_PIECE_GIVEN\u003e\n// n NICK \u003cNAME_PIECE_NICKNAME\u003e\n// n SPFX \u003cNAME_PIECE_SURNAME_PREFIX\n// n SURN \u003cNAME_PIECE_SURNAME\u003e\n// n NSFX \u003cNAME_PIECE_SUFFIX\u003e\n// n \u003c\u003cNOTE_STRUCTURE\u003e\u003e\n// n \u003c\u003cSOURCE_CITATION\u003e\u003e\n#[derive(Debug, Default)]\npub struct Name {\n    /// The value of the Name level\n    pub value: Option\u003cString\u003e,\n\n    /// GIVN\n    /// Given name or earned name. Different given names are separated by a comma.\n    pub given: Option\u003cString\u003e,\n\n    /// SURN\n    /// Surname or family name. Different surnames are separated by a comma.\n    pub surname: Option\u003cString\u003e,\n\n    /// NICK\n    /// A descriptive or familiar name used in connection with one's proper name.\n    pub nickname: Option\u003cString\u003e,\n\n    /// NPFX\n    /// Non indexing name piece that appears preceding the given name and surname\n    /// parts. Different name prefix parts are separated by a comma.\n    ///\n    /// Lt. Cmndr. Joseph /Allen/ jr.\n    /// In this example Lt. Cmndr. is considered as the name prefix portion.\n    pub prefix: Option\u003cString\u003e,\n\n    /// SPFX\n    /// Non-indexing name piece that appears after the given name and surname parts.\n    /// Different name suffix parts are separated by a comma.\n    ///\n    /// For example:\n    /// Lt. Cmndr. Joseph /Allen/ jr.\n    /// In this example jr. is considered as the name suffix portion.\n    pub suffix: Option\u003cString\u003e,\n\n    /// NSFX\n    /// Surname prefix or article used in a family name. Different surname articles\n    /// are separated by a comma, for example in the name \"de la Cruz\", this value\n    /// would be \"de, la\".\n    pub surname_prefix: Option\u003cString\u003e,\n\n    pub note: Option\u003ccrate::types::Note\u003e,\n\n    // TODO: do we need a specific struct for type or is it just a string?\n    pub r#type: Option\u003cString\u003e,\n}\nimpl Name {\n    fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cName\u003e {\n        let mut name = Name {\n            value: None,\n            given: None,\n            surname: None,\n            nickname: None,\n            prefix: None,\n            suffix: None,\n            surname_prefix: None,\n            note: None,\n            r#type: None,\n        };\n\n        // We're on level two, so parse until we hit another level two?\n        // let min_level: i32 = 2;\n\n        // let mut buffer: \u0026str = record;\n\n        // let mut _level: u8;\n        // let mut _xref: Option\u003c\u0026str\u003e;\n        // let mut tag: Option\u003c\u0026str\u003e;\n        // let mut value: Option\u003c\u0026str\u003e;\n        let mut line: Line;\n\n        while !record.is_empty() {\n            let mut consume = true;\n            // line = Line::parse(record).unwrap();\n            line = Line::peek(record).unwrap();\n\n            // (buffer, line) = Line::parse(buffer).unwrap();\n            // println!(\"Name::level = {}, tag = {:?}, value={:?}\", line.level, line.tag, line.value);\n\n            match line.tag {\n                \"NAME\" =\u003e {\n                    name.value = Some(line.value.to_string());\n                    // println!(\"name: {:?}\", name.value);\n                }\n                \"TYPE\" =\u003e {\n                    // type\n                    name.r#type = Some(line.value.to_string());\n                }\n                \"GIVN\" =\u003e {\n                    name.given = Some(line.value.to_string());\n                }\n                \"SURN\" =\u003e {\n                    name.surname = Some(line.value.to_string());\n                }\n                \"NICK\" =\u003e {\n                    name.nickname = Some(line.value.to_string());\n                }\n                \"NOTE\" =\u003e {\n                    let note = parse::get_tag_value(record).unwrap();\n                    name.note = Some(Note { note });\n                    consume = false;\n                }\n                \"NPFX\" =\u003e {\n                    name.prefix = Some(line.value.to_string());\n                }\n                \"SPFX\" =\u003e {\n                    name.suffix = Some(line.value.to_string());\n                }\n                \"NSFX\" =\u003e {\n                    name.surname_prefix = Some(line.value.to_string());\n                }\n                _ =\u003e {\n                    // println!(\"Unhandled name tag: {:?}\", tag.unwrap());\n                }\n            }\n\n            if consume {\n                Line::parse(record).unwrap();\n            }\n            // Check if the next line is a new NAME record\n            // TODO: a peek_line method so we can check level and tag in one call\n            // let (_, line) = Line::parse(buffer).unwrap();\n            line = Line::peek(record).unwrap();\n\n            // let level = parse::peek_level(buffer).unwrap_or((\"\", 0_u8)).1;\n            // // let tag = Some(parse::peek_tag(buffer).unwrap().1);\n            // let tag = parse::peek_tag(buffer).unwrap().1;\n\n            if line.level == 1 {\n                break;\n            }\n            // if line.level == 1 \u0026\u0026 line.tag == \"NAME\" {\n            //     break;\n            // }\n\n            if line.level == 2 \u0026\u0026 (line.tag == \"ROMN\" || line.tag == \"FONE\") {\n                break;\n            }\n            if line.tag == \"BIRT\" {\n                println!(\"DEBUG: {:?}\", line);\n            }\n        }\n\n        // println!(\"Name: {:?}\", name);\n        Ok(name)\n    }\n}\n\n// PERSONAL_NAME_STRUCTURE\n// n NAME \u003cNAME_PERSONAL\u003e\n// +1 TYPE \u003cNAME_TYPE\u003e\n// +1 \u003c\u003cPERSONAL_NAME_PIECES\u003e\u003e\n// +1 FONE \u003cNAME_PHONETIC_VARIATION\u003e\n// +2 TYPE \u003cPHONETIC_TYPE\u003e\n// +2 \u003c\u003cPERSONAL_NAME_PIECES\u003e\u003e\n// +1 ROMN \u003cNAME_ROMANIZED_VARIATION\u003e\n// +2 TYPE \u003cROMANIZED_TYPE\u003e\n// +2 \u003c\u003cPERSONAL_NAME_PIECES\u003e\u003e\n#[derive(Debug, Default)]\npub struct PersonalName {\n    /// The surname of an individual, if known, is enclosed between two slash (/)\n    /// characters. The order of the name parts should be the order that the person\n    /// would, by custom of their culture, have used when giving it to a recorder.\n    /// Early versions of Personal Ancestral File ® and other products did not use\n    /// the trailing slash when the surname was the last element of the name. If\n    /// part of name is illegible, that part is indicated by an ellipsis (...).\n    /// Capitalize the name of a person or place in the conventional manner—\n    /// capitalize the first letter of each part and lowercase the other letters,\n    /// unless conventional usage is otherwise. For example: McMurray.\n    ///\n    /// Examples:\n    /// William Lee (given name only or surname not known)\n    /// /Parry/ (surname only)\n    /// William Lee /Parry/\n    /// William Lee /Mac Parry/ (both parts (Mac and Parry) are surname parts William /Lee/ Parry (surname imbedded in the name string)\n    /// William Lee /Pa.../\n    ///\n    /// TODO: Can there be multiple names? The torture file seems to indicate so\n    pub name: Name,\n\n    // pub pieces: PersonalNamePieces,\n    pub r#type: Option\u003cString\u003e,\n\n    // The romanized variation of the name is written in the same form prescribed\n    /// for the name used in the superior \u003cNAME_PERSONAL\u003e context. The method used\n    /// to romanize the name is indicated by the line_value of the subordinate\n    /// \u003cROMANIZED_TYPE\u003e, for example if romaji was used to provide a reading of\n    /// a name written in kanji, then the ROMANIZED_TYPE subordinate to the ROMN\n    /// tag would indicate romaji.\n    pub romanized: Name,\n\n    /// FONE\n    /// The phonetic variation of the name is written in the same form as the was\n    /// the name used in the superior \u003cNAME_PERSONAL\u003e primitive, but phonetically\n    /// written using the method indicated by the subordinate \u003cPHONETIC_TYPE\u003e value,\n    /// for example if hiragana was used to provide a reading of a name written\n    /// in kanji, then the \u003cPHONETIC_TYPE\u003e value would indicate ‘kana’.\n    pub phonetic: Name,\n}\n// impl AsRef\u003cPersonalNamePieces\u003e for PersonalName {\n//     fn as_ref(\u0026self) -\u003e \u0026PersonalNamePieces {\n//         \u0026self.pieces\n//     }\n// }\n\nimpl PersonalName {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cPersonalName\u003e {\n        let mut pn = PersonalName {\n            name: Name {\n                value: None,\n                given: None,\n                surname: None,\n                nickname: None,\n                prefix: None,\n                suffix: None,\n                surname_prefix: None,\n                note: None,\n                r#type: None,\n            },\n            romanized: Name {\n                value: None,\n                given: None,\n                surname: None,\n                nickname: None,\n                prefix: None,\n                suffix: None,\n                surname_prefix: None,\n                note: None,\n                r#type: None,\n            },\n            phonetic: Name {\n                value: None,\n                given: None,\n                surname: None,\n                nickname: None,\n                prefix: None,\n                suffix: None,\n                surname_prefix: None,\n                note: None,\n                r#type: None,\n            },\n            r#type: None,\n        };\n\n        // We're on level one, so parse until we hit another level one?\n        let level = Line::peek(record).unwrap().level;\n\n        // Parse the name out of the record, and switch to a buffer\n        pn.name = Name::parse(record).unwrap();\n\n        // let mut line = Line::parse(\u0026mut buffer).unwrap();\n        let mut line = Line::peek(record).unwrap();\n\n        // let (mut buffer, mut line) = Line::parse(buffer).unwrap();\n\n        // while line.level \u003e 1 \u0026\u0026 !buffer.is_empty() {\n        // println!(\"1 Line: {:?}\", line);\n        while line.level \u003e level \u0026\u0026 !record.is_empty() {\n            if line.level == level + 1 {\n                match line.tag {\n                    \"ROMN\" =\u003e {\n                        pn.romanized = Name::parse(record).unwrap();\n                        if !line.value.is_empty() {\n                            pn.romanized.value = Some(line.value.to_string());\n                        } else {\n                            println!(\n                                \"Romanized value is missing; Level={}, tag={}\",\n                                line.level, line.tag\n                            );\n                        }\n                    }\n                    \"FONE\" =\u003e {\n                        pn.phonetic = Name::parse(record).unwrap();\n                        if !line.value.is_empty() {\n                            pn.phonetic.value = Some(line.value.to_string());\n                        } else {\n                            println!(\n                                \"Phonetic value is missing; Level={}, tag={}\",\n                                line.level, line.tag\n                            );\n                        }\n                    }\n                    _ =\u003e {\n                        println!(\"skipping PersonalName tag {:?}\", line.tag);\n                    }\n                }\n            }\n            if line.level == level {\n                break;\n            } else {\n                // (buffer, line) = Line::parse(buffer).unwrap();\n                // line = Line::parse(record).unwrap();\n                line = Line::peek(record).unwrap();\n            }\n        }\n\n        Ok(pn)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    fn parse_indi() {\n        let data = vec![\n            // \"0 @I1@ INDI\",\n            \"1 NAME Joseph Tag /Torture/\",\n            \"2 TYPE birth\",\n            \"2 NPFX Prof.\",\n            \"2 GIVN Joseph\",\n            \"2 NICK Joe\",\n            \"2 SPFX Le\",\n            \"2 SURN Torture\",\n            \"2 NSFX Jr.\",\n            \"2 NOTE These are notes about the first NAME structure in this record. These notes are \",\n            \"3 CONC embedded in the INDIVIDUAL record itself.\",\n            \"3 CONT \",\n            \"3 CONT This name structure uses all possible tags for a personal name structure.\",\n            \"3 CONT \",\n            \"3 CONT NOTE: many applications are confused by two NAME structures.\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 55\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE @N7@\",\n            \"3 QUAY 0\",\n            \"2 FONE Joseph Tag /Torture/\",\n            \"3 TYPE user defined\",\n            \"3 NPFX Prof.\",\n            \"3 GIVN Joseph\",\n            \"3 NICK Joe\",\n            \"3 SPFX Le\",\n            \"3 SURN Torture\",\n            \"3 NSFX Jr.\",\n            \"3 NOTE Phonetisation\",\n            \"3 SOUR @S1@\",\n            \"4 PAGE 55\",\n            \"4 EVEN BIRT\",\n            \"5 ROLE CHIL\",\n            \"4 DATA\",\n            \"5 DATE 1 JAN 1900\",\n            \"5 TEXT Here is some text from the source specific to this source \",\n            \"6 CONC citation.\",\n            \"6 CONT Here is more text but on a new line.\",\n            \"4 OBJE @M8@\",\n            \"4 NOTE @N7@\",\n            \"4 QUAY 0\",\n            \"2 ROMN Joseph Tag /Torture/\",\n            \"3 TYPE user defined\",\n            \"3 NPFX Prof.\",\n            \"3 GIVN Joseph\",\n            \"3 NICK Joe\",\n            \"3 SPFX Le\",\n            \"3 SURN Torture\",\n            \"3 NSFX Jr.\",\n            \"3 NOTE Romanisation\",\n            \"3 SOUR @S1@\",\n            \"4 PAGE 55\",\n            \"4 EVEN BIRT\",\n            \"5 ROLE CHIL\",\n            \"4 DATA\",\n            \"5 DATE 1 JAN 1900\",\n            \"5 TEXT Here is some text from the source specific to this source \",\n            \"6 CONC citation.\",\n            \"6 CONT Here is more text but on a new line.\",\n            \"4 OBJE @M8@\",\n            \"4 NOTE @N7@\",\n            \"4 QUAY 0\",\n            \"1 NAME William John /Smith/\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"2 NOTE This is a second personal NAME structure in a single INDIVIDUAL record \",\n            \"3 CONC which is allowed in GEDCOM.\",\n            \"3 CONT \",\n            \"3 CONT These notes are embedded in the INDIVIDUAL record.\",\n            \"1 SEX M\",\n            \"1 BIRT\",\n            \"2 TYPE Normal\",\n            \"2 DATE 31 DEC 1965\",\n            \"2 PLAC Salt Lake City, UT, USA\",\n            \"3 FONE Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 ROMN Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 MAP\",\n            \"4 LATI N0\",\n            \"4 LONG E0\",\n            \"3 NOTE Place note\",\n            \"2 ADDR\",\n            \"3 ADR1 St. Marks Hospital\",\n            \"3 CITY Salt Lake City\",\n            \"3 STAE UT\",\n            \"3 POST 84121\",\n            \"3 CTRY USA\",\n            \"2 AGNC none\",\n            \"2 RELI Religion\",\n            \"2 CAUS Conception\",\n            \"2 NOTE @N8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE Some notes about this birth source citation which are embedded in the citation \",\n            \"4 CONC structure itself.\",\n            \"3 QUAY 2\",\n            \"2 OBJE @M15@\",\n            \"2 AGE 0y\",\n            \"2 FAMC @F2@\",\n            \"1 DEAT\",\n            \"2 DATE ABT 15 JAN 2001\",\n            \"2 PLAC New York, New York, USA\",\n            \"3 NOTE The place structure has more detail than usually used for places\",\n            \"2 AGE 76y\",\n            \"2 TYPE slow\",\n            \"2 ADDR\",\n            \"3 ADR1 at Home\",\n            \"2 CAUS Cancer\",\n            \"2 AGNC none\",\n            \"2 OBJE @M8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some death source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A death source note.\",\n            \"2 NOTE A death event note.\",\n            \"1 FAMS @F1@\",\n            \"2 NOTE Note about the link to the family record with his first spouse.\",\n            \"2 NOTE Another note about the link to the family record with his first spouse.\",\n            \"1 FAMS @F4@\",\n            \"1 FAMC @F2@\",\n            \"2 NOTE Note about this link to his parents family record.\",\n            \"2 NOTE Another note about this link to his parents family record\",\n            \"1 FAMC @F3@\",\n            \"2 PEDI adopted\",\n            \"2 NOTE Note about the link to his adoptive parents family record.\",\n            \"1 BAPM\",\n            \"2 DATE ABT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 AGE 3m\",\n            \"2 TYPE BAPM\",\n            \"2 ADDR\",\n            \"3 ADR1 Church Name\",\n            \"3 ADR2 Street Address\",\n            \"3 CITY City Name\",\n            \"3 POST zip\",\n            \"3 CTRY Country\",\n            \"2 CAUS Birth\",\n            \"2 AGNC The Church\",\n            \"2 OBJE @M8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample baptism Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A baptism source note.\",\n            \"2 NOTE A baptism event note (the event of baptism (not LDS), performed in infancy or later. See also BAPL and CHR).\",\n            \"1 CHR\",\n            \"2 DATE CAL 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample CHR Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening Source note.\",\n            \"2 NOTE Christening event note (the religious event (not LDS) of baptizing and/or naming a \",\n            \"3 CONC child).\",\n            \"2 FAMC @F3@\",\n            \"1 CHR\",\n            \"2 DATE EST 30 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some christening source text.\",\n            \"5 CONT This is the second christening structure.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening Source note.\",\n            \"2 NOTE Alternative christening event note. GEDOM allows more than one of the same type \",\n            \"3 CONC of event.\",\n            \"1 BARM\",\n            \"2 DATE AFT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE BARM\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some Bar Mitzvah source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A Bar Mitzvah source note.\",\n            \"2 NOTE Bar Mitzvah event note (the ceremonial event held when a Jewish boy reaches age \",\n            \"3 CONC 13).\",\n            \"1 BASM\",\n            \"2 DATE AFT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE BASM\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some Bas Mitzvah source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A Bas Mitzvah source note.\",\n            \"2 NOTE Bas Mitzvah event note (the ceremonial event held when a Jewish girl reaches age 13, \",\n            \"3 CONC also known as \\\"Bat Mitzvah\\\").\",\n            \"1 ADOP\",\n            \"2 DATE BEF 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE ADOP\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some adoption source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An adoption source note.\",\n            \"2 NOTE Adoption event note (pertaining to creation of a child-parent relationship that does \",\n            \"3 CONC not exist biologically).\",\n            \"2 FAMC @F3@\",\n            \"3 ADOP BOTH\",\n            \"1 CHRA\",\n            \"2 DATE BET 31 DEC 1997 AND 1 FEB 1998\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHRA\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some christening source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening source note.\",\n            \"2 NOTE Adult christening event note (the religious event (not LDS) of baptizing and/or \",\n            \"3 CONC naming an adult person).\",\n            \"1 CONF\",\n            \"2 DATE BET 31 DEC 1997 AND 2 JAN 1998\",\n            \"2 PLAC The place\",\n            \"2 TYPE CONF\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some CONF Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A CONF Source note.\",\n            \"2 NOTE CONFIRMATION event note (the religious event (not LDS) of conferring the gift of the Holy Ghost and, among protestants, full church membership).\",\n            \"1 FCOM\",\n            \"2 DATE INT 31 DEC 1997 (a test)\",\n            \"2 PLAC The place\",\n            \"2 TYPE FCOM\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some first communion source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An first communion source note.\",\n            \"2 NOTE First communion event note (a religious rite, the first act of sharing in the Lord's \",\n            \"3 CONC supper as part of church worship).\",\n            \"1 GRAD\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE GRAD\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some graduation source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A graduation source note.\",\n            \"2 NOTE Graduation event note (an event of awarding educational diplomas or degrees to \",\n            \"3 CONC individuals).\",\n            \"1 EMIG\",\n            \"2 DATE 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE EMIG\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some emigration source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An emigration source note.\",\n            \"2 NOTE Emigration event note (an event of leaving one's homeland with the intent of residing \",\n            \"3 CONC elsewhere).\",\n            \"1 IMMI\",\n            \"2 DATE DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE IMMI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some immigration source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An immigration source note.\",\n            \"2 NOTE Immigration event note (an event of entering into a new locality with the intent of \",\n            \"3 CONC residing there).\",\n            \"1 NATU\",\n            \"2 DATE 1100 BCE\",\n            \"2 PLAC The place\",\n            \"2 TYPE NATU\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some naturalization source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A naturalization source note.\",\n            \"2 NOTE Naturalization event note (the event of obtaining citizenship).\",\n            \"1 CENS\",\n            \"2 DATE @#DHEBREW@ 2 TVT 5758\",\n            \"2 PLAC The place\",\n            \"2 TYPE CENS\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some census source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A census source note.\",\n            \"2 NOTE Census event note (the event of the periodic count of the population for a designated \",\n            \"3 CONC locality, such as a national or state Census).\",\n            \"1 RETI\",\n            \"2 DATE @#DFRENCH R@ 11 NIVO 0006\",\n            \"2 PLAC The place\",\n            \"2 TYPE RETI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some retirement source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A retirement source note.\",\n            \"2 NOTE Retirement event note (an event of exiting an occupational relationship with an \",\n            \"3 CONC employer after a qualifying time period).\",\n            \"1 PROB\",\n            \"2 DATE FROM @#DHEBREW@ 25 SVN 5757 TO @#DHEBREW@ 26 IYR 5757\",\n            \"2 PLAC The place\",\n            \"2 TYPE PROB\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some probate source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A probate source note.\",\n            \"2 NOTE Probate event note (an event of judicial determination of the validity of a will. May \",\n            \"3 CONC indicate several related court activities over several dates).\",\n            \"1 BURI\",\n            \"2 DATE @#DFRENCH R@ 5 VEND 0010\",\n            \"2 PLAC The place\",\n            \"2 TYPE BURI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some burial source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A burial source note.\",\n            \"2 NOTE Burial event note (the event of the proper disposing of the mortal remains of a \",\n            \"3 CONC deceased person).\",\n            \"1 WILL\",\n            \"2 DATE INT @#DHEBREW@ 2 TVT 5758 (interpreted)\",\n            \"2 PLAC The place\",\n            \"2 TYPE WILL\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some will source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A will source note.\",\n            \"2 NOTE Will event note (a legal document treated as an event, by which a person disposes of \",\n            \"3 CONC his or her estate, to take effect after death. The event date is the date the will was \",\n            \"3 CONC signed while the person was alive. See also Probate).\",\n            \"1 CREM\",\n            \"2 DATE AFT 15 JAN 2001\",\n            \"1 EVEN\",\n            \"2 DATE 5 MAY 0005\",\n            \"2 PLAC The place\",\n            \"2 TYPE EVEN\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some generic event source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A generic event source note.\",\n            \"2 NOTE Generic event note (a noteworthy happening related to an individual, a group, or an \",\n            \"3 CONC organization). The TYPE tag specifies the type of event.\",\n            \"1 RESI\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 AGE 35y\",\n            \"2 TYPE RESI\",\n            \"2 ADDR\",\n            \"3 ADR1 Special Address Line 1\",\n            \"3 ADR2 Special Address Line 2\",\n            \"3 ADR3 Special Address Line 3\",\n            \"3 CITY City Name\",\n            \"3 STAE State name\",\n            \"3 POST 0123456789\",\n            \"3 CTRY USA\",\n            \"2 PHON +1-800-555-5555\",\n            \"2 CAUS Needed housing\",\n            \"2 AGNC None\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some residence source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A residence source note.\",\n            \"2 NOTE Residence attribute note (the act of dwelling at an address for a period of time).\",\n            \"1 OCCU Occupation\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 AGE 40y\",\n            \"2 PLAC The place\",\n            \"2 TYPE OCCU\",\n            \"2 ADDR\",\n            \"3 ADR1 Work address line 1\",\n            \"3 ADR2 Work address line 2\",\n            \"3 ADR3 Work address line 3\",\n            \"3 CITY Work city\",\n            \"3 STAE Work state\",\n            \"3 POST Work post\",\n            \"3 CTRY Work country\",\n            \"2 CAUS Need for money\",\n            \"2 AGNC Employer\",\n            \"2 OBJE @M7@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some occupation source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An occupation source note.\",\n            \"2 NOTE Occupation attribute note (the type of work or profession of an individual).\",\n            \"1 OCCU Another occupation\",\n            \"2 DATE 31 DEC 1998\",\n            \"2 PLAC The place\",\n            \"2 TYPE OCCU\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some occupation source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An occupation source note.\",\n            \"2 NOTE Occupation attribute note. This is the second occupation attribute in the record.\",\n            \"1 EDUC Education\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE EDUC\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some education source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An education source note.\",\n            \"2 NOTE Education attribute note (indicator of a level of education attained).\",\n            \"1 DSCR Physical description\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE PHYS\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some physical description source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A physical description source note.\",\n            \"2 NOTE Physical description attribute note (the physical characteristics of a person, place, or \",\n            \"3 CONC thing).\",\n            \"1 RELI Religion\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE RELI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some religion source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A religion source note.\",\n            \"2 NOTE Religion attribute note (a religious denomination to which a person is affiliated or for \",\n            \"3 CONC which a record applies).\",\n            \"1 IDNO 6942\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE IDNO\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some national identification number source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An national identification number source note.\",\n            \"2 NOTE National identification number attribute note (a number assigned to identify a person \",\n            \"3 CONC within some significant external system).\",\n            \"1 PROP Possessions\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE PROP\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some possessions source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE @N11@\",\n            \"2 NOTE Possessions or property attribute note (pertaining to possessions such as real estate \",\n            \"3 CONC or other property of interest).\",\n            \"1 CAST Cast name\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CAST\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some caste name source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A caste name source note.\",\n            \"2 NOTE Caste name attribute note (the name of an individual's rank or status in society, based \",\n            \"3 CONC on racial or religious differences, or differences in wealth, inherited rank, profession, \",\n            \"3 CONC occupation, etc).\",\n            \"1 NCHI 42\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE NCHI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some number of children source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE Am number of children source note.\",\n            \"2 NOTE Number of children attribute note.\",\n            \"1 NMR 42\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE NMR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some number of marriages source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An number of marriages source note.\",\n            \"2 NOTE Number of marriages attribute note.\",\n            \"1 TITL Nobility title\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE TITL\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some title source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A title source note.\",\n            \"2 NOTE Title attribute note (a description of a specific writing or other work, such as the title \",\n            \"3 CONC of a book when used in a source context, or a formal designation used by an \",\n            \"3 CONC individual in connection with positions of royalty or other social status, \",\n            \"3 CONT such as Grand Duke).\",\n            \"1 NATI National or tribe origin\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE NATI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some nationality source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An nationality source note.\",\n            \"2 NOTE Nationality attribute note (the national heritage of an individual).\",\n            \"1 NOTE @N4@\",\n            \"1 NOTE This is a second set of notes for this single individual record. It is embedded in the \",\n            \"2 CONC INDIVIDUAL record instead of being in a separate NOTE record.\",\n            \"2 CONT \",\n            \"2 CONT These notes also have a source citation to a SOURCE record. In GEDCOM \",\n            \"2 CONC this source can only be a single line and links to a SOURCE record.\",\n            \"1 SOUR @S1@\",\n            \"2 PAGE 42\",\n            \"2 DATA\",\n            \"3 DATE 31 DEC 1900\",\n            \"3 TEXT Some sample text from the first source on this record.\",\n            \"2 QUAY 0\",\n            \"2 NOTE A source note.\",\n            \"1 SOUR @S2@\",\n            \"2 NOTE @N12@\",\n            \"1 OBJE @M7@\",\n            \"1 ASSO @I9@\",\n            \"2 RELA Has multimedia links\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample text about this source on an association.\",\n            \"2 NOTE Note on association link.\",\n            \"1 ASSO @I5@\",\n            \"2 RELA Father\",\n            \"1 REFN 01234567890123456789\",\n            \"2 TYPE reference\",\n            \"1 RIN 12\",\n            \"1 CHAN\",\n            \"2 DATE 12 FEB 2001\",\n            \"3 TIME 19:16:42\",\n        ];\n\n        let buffer = data.join(\"\\n\");\n        let mut record = buffer.as_str();\n        // println!(\"A Record: {}\", record.len());\n        let name = PersonalName::parse(\u0026mut record).unwrap();\n        // println!(\"B Record: {}\", record.len());\n        // println!(\"{name:#?}\");\n\n        // Check the name.name\n        assert_eq!(Some(\"Joseph Tag /Torture/\"), name.name.value.as_deref());\n        assert_eq!(Some(\"Joseph\"), name.name.given.as_deref());\n        assert_eq!(Some(\"Torture\"), name.name.surname.as_deref());\n        assert_eq!(Some(\"Joe\"), name.name.nickname.as_deref());\n        assert_eq!(Some(\"Prof.\"), name.name.prefix.as_deref());\n        assert_eq!(Some(\"Le\"), name.name.suffix.as_deref());\n        assert_eq!(Some(\"Jr.\"), name.name.surname_prefix.as_deref());\n        assert_eq!(Some(\"birth\"), name.name.r#type.as_deref());\n\n        // Check the name.romanized\n        assert_eq!(\n            Some(\"Joseph Tag /Torture/\"),\n            name.romanized.value.as_deref()\n        );\n        assert_eq!(Some(\"Joseph\"), name.romanized.given.as_deref());\n        assert_eq!(Some(\"Torture\"), name.romanized.surname.as_deref());\n        assert_eq!(Some(\"Joe\"), name.romanized.nickname.as_deref());\n        assert_eq!(Some(\"Prof.\"), name.romanized.prefix.as_deref());\n        assert_eq!(Some(\"Le\"), name.romanized.suffix.as_deref());\n        assert_eq!(Some(\"Jr.\"), name.romanized.surname_prefix.as_deref());\n        assert_eq!(Some(\"user defined\"), name.romanized.r#type.as_deref());\n\n        // Check the name.phonetic\n        assert_eq!(Some(\"Joseph Tag /Torture/\"), name.phonetic.value.as_deref());\n        assert_eq!(Some(\"Joseph\"), name.phonetic.given.as_deref());\n        assert_eq!(Some(\"Torture\"), name.phonetic.surname.as_deref());\n        assert_eq!(Some(\"Joe\"), name.phonetic.nickname.as_deref());\n        assert_eq!(Some(\"Prof.\"), name.phonetic.prefix.as_deref());\n        assert_eq!(Some(\"Le\"), name.phonetic.suffix.as_deref());\n        assert_eq!(Some(\"Jr.\"), name.phonetic.surname_prefix.as_deref());\n        assert_eq!(Some(\"user defined\"), name.phonetic.r#type.as_deref());\n    }\n}\n","traces":[{"line":61,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":208},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":208},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":208},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":208},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":201},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":192},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":183},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":176},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":145},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":136},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":109},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":396},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":188},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":208},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":208},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":263},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":186},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":16},"fn_name":null}],"covered":56,"coverable":66},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","note.rs"],"content":"#[derive(Debug, Default)]\npub struct NoteStructure {\n    pub note: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","residence.rs"],"content":"#[derive(Debug, Default)]\npub struct Residence {\n    pub place: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","source.rs"],"content":"// #[derive(Debug, Default)]\n// pub struct SourceCitation {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","types","line.rs"],"content":"// use std::str::FromStr;\nuse std::fmt;\n\nuse winnow::ascii::{alphanumeric1, digit1, line_ending, not_line_ending, space0};\nuse winnow::combinator::{opt, preceded, separated_pair};\nuse winnow::error::StrContext;\nuse winnow::prelude::*;\nuse winnow::stream::Stream;\nuse winnow::token::{tag, take_till};\n\n/// A GEDCOM line\n/// level + delim (space) + [optional_xref_ID] + tag + [optional_line_value] + terminator\n#[derive(Debug, Eq, PartialEq, Clone, Copy)]\npub struct Line\u003c'a\u003e {\n    pub level: u8,\n    pub xref: \u0026'a str,\n    pub tag: \u0026'a str,\n    pub value: \u0026'a str,\n}\n\nimpl\u003c'b\u003e fmt::Display for Line\u003c'b\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        if !self.xref.is_empty() {\n            write!(\n                f,\n                \"{} {} {} {}\",\n                self.level, self.xref, self.tag, self.value\n            )\n        } else {\n            write!(f, \"{} {} {}\", self.level, self.tag, self.value)\n        }\n    }\n}\nimpl\u003c'b\u003e Line\u003c'b\u003e {\n    pub fn parse(input: \u0026mut \u0026'b str) -\u003e PResult\u003cLine\u003c'b\u003e\u003e {\n        let mut line = Line {\n            level: 0,\n            xref: \"\",\n            tag: \"\",\n            value: \"\",\n        };\n        // println!(\"Parsing line...\");\n        // println!(\"Starting input: '{}'\", input);\n        if !input.is_empty() {\n            // We could rewrite this into a sequence of parsers, something like this:\n            // let (level, _, xref, _, tag, delim, value) = (\n            //     Self::level,\n            //     Self::delim,\n            //     Self::xref,\n            //     Self::delim,\n            //     Self::tag,\n            //     Self::delim,\n            //     Self::value,\n            // )\n            //     .parse_next(input).unwrap();\n\n            let level = Self::level(input);\n            match level {\n                Ok(lvl) =\u003e {\n                    line.level = lvl;\n                    let _ = Self::delim(input);\n                    match Self::xref(input) {\n                        Ok(xref) =\u003e {\n                            line.xref = xref;\n                        }\n                        Err(_e) =\u003e {\n                            todo!();\n                        }\n                    }\n                    if !line.xref.is_empty() {\n                        let _ = Self::delim(input);\n                    }\n                    line.tag = Self::tag(input)?;\n                    let _ = Self::delim(input);\n\n                    let is_eol = Self::peek_eol(input)?;\n                    if is_eol {\n                        Self::eol(input).unwrap();\n                    } else {\n                        Self::delim(input).unwrap();\n                        line.value = Self::value(input)?;\n\n                        let is_eol = Self::peek_eol(input)?;\n                        if is_eol {\n                            Self::eol(input).unwrap();\n                        }\n                    }\n                }\n                Err(e) =\u003e {\n                    println!(\"Err: {}\", e);\n                    println!(\"Error parsing line: '{}'\", input);\n                    Self::eol(input).unwrap();\n                    /*\n                    There's a case where a line is simply the extension of the\n                    previous line because of an embedded newline. This is common\n                    in Ancestry source data, IME. Technically, it's incorrect\n                    according to spec; the data should use a CONC/CONT to indicate\n                    a break on a new line.\n\n                    What we can attempt to do is parse the line as the value, as\n                    if it were a CONCatonation. We don't have a line level, nor\n                    do we know what the previous line is, so we'll set it to\n                    u8::MAX, I guess, and add a special use-case for that.\n                     */\n\n                    // line.level = u8::MAX;\n                    // line.tag = \"CONC\";\n                    // line.value = Self::value(input)?;\n                    // println!(\"New value: '{:?}'\", line);\n\n                    // there's a case where the value of a line contains a newline,\n                    // breaking it into its own line. I think it's techically\n                    // invalid, according to spec; it should use CONC/CONT.\n                    // It's common in Ancestry source data so may as well work\n                    // to handle it.\n                }\n            }\n        } else {\n            // There's a few instances where we're passed an empty input.\n            // This might be a parsing error, but might not be. More testing!\n            // println!(\"Empty input\");\n        }\n        Ok(line)\n    }\n\n    /// Peek ahead at the next line without consuming it.\n    pub fn peek(input: \u0026mut \u0026'b str) -\u003e PResult\u003cLine\u003c'b\u003e\u003e {\n        let start = input.checkpoint();\n        let line = Line::parse(input).unwrap();\n\n        input.reset(start);\n        Ok(line)\n    }\n\n    /// Parse a number from the string, but return it as an actual Rust number, not a string.\n    fn level(input: \u0026mut \u0026str) -\u003e PResult\u003cu8\u003e {\n        // parse_to works because it uses FromStr, which is effectively\n        // a convienence function around try_map\n        // digit1.try_map(str::parse).parse_next(input)\n        digit1\n            .context(StrContext::Label(\"level\"))\n            .parse_to()\n            .parse_next(input)\n    }\n\n    /// Parse a number from the string, but return it as an actual Rust number, not a string.\n    // fn peek_level\u003c's\u003e(input: \u0026mut \u0026's str) -\u003e PResult\u003cu8\u003e {\n    //     let start = input.checkpoint();\n\n    //     let level = Self::level(input).unwrap();\n    //     input.reset(start);\n    //     Ok(level)\n    // }\n\n    /// Parse the delimiter\n    fn delim(input: \u0026mut \u0026'b str) -\u003e PResult\u003c\u0026'b str\u003e {\n        space0.context(StrContext::Label(\"delim\")).parse_next(input)\n    }\n\n    fn eol(input: \u0026mut \u0026'b str) -\u003e PResult\u003c\u0026'b str\u003e {\n        // multispace0.context(StrContext::Label(\"eol2\")).parse_next(input)\n        line_ending\n            .context(StrContext::Label(\"eol\"))\n            .parse_next(input)\n\n        // println!(\"EOL start input: '{}'\", input);\n        // let res = line_ending.context(StrContext::Label(\"eol\")).parse_next(input);\n        // println!(\"EOL end input: '{}'\", input);\n\n        // res\n    }\n\n    /// Peek at the next character to see if it's a newline\n    fn peek_eol(input: \u0026mut \u0026'b str) -\u003e PResult\u003cbool\u003e {\n        if input.starts_with('\\n') || input.starts_with(\"\\r\\n\") {\n            return Ok(true);\n        }\n\n        // let start = input.checkpoint();\n        // let res = Self::eol(input);\n        // input.reset(start);\n\n        // if !res.is_err() {\n        //     let is_eol = res.unwrap();\n        //     return Ok(!is_eol.is_empty());\n        // }\n        Ok(false)\n        // let is_eol = Self::eol(input).unwrap();\n\n        // input.reset(start);\n        // Ok(!is_eol.is_empty())\n    }\n\n    fn tag(input: \u0026mut \u0026'b str) -\u003e PResult\u003c\u0026'b str\u003e {\n        // one of: a-zA-Z_\n        let parser = preceded(opt(tag(\"_\")), alphanumeric1)\n            .recognize()\n            .verify(|o: \u0026str| o.len() \u003c= 31);\n\n        parser.context(StrContext::Label(\"tag\")).parse_next(input)\n    }\n\n    fn value(input: \u0026mut \u0026'b str) -\u003e PResult\u003c\u0026'b str\u003e {\n        not_line_ending\n            .context(StrContext::Label(\"value\"))\n            .parse_next(input)\n    }\n\n    /// Parse the xref, if present\n    ///\n    /// TODO: Return the leading/trailing @ portion of the xref\n    fn xref(input: \u0026mut \u0026'b str) -\u003e PResult\u003c\u0026'b str\u003e {\n        if input.starts_with('@') {\n            let mut parser =\n                separated_pair(tag(\"@\"), take_till(0.., |c| c == '@'), tag(\"@\")).recognize();\n            return parser.parse_next(input);\n\n            // println!(\"Parsing xref: '{}'\", input);\n            // let mut parser = delimited(tag(\"@\"), take_till(0.., |c| c == '@'), tag(\"@\"));\n            // let res = parser.context(StrContext::Label(\"xref\")).parse_next(input);\n\n            // if !res.is_err() {\n            //     let mut xref = res.unwrap();\n            //     xref += \"@\";\n            //     return Ok(\"@1@\");\n            // }\n            // take_till(1.., |c| c == '@').parse_next(input)\n            // let mut parser = delimited(\n            //     tag(\"@\"),\n            //     is_not(\"@\"),\n            //     tag(\"@\"),\n            // );\n\n            // parser(input)\n        }\n        Ok(\"\")\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_lines() {\n        let mut data = vec![\n            \"0 HEAD\",\n            \"1 CHAR UTF-8\",\n            \"1 SOUR Ancestry.com Family Trees\",\n            \"2 DATA Name of source data\",\n            \"3 DATE 1 JAN 1998\",\n            \"3 COPR Copyright of source data\",\n            \"1 SUBM @U1@\",\n            \"0 @U1@ SUBM\",\n        ];\n\n        let line = Line::parse(\u0026mut data[0]).unwrap();\n        assert!(line.level == 0 \u0026\u0026 line.tag == \"HEAD\");\n\n        let line = Line::parse(\u0026mut data[1]).unwrap();\n        assert!(line.level == 1 \u0026\u0026 line.tag == \"CHAR\" \u0026\u0026 line.value == \"UTF-8\");\n\n        let line = Line::parse(\u0026mut data[2]).unwrap();\n        assert!(line.level == 1 \u0026\u0026 line.tag == \"SOUR\" \u0026\u0026 line.value == \"Ancestry.com Family Trees\");\n\n        let line = Line::parse(\u0026mut data[3]).unwrap();\n        assert!(line.level == 2 \u0026\u0026 line.tag == \"DATA\" \u0026\u0026 line.value == \"Name of source data\");\n\n        let line = Line::parse(\u0026mut data[4]).unwrap();\n        assert!(line.level == 3 \u0026\u0026 line.tag == \"DATE\" \u0026\u0026 line.value == \"1 JAN 1998\");\n\n        let line = Line::parse(\u0026mut data[5]).unwrap();\n        assert!(line.level == 3 \u0026\u0026 line.tag == \"COPR\" \u0026\u0026 line.value == \"Copyright of source data\");\n\n        let line = Line::parse(\u0026mut data[6]).unwrap();\n        assert!(line.level == 1 \u0026\u0026 line.tag == \"SUBM\" \u0026\u0026 line.value == \"@U1@\");\n\n        let line = Line::parse(\u0026mut data[7]).unwrap();\n        // TODO: Update this to include the wrapping @ when I figure out how to make nom do that.\n        assert!(line.level == 0 \u0026\u0026 line.tag == \"SUBM\" \u0026\u0026 line.value == \"\" \u0026\u0026 line.xref == \"@U1@\");\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":818},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":818},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":818},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6807},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6807},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":905},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":905},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":5862},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":5862},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":11724},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":5639},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":5639},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":6807},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":3948},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3948},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":3948},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":3948},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":3948},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":19491},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":19491},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":12629},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":18714},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":6085},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":20301},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":5862},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":5862},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":5862},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":5862},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":512},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":6672},"fn_name":null}],"covered":59,"coverable":78},{"path":["/","Users","adam","src","rust-gedcom","src","types","map.rs"],"content":"use crate::types::Line;\n\nuse std::str::FromStr;\n\nuse winnow::prelude::*;\n\n// The GEDCOM specification of this type\n//\n// +1 MAP {0:1}\n// +2 LATI \u003cPLACE_LATITUDE\u003e {1:1} p.58\n// +2 LONG \u003cPLACE_LONGITUDE\u003e\n\n#[derive(Clone, Debug, Default)]\npub struct Map {\n    pub latitude: f64,\n    pub longitude: f64,\n}\n\nimpl Map {\n    /// Parse a map record\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cMap\u003e {\n        let mut map = Map {\n            latitude: 0.0,\n            longitude: 0.0,\n        };\n        let level = Line::peek(record).unwrap().level;\n\n        while !record.is_empty() {\n            let mut line = Line::parse(record).unwrap();\n            match line.tag {\n                \"LATI\" =\u003e {\n                    // Need to map this:\n                    // N41.913744 -\u003e 41.913744\n                    // S41.913744 -\u003e -41.913744\n                    map.latitude = f64::from_str(\u0026line.value[1..line.value.len()]).unwrap();\n                    if line.value.chars().nth(0) == Some('S') {\n                        map.latitude *= -1.0;\n                    }\n                }\n                \"LONG\" =\u003e {\n                    // Need to map this:\n                    // W88.31085 -\u003e -88.31085\n                    // E88.31085 -\u003e 88.31085\n                    map.longitude = f64::from_str(\u0026line.value[1..line.value.len()]).unwrap();\n                    if line.value.chars().nth(0) == Some('W') {\n                        map.longitude *= -1.0;\n                    }\n                }\n                _ =\u003e {}\n            }\n\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            line = Line::peek(record).unwrap();\n            if line.level == level {\n                break;\n            }\n        }\n\n        Ok(map)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_map() {\n        let data = vec![\"3 MAP\", \"4 LATI N41.913744\", \"4 LONG W88.31085\"];\n\n        let input = data.join(\"\\n\");\n        let mut record = input.as_str();\n        let map = Map::parse(\u0026mut record).unwrap();\n\n        assert!(map.latitude == 41.913744);\n        assert!(map.longitude == -88.31085);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":17,"coverable":18},{"path":["/","Users","adam","src","rust-gedcom","src","types","mod.rs"],"content":"/// mod.rs\n// top-level record types\nmod address;\nmod adopted_by;\nmod corporation;\nmod datetime;\nmod event;\nmod family;\nmod gedc;\nmod header;\nmod individual;\nmod line;\nmod map;\nmod note;\nmod object;\nmod pedigree;\nmod place;\nmod quay;\nmod source;\nmod source_citation;\nmod sourcedata;\nmod submitter;\n\npub use address::*;\npub use adopted_by::AdoptedBy;\npub use datetime::DateTime;\npub use event::{EventDetail, EventTypeCitedFrom};\npub use family::Family;\npub use gedc::{Form, Gedc};\npub use header::Header;\npub use individual::*;\npub use line::Line;\npub use map::Map;\npub use note::Note;\npub use object::Object;\npub use pedigree::Pedigree;\npub use place::Place;\npub use quay::Quay;\npub use source::Source;\npub use source_citation::SourceCitation;\npub use sourcedata::SourceData;\npub use submitter::Submitter;\n\n#[derive(Debug, Default)]\npub struct Gedcom {\n    pub header: Header,\n    pub individuals: Vec\u003cIndividual\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","types","note.rs"],"content":"/// Parse a Note structure\n// use super::Line;\nuse crate::parse;\n\nuse winnow::prelude::*;\n\n#[derive(Debug, Default, PartialEq, Clone)]\npub struct Note {\n    /// The note\n    pub note: Option\u003cString\u003e,\n}\n\nimpl Note {\n    pub fn parse(buffer: \u0026mut \u0026str) -\u003e PResult\u003cNote\u003e {\n        let mut note = Note { note: None };\n\n        note.note = parse::get_tag_value(buffer).unwrap();\n\n        Ok(note)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Note;\n\n    #[test]\n    fn parse_note() {\n        // 1 NOTE This file demonstrates all tags that are allowed in GEDCOM 5.5. Here are some comments about the HEADER record\n        // 2 CONC and comments about where to look for information on the other 9 types of GEDCOM records. Most other records will\n        // 2 CONC have their own notes that describe what to look for in that record and what to hope the importing software will find.\n        // 2 CONT\n        // 2 CONT Many applications will fail to import these notes. The notes are therefore also provided with the files as a plain-text\n        // 2 CONC \"Read-Me\" file.\n\n        let data = vec![\n            \"1 NOTE This is the first line of a note.\",\n            \"2 CONT This is the second line of a note. \",\n            \"2 CONC This is also on the second line.\",\n            \"2 CONT This line should be the last line.\",\n        ];\n\n        let input = data.join(\"\\n\");\n        let mut record = input.as_str();\n        let note = Note::parse(\u0026mut record);\n        let n = note.unwrap().note.unwrap();\n\n        assert!(n.starts_with(\"This is the first line of a note.\\n\"));\n        assert!(n.ends_with(\"the last line.\"));\n        assert!(n == \"This is the first line of a note.\\nThis is the second line of a note. This is also on the second line.\\nThis line should be the last line.\");\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":11},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","Users","adam","src","rust-gedcom","src","types","object.rs"],"content":"// use crate::types::Line;\n\n// use nom::{bytes::complete::is_not, IResult};\n\n// 0 @M1@ OBJE\n// 1 FILE photo.jpeg\n// 2 FORM JPEG\n// 3 TYPE photo\n// 2 TITL Picture of the book cover\n// 1 REFN 01234567890123456789\n// 2 TYPE reference\n// 1 RIN 1\n// 1 NOTE Here are some notes on this multimedia object.\n// 2 CONT If decoded it should be an image of a flower.\n// 1 NOTE @N1@\n// 1 CHAN\n// 2 DATE 14 JAN 2001\n// 3 TIME 14:10:31\n\n#[derive(Debug, Eq, PartialEq, Clone)]\npub struct Object {\n    pub xref: String,\n}\n\nimpl Object {\n    pub fn parse(_record: \u0026str) -\u003e Object {\n        // let mut object = Object { xref: \"\" };\n\n        // while !record.is_empty() {\n        //     let (buffer, line) = Line::parse(\u0026record).unwrap();\n\n        //     // If we're at the top of the record, get the xref\n        //     // \u0026\u0026 level == 0\n        //     match line.level {\n        //         0 =\u003e {\n        //             object.xref = line.xref;\n        //         }\n        //         _ =\u003e {\n        //         }\n        //     }\n        // }\n        // object\n        Object {\n            xref: \"\".to_string(),\n        }\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","Users","adam","src","rust-gedcom","src","types","pedigree.rs"],"content":"use std::str::FromStr;\n\n// PEDIGREE_LINKAGE_TYPE:= {Size=5:7}\n// [ adopted | birth | foster | sealing ]\n// A code used to indicate the child to family relationship for pedigree navigation purposes.\n// Where:\n// adopted = indicates adoptive parents.\n// birth = indicates birth parents.\n// foster = indicates child was included in a foster or guardian family.\n// sealing = indicates child was sealed to parents other than birth parents.\n\n#[derive(Default, Debug, PartialEq, Clone)]\n/// The quantitative eveluation of the credibility of a piece of information\n/// based upon its supporting evidence.\npub enum Pedigree {\n    /// Adoptive parents\n    Adopted,\n    #[default]\n    /// Birth parents\n    Birth,\n    /// Foster parents\n    Foster,\n    // Sealed to parents other than birth parents\n    Sealing,\n}\n\nimpl FromStr for Pedigree {\n    type Err = ();\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cPedigree, Self::Err\u003e {\n        match input {\n            \"adopted\" =\u003e Ok(Pedigree::Adopted),\n            \"birth\" =\u003e Ok(Pedigree::Birth),\n            \"foster\" =\u003e Ok(Pedigree::Foster),\n            \"sealing\" =\u003e Ok(Pedigree::Sealing),\n            _ =\u003e Err(()),\n        }\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":7},{"path":["/","Users","adam","src","rust-gedcom","src","types","place.rs"],"content":"/// The Place structure\nuse crate::types::{Line, Map, Note};\n\nuse winnow::prelude::*;\n\n// PLACE_STRUCTURE:=\n// n PLAC \u003cPLACE_NAME\u003e {1:1} p.58\n// +1 FORM \u003cPLACE_HIERARCHY\u003e {0:1} p.58\n// 39\n// +1 FONE \u003cPLACE_PHONETIC_VARIATION\u003e {0:M} p.59\n// +2 TYPE \u003cPHONETIC_TYPE\u003e {1:1} p.57\n// +1 ROMN \u003cPLACE_ROMANIZED_VARIATION\u003e {0:M} p.59\n// +2 TYPE \u003cROMANIZED_TYPE\u003e {1:1} p.61\n// +1 MAP {0:1}\n// +2 LATI \u003cPLACE_LATITUDE\u003e {1:1} p.58\n// +2 LONG \u003cPLACE_LONGITUDE\u003e {1:1} p.58\n// +1 \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n\n#[derive(Clone, Debug, Default)]\npub struct Place {\n    pub name: Option\u003cString\u003e,\n    pub phonetic: Option\u003cPlaceVariation\u003e,\n    pub roman: Option\u003cPlaceVariation\u003e,\n    pub map: Option\u003cMap\u003e,\n    pub note: Option\u003cNote\u003e,\n}\n\nimpl Place {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cPlace\u003e {\n        let mut place = Place {\n            name: None,\n            phonetic: None,\n            roman: None,\n            map: None,\n            note: None,\n        };\n\n        let level = Line::peek(record).unwrap().level;\n        while !record.is_empty() {\n            let mut parse = true;\n            let mut line = Line::peek(record).unwrap();\n            match line.tag {\n                \"PLAC\" =\u003e {\n                    place.name = Some(line.value.to_string());\n                }\n                \"FONE\" =\u003e {\n                    place.phonetic = Some(PlaceVariation::parse(record).unwrap());\n                    parse = false;\n                }\n                \"ROMN\" =\u003e {\n                    place.roman = Some(PlaceVariation::parse(record).unwrap());\n                    parse = false;\n                }\n                \"MAP\" =\u003e {\n                    place.map = Some(Map::parse(record).unwrap());\n                    parse = false;\n                }\n                \"NOTE\" =\u003e {\n                    place.note = Some(Note::parse(record).unwrap());\n                    parse = false;\n                }\n                _ =\u003e {}\n            }\n\n            // If we need to, advance our position in the stream\n            if parse {\n                Line::parse(record).unwrap();\n            }\n\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            line = Line::peek(record).unwrap();\n            if line.level == level {\n                break;\n            }\n        }\n\n        Ok(place)\n    }\n}\n\n#[derive(Clone, Debug, Default)]\npub struct PlaceVariation {\n    pub name: Option\u003cString\u003e,\n    pub r#type: Option\u003cString\u003e,\n}\nimpl PlaceVariation {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cPlaceVariation\u003e {\n        let mut variation = PlaceVariation {\n            name: None,\n            r#type: None,\n        };\n        let level = Line::peek(record).unwrap().level;\n\n        while !record.is_empty() {\n            let mut line = Line::parse(record).unwrap();\n            match line.tag {\n                \"FONE\" =\u003e {\n                    variation.name = Some(line.value.to_string());\n                }\n                \"ROMN\" =\u003e {\n                    variation.name = Some(line.value.to_string());\n                }\n                \"TYPE\" =\u003e {\n                    variation.r#type = Some(line.value.to_string());\n                }\n                _ =\u003e {}\n            }\n\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            line = Line::peek(record).unwrap();\n            if line.level == level {\n                break;\n            }\n        }\n        Ok(variation)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_place() {\n        let data = vec![\n            \"2 PLAC Salt Lake City, UT, USA\",\n            \"3 FONE Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 ROMN Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 MAP\",\n            \"4 LATI N0\",\n            \"4 LONG E0\",\n            \"3 NOTE Place note\",\n        ];\n\n        let input = data.join(\"\\n\");\n        let mut record = input.as_str();\n        let place = Place::parse(\u0026mut record).unwrap();\n\n        assert!(place.name.is_some());\n        assert!(place.name.unwrap() == \"Salt Lake City, UT, USA\");\n\n        let phonetic = place.phonetic.unwrap();\n        assert!(phonetic.name == Some(\"Salt Lake City, UT, USA\".to_string()));\n        assert!(phonetic.r#type == Some(\"user defined\".to_string()));\n\n        let roman = place.roman.unwrap();\n        assert!(roman.name == Some(\"Salt Lake City, UT, USA\".to_string()));\n        assert!(roman.r#type == Some(\"user defined\".to_string()));\n\n        assert!(place.map.is_some());\n        let map = place.map.unwrap();\n        assert!(map.latitude == 0.0);\n        assert!(map.longitude == 0.0);\n    }\n\n    #[test]\n    fn parse_variation() {\n        let data = vec![\"3 FONE Salt Lake City, UT, USA\", \"4 TYPE user defined\"];\n\n        let input = data.join(\"\\n\");\n        let mut record = input.as_str();\n        let variation = PlaceVariation::parse(\u0026mut record).unwrap();\n\n        assert!(variation.name.is_some());\n        assert!(variation.r#type.is_some());\n\n        assert!(variation.name.unwrap() == \"Salt Lake City, UT, USA\");\n        assert!(variation.r#type.unwrap() == \"user defined\");\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":85},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":85},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":13},"fn_name":null}],"covered":41,"coverable":43},{"path":["/","Users","adam","src","rust-gedcom","src","types","quay.rs"],"content":"use std::str::FromStr;\n\n// CERTAINTY_ASSESSMENT:= {Size=1:1}\n// [ 0 | 1 | 2 | 3 ]\n// The QUAY tag's value conveys the submitter's quantitative evaluation of the credibility of a piece of\n// information, based upon its supporting evidence. Some systems use this feature to rank multiple\n// conflicting opinions for display of most likely information first. It is not intended to eliminate the\n// receiver's need to evaluate the evidence for themselves.\n// 0 = Unreliable evidence or estimated data\n// 1 = Questionable reliability of evidence (interviews, census, oral genealogies, or potential for bias\n// for example, an autobiography)\n// 2 = Secondary evidence, data officially recorded sometime after event\n// 3 = Direct and primary evidence used, or by dominance of the evidence\n\n#[derive(Clone, Default, Debug, PartialEq)]\n/// The quantitative eveluation of the credibility of a piece of information\n/// based upon its supporting evidence.\npub enum Quay {\n    #[default]\n    Unreliable,\n    Questionable,\n    Secondary,\n    Direct,\n}\n\nimpl FromStr for Quay {\n    type Err = ();\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cQuay, Self::Err\u003e {\n        match input {\n            \"0\" =\u003e Ok(Quay::Unreliable),\n            \"1\" =\u003e Ok(Quay::Questionable),\n            \"2\" =\u003e Ok(Quay::Secondary),\n            \"3\" =\u003e Ok(Quay::Direct),\n            _ =\u003e Err(()),\n        }\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":7},{"path":["/","Users","adam","src","rust-gedcom","src","types","source.rs"],"content":"// use crate::parse;\n// use crate::types::corporation::Corporation;\n\nuse super::{corporation::Corporation, Line, SourceData};\n\n// +1 SOUR \u003cAPPROVED_SYSTEM_ID\u003e\n//     +2 VERS \u003cVERSION_NUMBER\u003e\n//     +2 NAME \u003cNAME_OF_PRODUCT\u003e\n//     +2 CORP \u003cNAME_OF_BUSINESS\u003e\n//         +3 \u003c\u003cADDRESS_STRUCTURE\u003e\u003e\n//     +2 DATA \u003cNAME_OF_SOURCE_DATA\u003e\n//         +3 DATE \u003cPUBLICATION_DATE\u003e\n//         +3 COPR \u003cCOPYRIGHT_SOURCE_DATA\u003e\n//         +4 [CONT|CONC]\u003cCOPYRIGHT_SOURCE_DATA\u003e\n\n// 1 SOUR Ancestry.com Family Trees\n// 2 NAME Ancestry.com Member Trees\n// 2 VERS 2021.07\n// 2 _TREE Ambrose Bierce Family Tree\n// 3 RIN 116823582\n// 3 _ENV prd\n// 2 CORP Ancestry.com\n// 3 PHON 801-705-7000\n// 3 WWW www.ancestry.com\n// 3 ADDR 1300 West Traverse Parkway\n// 4 CONT Lehi, UT  84043\n// 4 CONT USA\n\n#[derive(Clone, Debug, Default)]\npub struct Source {\n    /// A corporation tag contains the name of the corporation and its address.\n    pub corporation: Option\u003cCorporation\u003e,\n    // pub data: Option\u003cData\u003e,\n    pub name: Option\u003cString\u003e,\n    pub source: String,\n    pub data: Option\u003cSourceData\u003e,\n    // pub copyright: Option\u003cCopyright\u003e,\n    pub version: Option\u003cString\u003e,\n}\n\nimpl Source {\n    /// Parse a SOUR record\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cSource\u003e) {\n        let mut source = Source {\n            corporation: None,\n            data: None,\n            name: None,\n            source: \"\".to_string(),\n            version: None,\n        };\n        let mut line: Line;\n\n        line = Line::peek(\u0026mut buffer).unwrap();\n\n        // Verify we have a SOUR record\n        if line.level == 1 \u0026\u0026 line.tag == \"SOUR\" {\n            // Consume the first line\n            line = Line::parse(\u0026mut buffer).unwrap();\n\n            source.source = line.value.to_string();\n\n            let mut next = Line::peek(\u0026mut buffer).unwrap();\n\n            while next.level \u003e= line.level {\n                // We don't want to consume the line yet because we may need\n                // the original for a parser.\n                let inner_line: Line = Line::peek(\u0026mut buffer).unwrap();\n\n                // println!(\"Evaluating tag: {:?}\", inner_line.tag);\n                match inner_line.tag {\n                    // An ancestry-specific tag\n                    \"_TREE\" =\u003e {\n                        // The value of tree contains the tree name, which is useful,\n                        // but not a part of the GEDCOM spec.\n                        // The next level (3) may contain RIN, some sort of internal id\n                        // but is probably not useful for anything\n                        println!(\"Skipping _TREE\");\n                        // Consume the line\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"CORP\" =\u003e {\n                        (buffer, source.corporation) = Corporation::parse(buffer);\n                    }\n                    \"NAME\" =\u003e {\n                        source.name = Some(inner_line.value.to_string());\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"VERS\" =\u003e {\n                        source.version = Some(inner_line.value.to_string());\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"DATA\" =\u003e {\n                        (buffer, source.data) = SourceData::parse(buffer);\n                    }\n                    _ =\u003e {\n                        println!(\"Unknown line: {:?}\", inner_line);\n\n                        // consume the line so we can parse the next\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                }\n\n                // Peek at the next level\n                if !buffer.is_empty() {\n                    next = Line::peek(\u0026mut buffer).unwrap();\n                    if next.level \u003c= 1 {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n\n        (buffer, Some(source))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::types::DateTime;\n\n    use super::{Source, SourceData};\n\n    #[test]\n    fn parse() {\n        let data = vec![\n            \"1 SOUR GEDitCOM\",\n            \"2 VERS 2.9.4\",\n            \"2 NAME GEDitCOM\",\n            \"2 CORP RSAC Software\",\n            \"3 ADDR\",\n            \"4 ADR1 RSAC Software\",\n            \"4 ADR2 7108 South Pine Cone Street\",\n            \"4 ADR3 Ste 1\",\n            \"4 CITY Salt Lake City\",\n            \"4 STAE UT\",\n            \"4 POST 84121\",\n            \"4 CTRY USA\",\n            \"3 PHON +1-801-942-7768\",\n            \"3 PHON +1-801-555-1212\",\n            \"3 PHON +1-801-942-1148\",\n            \"3 EMAIL a@@example.com\",\n            \"3 EMAIL b@@example.com\",\n            \"3 EMAIL c@@example.com\",\n            \"3 FAX +1-801-942-7768\",\n            \"3 FAX +1-801-555-1212\",\n            \"3 FAX +1-801-942-1148\",\n            \"3 WWW https://www.example.com\",\n            \"3 WWW https://www.example.org\",\n            \"3 WWW https://www.example.net\",\n            \"2 DATA Name of source data\",\n            \"3 DATE 1 JAN 1998\",\n            \"3 COPR Copyright of source data\",\n        ];\n\n        let (_data, source) = Source::parse(\u0026data.join(\"\\n\"));\n        let sour = source.unwrap();\n\n        assert_eq!(sour.source, \"GEDitCOM\".to_string());\n        assert_eq!(sour.name, Some(\"GEDitCOM\".to_string()));\n        assert_eq!(sour.version, Some(\"2.9.4\".to_string()));\n        assert_eq!(\n            sour.data,\n            Some(SourceData {\n                name: Some(\"Name of source data\".to_string()),\n                date: Some(DateTime {\n                    date: Some(\"1 JAN 1998\".to_string()),\n                    time: None\n                }),\n                copyright: Some(\"Copyright of source data\".to_string()),\n            })\n        );\n        let corp = sour.corporation.unwrap();\n\n        assert_eq!(corp.name, Some(\"RSAC Software\".to_string()));\n\n        let corp_address: crate::types::Address = corp.address.unwrap();\n        assert_eq!(corp_address.addr1, Some(\"RSAC Software\".to_string()));\n        assert_eq!(\n            corp_address.addr2,\n            Some(\"7108 South Pine Cone Street\".to_string())\n        );\n        assert_eq!(corp_address.addr3, Some(\"Ste 1\".to_string()));\n        assert_eq!(corp_address.city, Some(\"Salt Lake City\".to_string()));\n        assert_eq!(corp_address.state, Some(\"UT\".to_string()));\n        assert_eq!(corp_address.postal_code, Some(\"84121\".to_string()));\n        assert_eq!(corp_address.country, Some(\"USA\".to_string()));\n\n        assert!(corp_address.phone.contains(\u0026\"+1-801-942-7768\".to_string()));\n        assert!(corp_address.phone.contains(\u0026\"+1-801-555-1212\".to_string()));\n        assert!(corp_address.phone.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(corp_address.email.contains(\u0026\"a@@example.com\".to_string()));\n        assert!(corp_address.email.contains(\u0026\"b@@example.com\".to_string()));\n        assert!(corp_address.email.contains(\u0026\"c@@example.com\".to_string()));\n        assert!(corp_address.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(corp_address.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(corp_address.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(corp_address\n            .www\n            .contains(\u0026\"https://www.example.com\".to_string()));\n        assert!(corp_address\n            .www\n            .contains(\u0026\"https://www.example.org\".to_string()));\n        assert!(corp_address\n            .www\n            .contains(\u0026\"https://www.example.net\".to_string()));\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":28,"coverable":33},{"path":["/","Users","adam","src","rust-gedcom","src","types","source_citation.rs"],"content":"use std::str::FromStr;\n\nuse crate::parse;\n\nuse super::{EventTypeCitedFrom, Line, Note, Object, Quay};\n\nuse winnow::prelude::*;\n\n// [ /* pointer to source record (preferred)*/\n// n SOUR @\u003cXREF:SOUR\u003e@ {1:1} p.27\n// +1 PAGE \u003cWHERE_WITHIN_SOURCE\u003e {0:1} p.64\n// +1 EVEN \u003cEVENT_TYPE_CITED_FROM\u003e {0:1} p.49\n// +2 ROLE \u003cROLE_IN_EVENT\u003e {0:1} p.61\n// +1 DATA {0:1}\n// +2 DATE \u003cENTRY_RECORDING_DATE\u003e {0:1} p.48\n// +2 TEXT \u003cTEXT_FROM_SOURCE\u003e {0:M} p.63\n// +3 [CONC|CONT] \u003cTEXT_FROM_SOURCE\u003e {0:M}\n// +1 \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n// +1 \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// +1 QUAY \u003cCERTAINTY_ASSESSMENT\u003e {0:1} p.43\n\n// | /* Systems not using source records */\n// n SOUR \u003cSOURCE_DESCRIPTION\u003e {1:1} p.61\n// +1 [CONC|CONT] \u003cSOURCE_DESCRIPTION\u003e {0:M}\n// +1 TEXT \u003cTEXT_FROM_SOURCE\u003e {0:M} p.63\n// +2 [CONC|CONT] \u003cTEXT_FROM_SOURCE\u003e {0:M}\n// +1 \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n// +1 \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// +1 QUAY \u003cCERTAINTY_ASSESSMENT\u003e {0:1} p.43\n// ]\n\n#[derive(Clone, Debug, Default)]\npub struct SourceCitation {\n    pub xref: Option\u003cString\u003e,\n    pub page: Option\u003ci32\u003e,\n    pub event: Option\u003cEventTypeCitedFrom\u003e,\n    pub data: Option\u003cSourceCitationData\u003e,\n    pub media: Vec\u003cObject\u003e,\n    pub note: Option\u003cNote\u003e,\n    pub quay: Option\u003cQuay\u003e,\n}\n\nimpl SourceCitation {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cSourceCitation\u003e {\n        let mut sc = SourceCitation {\n            xref: None,\n            page: None,\n            event: None,\n            data: None,\n            media: vec![],\n            note: None,\n            quay: None,\n        };\n\n        let level = Line::peek(record).unwrap().level;\n        let mut line = Line::peek(record).unwrap();\n\n        while !record.is_empty() {\n            let mut consume = true;\n            match line.tag {\n                \"DATA\" =\u003e {\n                    sc.data = Some(SourceCitationData::parse(record).unwrap());\n                    consume = false;\n                }\n                \"EVEN\" =\u003e {\n                    sc.event = Some(EventTypeCitedFrom::parse(record).unwrap());\n                    consume = false;\n                }\n                \"NOTE\" =\u003e {\n                    let note = parse::get_tag_value(record).unwrap();\n                    sc.note = Some(Note { note });\n                    consume = false;\n                }\n                \"OBJE\" =\u003e {\n                    let obj = Object {\n                        xref: line.value.to_string(),\n                    };\n                    sc.media.push(obj);\n                }\n                \"PAGE\" =\u003e {\n                    sc.page = Some(line.value.parse().unwrap());\n                }\n                \"QUAY\" =\u003e {\n                    let quay = Quay::from_str(line.value).unwrap();\n                    sc.quay = Some(quay);\n                }\n                \"SOUR\" =\u003e {\n                    sc.xref = Some(line.value.to_string());\n                }\n                _ =\u003e {}\n            }\n\n            if consume {\n                Line::parse(record).unwrap();\n            }\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            line = Line::peek(record).unwrap();\n            if line.level == level {\n                break;\n            }\n        }\n\n        Ok(sc)\n    }\n}\n\n#[derive(Clone, Debug, Default)]\npub struct SourceCitationData {\n    pub date: Option\u003cString\u003e,\n    pub text: Option\u003cNote\u003e,\n}\nimpl SourceCitationData {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cSourceCitationData\u003e {\n        let mut data = SourceCitationData {\n            date: None,\n            text: None,\n        };\n\n        let level = Line::peek(record).unwrap().level;\n        let mut line = Line::peek(record).unwrap();\n\n        while !record.is_empty() {\n            let mut consume = true;\n            match line.tag {\n                \"DATE\" =\u003e {\n                    data.date = Some(line.value.to_string());\n                }\n                \"TEXT\" =\u003e {\n                    let text = parse::get_tag_value(record).unwrap();\n                    let note = Note { note: text };\n                    data.text = Some(note);\n                    consume = false;\n                }\n                _ =\u003e {}\n            }\n\n            if consume {\n                Line::parse(record).unwrap();\n            }\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            line = Line::peek(record).unwrap();\n            if line.level == level {\n                break;\n            }\n        }\n        Ok(data)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_source_citation() {\n        let data = vec![\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE Some notes about this birth source citation which are embedded in the citation \",\n            \"4 CONC structure itself.\",\n            \"3 QUAY 2\",\n        ].join(\"\\n\");\n\n        let mut record = data.as_str();\n        let detail = SourceCitation::parse(\u0026mut record).unwrap();\n\n        assert!(detail.data.is_some());\n        let sc = detail.data.unwrap();\n        assert!(sc.date.unwrap() == \"1 JAN 1900\");\n        assert!(sc.text.unwrap().note.unwrap() == \"Here is some text from the source specific to this source citation.\\nHere is more text but on a new line.\");\n\n        assert!(detail.xref.is_some());\n        assert!(detail.xref.unwrap() == \"@S1@\");\n\n        assert!(detail.event.is_some());\n        let event = detail.event.unwrap();\n        assert!(event.r#type.unwrap() == \"BIRT\");\n        assert!(event.role.unwrap() == \"CHIL\");\n\n        assert!(detail.page.is_some());\n        assert!(detail.page.unwrap() == 42);\n    }\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":143},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":136},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":130},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":26},"fn_name":null}],"covered":53,"coverable":54},{"path":["/","Users","adam","src","rust-gedcom","src","types","sourcedata.rs"],"content":"use super::{DateTime, Line};\nuse crate::parse;\n\n//     +2 DATA \u003cNAME_OF_SOURCE_DATA\u003e\n//         +3 DATE \u003cPUBLICATION_DATE\u003e\n//         +3 COPR \u003cCOPYRIGHT_SOURCE_DATA\u003e\n//         +4 [CONT|CONC]\u003cCOPYRIGHT_SOURCE_DATA\u003e\n#[derive(Clone, Debug, Default, PartialEq)]\npub struct SourceData {\n    pub name: Option\u003cString\u003e,\n    pub date: Option\u003cDateTime\u003e,\n    pub copyright: Option\u003cString\u003e,\n}\n\nimpl SourceData {\n    /// Parse a SOUR record\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cSourceData\u003e) {\n        let mut data = SourceData {\n            name: None,\n            date: None,\n            copyright: None,\n        };\n        let mut line: Line;\n\n        line = Line::peek(\u0026mut buffer).unwrap();\n        if line.tag == \"DATA\" {\n            let lvl = line.level;\n\n            // consume the line\n            line = Line::parse(\u0026mut buffer).unwrap();\n            data.name = Some(line.value.to_string());\n\n            while line.level \u003e= lvl {\n                if buffer.is_empty() {\n                    break;\n                }\n\n                line = Line::peek(\u0026mut buffer).unwrap();\n                if line.level == 1 {\n                    // abort\n                    break;\n                }\n                match line.tag {\n                    \"DATE\" =\u003e {\n                        (buffer, data.date) = DateTime::parse(buffer);\n                    }\n                    \"COPR\" =\u003e {\n                        // Consume the line and get the value\n                        data.copyright = parse::get_tag_value(\u0026mut buffer).unwrap();\n                    }\n                    _ =\u003e {\n                        break;\n                    }\n                }\n            }\n        }\n\n        (buffer, Some(data))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::SourceData;\n    use crate::types::DateTime;\n\n    #[test]\n    fn parse() {\n        let data = vec![\n            \"2 DATA Name of source data\",\n            \"3 DATE 1 JAN 1998\",\n            \"3 COPR Copyright of source data\",\n        ];\n\n        let (_data, _sourcedata) = SourceData::parse(\u0026data.join(\"\\n\"));\n        let sourcedata = _sourcedata.unwrap();\n\n        assert_eq!(\n            Some(sourcedata),\n            Some(SourceData {\n                name: Some(\"Name of source data\".to_string()),\n                date: Some(DateTime {\n                    date: Some(\"1 JAN 1998\".to_string()),\n                    time: None\n                }),\n                copyright: Some(\"Copyright of source data\".to_string()),\n            })\n        );\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":20,"coverable":20},{"path":["/","Users","adam","src","rust-gedcom","src","types","submitter.rs"],"content":"use crate::types::{Address, DateTime, Line, Note};\n\n// n @\u003cXREF:SUBM\u003e@ SUBM {1:1}\n// +1 NAME \u003cSUBMITTER_NAME\u003e {1:1} p.63\n// +1 \u003c\u003cADDRESS_STRUCTURE\u003e\u003e {0:1}* p.31\n// +1 \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n// +1 LANG \u003cLANGUAGE_PREFERENCE\u003e {0:3} p.51\n// +1 RFN \u003cSUBMITTER_REGISTERED_RFN\u003e {0:1} p.63\n// +1 RIN \u003cAUTOMATED_RECORD_ID\u003e {0:1} p.43\n// +1 \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// +1 \u003c\u003cCHANGE_DATE\u003e\u003e\n\n#[derive(Clone, Debug, Default, PartialEq)]\npub struct Submitter {\n    /// The pointer to the SUBM record\n    pub xref: Option\u003cString\u003e,\n    pub name: Option\u003cString\u003e,\n    pub address: Option\u003cAddress\u003e,\n    pub media: Vec\u003cString\u003e,\n    /// A list of languages in which the submitter prefers to communicate\n    /// listed in order of priority.\n    pub lang: Vec\u003cString\u003e,\n    pub rfn: Option\u003cString\u003e,\n    pub rin: Option\u003cString\u003e,\n    pub note: Option\u003cNote\u003e,\n    pub change_date: Option\u003cDateTime\u003e,\n}\n\nimpl Submitter {\n    pub fn find_by_xref(mut buffer: \u0026str, xref: String) -\u003e Option\u003cSubmitter\u003e {\n        // println!(\"find_by_xref::buffer: {:?}\", buffer);\n        let mut submitter = Submitter {\n            xref: Some(xref),\n            name: None,\n            address: None,\n            media: vec![],\n            lang: vec![],\n            rfn: None,\n            rin: None,\n            note: None,\n            change_date: None,\n        };\n        let mut line = Line::peek(\u0026mut buffer).unwrap();\n\n        while !buffer.is_empty() {\n            // this is only going to match one line. We want to skip forward\n            // until we reach this line, and then process until we hit either EOF or a new 0 level\n            // if line.level == 0 \u0026\u0026 xref == line.xref.unwrap() {\n            if line.level == 0 {\n                // Peek at the next line so we know how to parse it.\n                line = Line::peek(\u0026mut buffer).unwrap();\n\n                // Loop through the rest of the record\n                while line.level \u003e 0 || !buffer.is_empty() {\n                    match line.tag {\n                        \"NAME\" =\u003e {\n                            submitter.name = Some(line.value.to_string());\n                            Line::parse(\u0026mut buffer).unwrap();\n                        }\n                        \"ADDR\" =\u003e {\n                            submitter.address = Some(Address::parse(\u0026mut buffer).unwrap());\n                        }\n                        \"OBJE\" =\u003e {\n                            // Parse the object id and add it to the list\n                            let media_xref = line.value;\n                            submitter.media.push(media_xref.to_string());\n                            Line::parse(\u0026mut buffer).unwrap();\n                            // TODO: find the media object and parse it\n                        }\n                        \"RIN\" =\u003e {\n                            line = Line::parse(\u0026mut buffer).unwrap();\n                            submitter.rin = Some(line.value.to_string());\n                            // println!(\"!! {:}\", line.tag);\n                        }\n                        \"CHAN\" =\u003e {\n                            // Parse the date/time\n                            Line::parse(\u0026mut buffer).unwrap();\n                            (buffer, submitter.change_date) = DateTime::parse(buffer);\n                        }\n                        \"LANG\" =\u003e {\n                            let lang = line.value;\n                            submitter.lang.push(lang.to_string());\n                            Line::parse(\u0026mut buffer).unwrap();\n                        }\n                        \"NOTE\" =\u003e {\n                            submitter.note = Some(Note::parse(\u0026mut buffer).unwrap());\n                        }\n                        \"RFN\" =\u003e {\n                            let rfn = line.value;\n                            submitter.rfn = Some(rfn.to_string());\n                            Line::parse(\u0026mut buffer).unwrap();\n                        }\n                        _ =\u003e {\n                            // Advance the buffer past the unknown line\n                            Line::parse(\u0026mut buffer).unwrap();\n                        }\n                    }\n                    line = Line::peek(\u0026mut buffer).unwrap();\n                }\n            } else {\n                line = Line::parse(\u0026mut buffer).unwrap();\n            }\n        }\n\n        Some(submitter)\n    }\n\n    /// Parses a SUBM block\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cSubmitter\u003e) {\n        let mut submitter = Submitter {\n            xref: None,\n            name: None,\n            address: None,\n            media: vec![],\n            lang: vec![],\n            rfn: None,\n            rin: None,\n            note: None,\n            change_date: None,\n        };\n        let mut line = Line::peek(\u0026mut buffer).unwrap();\n        if line.level == 1 \u0026\u0026 line.tag == \"SUBM\" {\n            // advance our position in the buffer\n            line = Line::parse(\u0026mut buffer).unwrap();\n            // This is a temporary hack, because parse::xref strips @ from the id\n            let xref = line.value;\n            submitter.xref = Some(xref.to_owned());\n        }\n\n        (buffer, Some(submitter))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Submitter;\n\n    #[test]\n    fn parse_submitter() {\n        let data = vec![\n            \"1 SUBM @U1@\",\n            // other records that we need to skip over\n            \"1 FILE TGC55C.ged\",\n            \"1 COPR © 1997 by H. Eichmann, parts © 1999-2000 by J. A. Nairn.\",\n            // The submitter record\n            \"0 @U1@ SUBM\",\n            \"1 NAME Adam Israel\",\n            \"1 ADDR\",\n            \"2 ADR1 Example Software\",\n            \"2 ADR2 123 Main Street\",\n            \"2 ADR3 Ste 1\",\n            \"2 CITY Anytown\",\n            \"2 STAE IL\",\n            \"2 POST 55555\",\n            \"2 CTRY USA\",\n            \"1 PHON +1-800-555-1111\",\n            \"1 PHON +1-800-555-1212\",\n            \"1 PHON +1-800-555-1313\",\n            \"1 EMAIL a@@example.com\",\n            \"1 EMAIL b@@example.com\",\n            \"1 EMAIL c@@example.com\",\n            \"1 FAX +1-800-555-1414\",\n            \"1 FAX +1-800-555-1515\",\n            \"1 FAX +1-800-555-1616\",\n            \"1 WWW https://www.example.com\",\n            \"1 WWW https://www.example.org\",\n            \"1 WWW https://www.example.net\",\n            \"1 OBJE @M1@\",\n            \"1 RFN 123456789\",\n            \"1 RIN 1\",\n            \"1 NOTE This is a test note.\",\n            \"2 CONT And so is this.\",\n            \"1 CHAN\",\n            \"2 DATE 7 SEP 2000\",\n            \"3 TIME 8:35:36\",\n            \"1 LANG English\",\n            \"1 LANG German\",\n        ];\n\n        let (_, mut submitter) = Submitter::parse(data.join(\"\\n\").as_str());\n        let xref = submitter.unwrap().xref;\n\n        // Now, find the xref\n        submitter = Submitter::find_by_xref(data.join(\"\\n\").as_str(), xref.unwrap());\n        let s = submitter.unwrap();\n\n        assert!(s.xref == Some(\"@U1@\".to_string()));\n        assert!(s.name == Some(\"Adam Israel\".to_string()));\n\n        let addr = s.address.unwrap();\n\n        assert!(addr.addr1 == Some(\"Example Software\".to_string()));\n        assert!(addr.addr2 == Some(\"123 Main Street\".to_string()));\n        assert!(addr.addr3 == Some(\"Ste 1\".to_string()));\n        assert!(addr.city == Some(\"Anytown\".to_string()));\n        assert!(addr.state == Some(\"IL\".to_string()));\n        assert!(addr.postal_code == Some(\"55555\".to_string()));\n        assert!(addr.country == Some(\"USA\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-800-555-1111\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-800-555-1212\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-800-555-1313\".to_string()));\n        assert!(addr.email.contains(\u0026\"a@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"b@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"c@@example.com\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-800-555-1414\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-800-555-1515\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-800-555-1616\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.com\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.org\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.net\".to_string()));\n\n        // TODO: Make sure this resolves to a Media record\n        assert!(s.media.contains(\u0026\"@M1@\".to_string()));\n\n        assert!(s.lang.contains(\u0026\"English\".to_string()));\n        assert!(s.lang.contains(\u0026\"German\".to_string()));\n\n        assert!(s.rin == Some(\"1\".to_string()));\n\n        let date = s.change_date.unwrap();\n        assert!(date.date == Some(\"7 SEP 2000\".to_string()));\n        assert!(date.time == Some(\"8:35:36\".to_string()));\n\n        // TODO: Implement these once the fields are implemented.\n        assert!(s.rfn == Some(\"123456789\".to_string()));\n\n        let note = s.note.unwrap().note.unwrap();\n        assert!(note.starts_with(\"This is a test note.\"));\n        assert!(note.ends_with(\"And so is this.\"));\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":47,"coverable":49}]};
        var previousData = {"files":[{"path":["/","Users","adam","src","rust-gedcom","benches","parse_gedcom.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\nuse gedcom_rs::parse::parse_gedcom;\n\nuse std::time::Duration;\n\nconst FILENAME: \u0026str = \"data/complete.ged\";\n\nfn criterion_benchmark(c: \u0026mut Criterion) {\n    let mut group = c.benchmark_group(\"parse-gedcom\");\n    group.measurement_time(Duration::from_secs(30));\n\n    // TODO: Benchmark individual types?\n    group.bench_function(\"parse gedcom\", |b| b.iter(|| parse_gedcom(FILENAME)));\n    group.finish();\n}\n\ncriterion_group!(benches, criterion_benchmark);\ncriterion_main!(benches);\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","lib.rs"],"content":"pub mod parse;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","main.rs"],"content":"extern crate gedcom_rs;\n\nuse gedcom_rs::parse::parse_gedcom;\n\nuse std::env;\n\nfn main() {\n    let args: Vec\u003cString\u003e = env::args().collect();\n    match args.len() {\n        1 =\u003e usage(\"Missing filename.\"),\n        s if s \u003e 2 =\u003e usage(\u0026format!(\"Found more args than expected: {:?}\", \u0026args[1..])),\n        _ =\u003e (),\n    };\n\n    let filename = \u0026args[1];\n\n    if filename == \"--help\" || filename == \"-h\" {\n        usage(\"\");\n    }\n\n    let gedcom = parse_gedcom(filename);\n\n    // TODO: print a pretty summary of the gedcom. Use `tabled` crate?\n    println!(\"{:#?}\", gedcom);\n}\n\nfn usage(msg: \u0026str) {\n    if !msg.is_empty() {\n        println!(\"{msg}\");\n    }\n    println!(\"Usage: gedcom-test ./path/to/gedcom.ged\");\n    std::process::exit(0x0100);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_complete_gedcom() {\n        let gedcom = parse_gedcom(\"./data/complete.ged\");\n\n        // Test the header\n        // println!(\"Gedcom: {:?}\", gedcom.header);\n        // Test the copyright header\n        assert!(gedcom.header.copyright.is_some());\n        let copyright = gedcom.header.copyright.unwrap();\n        assert!(\n            copyright == \"© 1997 by H. Eichmann, parts © 1999-2000 by J. A. Nairn.\".to_string()\n        );\n\n        // Test the note field\n        assert!(gedcom.header.note.is_some());\n        let note = gedcom.header.note.unwrap();\n        assert!(note.starts_with(\"This file demonstrates all tags that are allowed in GEDCOM 5.5.\"));\n        assert!(note.ends_with(\"GEDCOM 5.5 specs on the Internet at \u003chttp://homepages.rootsweb.com/~pmcbride/gedcom/55gctoc.htm\u003e.\"));\n    }\n\n    // #[test]\n    // /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    // /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    // fn newline_in_note() {\n    //     let data = vec![\n    //         \"0 @S313871942@ SOUR\",\n    //         \"1 TITL Germany, Lutheran Baptisms, Marriages, and Burials, 1567-1945\",\n    //         \"1 AUTH Ancestry.com\",\n    //         \"1 PUBL Ancestry.com Operations, Inc.\",\n    //         \"1 NOTE \u003cp\u003eMikrofilm Sammlung.  Familysearch.org\u003c/p\u003e\",\n    //         \"\u003cp\u003eOriginale:  Lutherische Kirchenbücher, 1567-1945. Various sources.\u003c/p\u003e\",\n    //         \"1 _APID 1,61250::0\",\n    //     ];\n\n    //     // assert_eq!(expected, line(\"\\r\")(\"0 HEAD\\r\").unwrap());\n    //     // assert_eq!(expected, line(\"\\n\")(\"0 HEAD\\n\").unwrap());\n    //     // assert_eq!(expected, line(\"\\r\\n\")(\"0 HEAD\\r\\n\").unwrap());\n    // }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":16},{"path":["/","Users","adam","src","rust-gedcom","src","parse.rs"],"content":"// use crate::types::{Address, Line, Source};\n// use super::types::Line;\nuse super::types::*;\n\nuse std::fs::File;\n\nuse std::io::{self, BufRead};\nuse std::path::Path;\n\nuse winnow::prelude::*;\n\n/// This is pretty much a kludge to strip out U+FEFF, a Zero Width No-Break Space\n/// https://www.compart.com/en/unicode/U+FEFF\n///\n/// So far, I've only seen this with one GEDCOM, as the starting byte.\n// pub fn zero_with_no_break_space(input: \u0026mut \u0026str) -\u003e PResult\u003c\u0026str\u003e {\n//     if input.starts_with('\\u{FEFF}') {\n//         let parser = tag(\"\\u{FEFF}\");\n\n//         parser.parse_next(input)\n//     } else {\n//         Ok(\"\")\n//     }\n// }\n\n/// Read the next tag's value and any continuations\npub fn get_tag_value(input: \u0026mut \u0026str) -\u003e PResult\u003cOption\u003cString\u003e\u003e {\n    let mut line = Line::parse(input).unwrap();\n\n    // Seed the value with the initial value\n    let mut text: String = line.value.to_string();\n\n    line = Line::peek(input).unwrap();\n    while line.tag == \"CONC\" || line.tag == \"CONT\" {\n        // consume\n        line = Line::parse(input).unwrap();\n\n        if line.tag == \"CONT\" {\n            text += \"\\n\";\n        }\n        text += line.value;\n\n        // peek ahead\n        line = Line::peek(input).unwrap();\n    }\n\n    Ok(Some(text))\n}\n\n/// Parse the buffer if the CONC tag is found and return the resulting string.\n// pub fn conc(input: \u0026mut \u0026str) -\u003e PResult\u003cOption\u003cString\u003e\u003e {\n//     let line = Line::parse(input).unwrap();\n\n//     if line.tag == \"CONC\" {\n//         Ok(Some(line.value.to_string()))\n//     } else {\n//         Ok(None)\n//     }\n// }\n\n/// Parse the buffer if the CONT tag is found and return the resulting string.\n/// TODO: Refactor this. It should handle CONT and CONC.\n// pub fn cont(input: \u0026mut \u0026str) -\u003e PResult\u003cOption\u003cString\u003e\u003e {\n//     let line = Line::parse(input).unwrap();\n\n//     if line.tag == \"CONT\" {\n//         Ok(Some(line.value.to_string()))\n//     } else {\n//         Ok(None)\n//     }\n// }\n\n/// Parse a GEDCOM file\npub fn parse_gedcom(filename: \u0026str) -\u003e Gedcom {\n    // Initialize an empty gedcom\n    let mut gedcom = Gedcom {\n        header: Header {\n            encoding: None,\n            copyright: None,\n            date: None,\n            destination: None,\n            gedcom_version: None,\n            language: None,\n            filename: None,\n            note: None,\n            source: None,\n            submitter: None,\n            submission: None,\n        },\n        individuals: vec![],\n    };\n\n    if let Ok(lines) = read_lines(filename) {\n        // Consumes the iterator, returns an (Optional) String\n\n        // Read through the lines and build a buffer of \u003crecords\u003e, each starting\n        // with a zero and ending with the last line before the next. Then feed that\n        // buffer to a nom parser to split it into Lines?\n\n        // This is kind of like a buffered read, specific to the GEDCOM format\n        // We read into the buffer until we hit a new record, and then parse that\n        // record into a struct.\n        let mut record: String = String::new();\n\n        for mut buffer in lines.flatten() {\n            // Strip off any leading Zero Width No-Break Space\n            if buffer.strip_prefix('\\u{FEFF}').is_some() {\n                buffer.remove(0);\n            }\n            // println!(\"Buffer: \\n'{}'\", buffer);\n            // record = buffer.clone() + \"\\n\";\n\n            if let Some(ch) = buffer.chars().next() {\n                if ch == '0' \u0026\u0026 !record.is_empty() {\n                    let mut input: \u0026str = record.as_str();\n\n                    // Peek at the first line in the record so we know how\n                    // to parse it.\n                    let line = Line::peek(\u0026mut input).unwrap();\n                    // println!(\"Got a line: {:?}\", line);\n                    match line.tag {\n                        \"HEAD\" =\u003e {\n                            // println!(\"Parsing HEAD: \\n{}\", input);\n                            gedcom.header = Header::parse(input.to_string());\n                        }\n                        \"INDI\" =\u003e {\n                            let indi = Individual::parse(\u0026mut input);\n                            // TODO: Remove the if. This is just to clean up the output for debugging.\n                            // if indi.xref.clone().unwrap() == \"@I1@\" {\n                            gedcom.individuals.push(indi);\n                            // }\n                        }\n                        \"SOUR\" =\u003e {}\n                        \"REPO\" =\u003e {}\n                        \"OBJE\" =\u003e {\n                            // let obj = Object::parse(buff);\n                            // println!(\"{:?}\", obj);\n                        }\n                        \"FAM\" =\u003e {}\n                        \"SUBM\" =\u003e {\n                            // // The record of the submitter of the family tree\n                            // // Not always present (it exists in complete.ged)\n                            // if let Some(ref subm) = gedcom.header.submitter {\n                            //     if let Some(xref) = \u0026subm.xref {\n                            //         gedcom.header.submitter =\n                            //             Submitter::find_by_xref(buff, xref.to_string());\n                            //     }\n                            // }\n                        }\n                        _ =\u003e {}\n                    };\n\n                    record.clear();\n                }\n                record = record + \u0026buffer.clone() + \"\\n\";\n            }\n        }\n        // TODO: families\n        // TODO: repositories\n        // TODO: sources\n        // TODO: multimedia\n    }\n    gedcom\n}\n\n// The output is wrapped in a Result to allow matching on errors\n// Returns an Iterator to the Reader of the lines of the file.\n// https://doc.rust-lang.org/rust-by-example/std_misc/file/read_lines.html\nfn read_lines\u003cP\u003e(filename: P) -\u003e io::Result\u003cio::Lines\u003cio::BufReader\u003cFile\u003e\u003e\u003e\nwhere\n    P: AsRef\u003cPath\u003e,\n{\n    let file = File::open(filename)?;\n    Ok(io::BufReader::new(file).lines())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_get_tag_value() {\n        let mut input = \"3 ADDR 1300 West Traverse Parkway\\n4 CONT Lehi, UT 84043 \\n4 CONC USA\";\n        let output = \"1300 West Traverse Parkway\\nLehi, UT 84043 USA\";\n\n        let res = get_tag_value(\u0026mut input).unwrap();\n        if let Some(value) = res {\n            assert!(output == value);\n        }\n        assert!(input.len() == 0);\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":149},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":149},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":149},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":149},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":582},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":284},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":111},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":173},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":149},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1955},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1956},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3910},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":77},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1955},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":39,"coverable":40},{"path":["/","Users","adam","src","rust-gedcom","src","types","address.rs"],"content":"use super::Line;\nuse crate::parse;\n\nuse winnow::prelude::*;\n\n#[derive(Debug, Default, PartialEq, Clone)]\npub struct Address {\n    pub addr1: Option\u003cString\u003e,\n    pub addr2: Option\u003cString\u003e,\n    pub addr3: Option\u003cString\u003e,\n    pub city: Option\u003cString\u003e,\n    pub state: Option\u003cString\u003e,\n    pub postal_code: Option\u003cString\u003e,\n    pub country: Option\u003cString\u003e,\n    pub phone: Vec\u003cString\u003e,\n    pub email: Vec\u003cString\u003e,\n    pub fax: Vec\u003cString\u003e,\n    pub www: Vec\u003cString\u003e,\n}\n\nimpl Address {\n    pub fn parse(buffer: \u0026mut \u0026str) -\u003e PResult\u003cAddress\u003e {\n        let mut address = Address {\n            addr1: None,\n            addr2: None,\n            addr3: None,\n            city: None,\n            state: None,\n            postal_code: None,\n            country: None,\n            phone: vec![],\n            email: vec![],\n            fax: vec![],\n            www: vec![],\n        };\n\n        let mut line = Line::peek(buffer).unwrap();\n        let min_level = line.level;\n\n        // Only iterate through the ADDR records\n        while line.level \u003e= min_level {\n            line = Line::peek(buffer).unwrap();\n\n            let mut consume = true;\n            match line.tag {\n                \"ADDR\" =\u003e {\n                    address.addr1 = parse::get_tag_value(buffer).unwrap();\n                    // println!(\"Input after get_tag_value: \\n'{}'\", buffer);\n                    consume = false;\n                }\n                \"ADR1\" =\u003e {\n                    address.addr1 = Some(line.value.to_string());\n                }\n                \"ADR2\" =\u003e {\n                    address.addr2 = Some(line.value.to_string());\n                }\n                \"ADR3\" =\u003e {\n                    address.addr3 = Some(line.value.to_string());\n                }\n                \"CONT\" =\u003e {} // Ignore, it's a special case handled by ADDR\n                \"CONC\" =\u003e {} // Ignore, it's a special case handled by ADDR\n                \"CITY\" =\u003e {\n                    address.city = Some(line.value.to_string());\n                }\n                \"STAE\" =\u003e {\n                    address.state = Some(line.value.to_string());\n                }\n                \"POST\" =\u003e {\n                    address.postal_code = Some(line.value.to_string());\n                }\n                \"CTRY\" =\u003e {\n                    address.country = Some(line.value.to_string());\n                }\n                \"PHON\" =\u003e {\n                    address.phone.push(line.value.to_string());\n                }\n                \"EMAIL\" =\u003e {\n                    address.email.push(line.value.to_string());\n                }\n                \"FAX\" =\u003e {\n                    address.fax.push(line.value.to_string());\n                }\n                \"WWW\" =\u003e {\n                    address.www.push(line.value.to_string());\n                }\n                _ =\u003e {\n                    // We've hit a non-address tag, so break out of the loop\n                    break;\n                }\n            }\n            // println!(\"Buffer before: {}\", buffer.len());\n            if consume {\n                Line::parse(buffer).unwrap();\n            }\n            // println!(\"Buffer after: {}\", buffer.len());\n            // (buffer, _) = Line::parse(buffer).unwrap();\n\n            // Grab the next line, if there is one, or short-circuit the loop\n            line = Line::peek(buffer).unwrap();\n            // (_, line) = Line::peek(buffer).unwrap();\n        }\n        Ok(address)\n    }\n}\n\n/// Parse the Address entity\n///\n/// This could be formatted one of three (valid) ways:\n///\n/// ```\n/// /*\n/// 3 ADDR 1300 West Traverse Parkway\n/// 4 CONT Lehi, UT  84043\n/// 4 CONT USA\n/// */\n/// ```\n///\n/// or:\n///\n/// ```\n/// /*\n/// 3 ADDR 1300 West Traverse Parkway\n/// 4 CONT Lehi, UT  84043\n/// 4 CONC USA\n/// */\n/// ```\n///\n/// or:\n///\n/// ```\n/// /*\n/// 3 ADDR\n/// 4 ADR1 RSAC Software\n/// 4 ADR2 7108 South Pine Cone Street\n/// 4 ADR3 Ste 1\n/// 4 CITY Salt Lake City\n/// 4 STAE UT\n/// 4 POST 84121\n/// 4 CTRY USA\n/// */\n/// ```\n///\n/// Why did I do it this way, vs implementing `parse` on the Address?\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_addr_tag() {\n        let mut data = \"3 ADDR\\n\";\n        let line = Line::parse(\u0026mut data).unwrap();\n\n        // let (str, line) = Line::parse(\u0026data).unwrap();\n\n        assert!(data.len() == 0);\n        assert!(line.level == 3);\n        assert!(line.xref == \"\");\n        assert!(line.tag == \"ADDR\");\n        assert!(line.value == \"\");\n    }\n\n    #[test]\n    fn parse_adr1_tag() {\n        let mut data = \"4 ADR1 RSAC Software\\n\";\n        let line = Line::parse(\u0026mut data).unwrap();\n\n        assert!(data.is_empty());\n        assert!(line.level == 4);\n        assert!(line.xref == \"\");\n        assert!(line.tag == \"ADR1\");\n        assert!(line.value == \"RSAC Software\");\n    }\n\n    #[test]\n    fn parse_full_address() {\n        let data = vec![\n            \"3 ADDR\",\n            \"4 ADR1 RSAC Software\",\n            \"4 ADR2 7108 South Pine Cone Street\",\n            \"4 ADR3 Ste 1\",\n            \"4 CITY Salt Lake City\",\n            \"4 STAE UT\",\n            \"4 POST 84121\",\n            \"4 CTRY USA\",\n            \"3 PHON +1-801-942-7768\",\n            \"3 PHON +1-801-555-1212\",\n            \"3 PHON +1-801-942-1148\",\n            \"3 EMAIL a@@example.com\",\n            \"3 EMAIL b@@example.com\",\n            \"3 EMAIL c@@example.com\",\n            \"3 FAX +1-801-942-7768\",\n            \"3 FAX +1-801-555-1212\",\n            \"3 FAX +1-801-942-1148\",\n            \"3 WWW https://www.example.com\",\n            \"3 WWW https://www.example.org\",\n            \"3 WWW https://www.example.net\",\n        ];\n\n        let input = data.join(\"\\n\");\n        let mut record = input.as_str();\n\n        let addr = Address::parse(\u0026mut record).unwrap();\n\n        assert!(addr.addr1 == Some(\"RSAC Software\".to_string()));\n        assert!(addr.addr2 == Some(\"7108 South Pine Cone Street\".to_string()));\n        assert!(addr.addr3 == Some(\"Ste 1\".to_string()));\n        assert!(addr.city == Some(\"Salt Lake City\".to_string()));\n        assert!(addr.state == Some(\"UT\".to_string()));\n        assert!(addr.postal_code == Some(\"84121\".to_string()));\n        assert!(addr.country == Some(\"USA\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-942-7768\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-555-1212\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.email.contains(\u0026\"a@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"b@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"c@@example.com\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.com\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.org\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.net\".to_string()));\n    }\n\n    #[test]\n    fn parse_full_address2() {\n        let data = vec![\n            \"1 ADDR\",\n            \"2 ADR1 RSAC Software\",\n            \"2 ADR2 7108 South Pine Cone Street\",\n            \"2 ADR3 Ste 1\",\n            \"2 CITY Salt Lake City\",\n            \"2 STAE UT\",\n            \"2 POST 84121\",\n            \"2 CTRY USA\",\n            \"1 PHON +1-801-942-7768\",\n            \"1 PHON +1-801-555-1212\",\n            \"1 PHON +1-801-942-1148\",\n            \"1 EMAIL a@@example.com\",\n            \"1 EMAIL b@@example.com\",\n            \"1 EMAIL c@@example.com\",\n            \"1 FAX +1-801-942-7768\",\n            \"1 FAX +1-801-555-1212\",\n            \"1 FAX +1-801-942-1148\",\n            \"1 WWW https://www.example.com\",\n            \"1 WWW https://www.example.org\",\n            \"1 WWW https://www.example.net\",\n        ]\n        .join(\"\\n\");\n\n        let mut record = data.as_str();\n        let addr = Address::parse(\u0026mut record).unwrap();\n\n        // println!(\"addr1: {:?}\", addr.addr1);\n        assert!(addr.addr1 == Some(\"RSAC Software\".to_string()));\n        assert!(addr.addr2 == Some(\"7108 South Pine Cone Street\".to_string()));\n        assert!(addr.addr3 == Some(\"Ste 1\".to_string()));\n        assert!(addr.city == Some(\"Salt Lake City\".to_string()));\n        assert!(addr.state == Some(\"UT\".to_string()));\n        assert!(addr.postal_code == Some(\"84121\".to_string()));\n        assert!(addr.country == Some(\"USA\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-942-7768\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-555-1212\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.email.contains(\u0026\"a@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"b@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"c@@example.com\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.com\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.org\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.net\".to_string()));\n    }\n\n    #[test]\n    /// Test the address block as used by Ancestry\n    fn parse_addr_cont() {\n        let data = vec![\n            \"3 ADDR 1300 West Traverse Parkway\",\n            \"4 CONT Lehi, UT  84043\",\n            \"4 CONT USA\",\n            \"3 PHON +1-801-942-7768\",\n            \"3 PHON +1-801-555-1212\",\n            \"3 PHON +1-801-942-1148\",\n        ]\n        .join(\"\\n\");\n\n        let mut record = data.as_str();\n        let address = Address::parse(\u0026mut record);\n        let addr = address.unwrap();\n\n        assert!(addr.addr1 == Some(\"1300 West Traverse Parkway\\nLehi, UT  84043\\nUSA\".to_string()));\n\n        assert!(addr.phone.contains(\u0026\"+1-801-942-7768\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-555-1212\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-942-1148\".to_string()));\n    }\n\n    #[test]\n    /// Test the address block as used by Ancestry\n    fn parse_addr_conc() {\n        let data = vec![\n            \"3 ADDR 1300 West Traverse Parkway\",\n            \"4 CONT Lehi, UT 84043 \",\n            \"4 CONC USA\",\n        ]\n        .join(\"\\n\");\n\n        let mut record = data.as_str();\n        let address = Address::parse(\u0026mut record);\n        let addr = address.unwrap();\n        assert!(addr.addr1 == Some(\"1300 West Traverse Parkway\\nLehi, UT 84043 USA\".to_string()));\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":219},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":211},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":211},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":211},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":209},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":183},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":170},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":156},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":171},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":153},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":144},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":123},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":75},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":378},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":179},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":199},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":20},"fn_name":null}],"covered":43,"coverable":43},{"path":["/","Users","adam","src","rust-gedcom","src","types","adopted_by.rs"],"content":"use std::str::FromStr;\n\n// ADOPTED_BY_WHICH_PARENT:= {Size=1:4}\n// [ HUSB | WIFE | BOTH ]\n// A code which shows which parent in the associated family record adopted this person.\n// Where:\n// HUSB = The HUSBand in the associated family adopted this person.\n// WIFE = The WIFE in the associated family adopted this person.\n// BOTH = Both HUSBand and WIFE adopted this person.\n\n#[derive(Default, Debug, PartialEq, Clone)]\n/// Which parent in the associated family record adopted this person.\npub enum AdoptedBy {\n    #[default]\n    /// Both HUSBand and WIFE adopted this person.\n    Both,\n    /// The HUSBand in the associated family adopted this person.\n    Husband,\n    // The WIFE in the associated family adopted this person.\n    Wife,\n}\n\nimpl FromStr for AdoptedBy {\n    type Err = ();\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cAdoptedBy, Self::Err\u003e {\n        match input {\n            \"BOTH\" =\u003e Ok(AdoptedBy::Both),\n            \"HUSB\" =\u003e Ok(AdoptedBy::Husband),\n            \"WIFE\" =\u003e Ok(AdoptedBy::Wife),\n            _ =\u003e Err(()),\n        }\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":6},{"path":["/","Users","adam","src","rust-gedcom","src","types","corporation.rs"],"content":"use super::Line;\nuse crate::types::Address;\n\n// +1 SOUR \u003cAPPROVED_SYSTEM_ID\u003e\n//     +2 VERS \u003cVERSION_NUMBER\u003e\n//     +2 NAME \u003cNAME_OF_PRODUCT\u003e\n//     +2 CORP \u003cNAME_OF_BUSINESS\u003e\n//         +3 \u003c\u003cADDRESS_STRUCTURE\u003e\u003e\n//     +2 DATA \u003cNAME_OF_SOURCE_DATA\u003e\n//         +3 DATE \u003cPUBLICATION_DATE\u003e\n//         +3 COPR \u003cCOPYRIGHT_SOURCE_DATA\u003e\n//         +4 [CONT|CONC]\u003cCOPYRIGHT_SOURCE_DATA\u003e\n\n#[derive(Clone, Debug, Default, PartialEq)]\npub struct Corporation {\n    pub name: Option\u003cString\u003e,\n    pub address: Option\u003cAddress\u003e,\n}\n\nimpl Corporation {\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cCorporation\u003e) {\n        let mut corp: Corporation = Corporation {\n            name: None,\n            address: None,\n        };\n\n        let mut line: Line = Line::peek(\u0026mut buffer).unwrap();\n\n        // Verify we have a CORP record\n        // line = Line::peek(\u0026mut buffer).unwrap();\n        if line.level == 2 \u0026\u0026 line.tag == \"CORP\" {\n            line = Line::parse(\u0026mut buffer).unwrap();\n            // (buffer, line) = Line::parse(buffer).unwrap();\n            corp.name = Some(line.value.to_string());\n\n            // Check if the next line contains an address struct\n            line = Line::peek(\u0026mut buffer).unwrap();\n\n            if line.level == 3 \u0026\u0026 line.tag == \"ADDR\" {\n                corp.address = Some(Address::parse(\u0026mut buffer).unwrap());\n            }\n        }\n\n        (buffer, Some(corp))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::types::corporation::Corporation;\n\n    #[test]\n    fn parse_corp() {\n        let data = vec![\n            \"2 CORP RSAC Software\",\n            \"3 ADDR\",\n            \"4 ADR1 RSAC Software\",\n            \"4 ADR2 7108 South Pine Cone Street\",\n            \"4 ADR3 Ste 1\",\n            \"4 CITY Salt Lake City\",\n            \"4 STAE UT\",\n            \"4 POST 84121\",\n            \"4 CTRY USA\",\n            \"3 PHON +1-801-942-7768\",\n            \"3 PHON +1-801-555-1212\",\n            \"3 PHON +1-801-942-1148\",\n            \"3 EMAIL a@@example.com\",\n            \"3 EMAIL b@@example.com\",\n            \"3 EMAIL c@@example.com\",\n            \"3 FAX +1-801-942-7768\",\n            \"3 FAX +1-801-555-1212\",\n            \"3 FAX +1-801-942-1148\",\n            \"3 WWW https://www.example.com\",\n            \"3 WWW https://www.example.org\",\n            \"3 WWW https://www.example.net\",\n        ];\n\n        let (_data, _corp) = Corporation::parse(data.join(\"\\n\").as_str());\n        let corp = _corp.unwrap();\n\n        assert!(Some(\"RSAC Software\".to_string()) == corp.name);\n\n        let addr = corp.address.unwrap();\n\n        assert!(Some(\"RSAC Software\".to_string()) == addr.addr1);\n        assert!(Some(\"7108 South Pine Cone Street\".to_string()) == addr.addr2);\n        assert!(Some(\"Ste 1\".to_string()) == addr.addr3);\n        assert!(Some(\"Salt Lake City\".to_string()) == addr.city);\n        assert!(Some(\"UT\".to_string()) == addr.state);\n        assert!(Some(\"84121\".to_string()) == addr.postal_code);\n        assert!(Some(\"USA\".to_string()) == addr.country);\n        assert!(addr.phone.contains(\u0026\"+1-801-942-7768\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-555-1212\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.email.contains(\u0026\"a@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"b@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"c@@example.com\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.com\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.org\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.net\".to_string()));\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","Users","adam","src","rust-gedcom","src","types","datetime.rs"],"content":"use super::Line;\n// use crate::parse;\n\n// +1 DATE \u003cTRANSMISSION_DATE\u003e\n// +2 TIME \u003cTIME_VALUE\u003e\n#[derive(Debug, Clone, PartialEq)]\npub struct DateTime {\n    pub date: Option\u003cString\u003e,\n    pub time: Option\u003cString\u003e,\n}\n\nimpl DateTime {\n    /// Parse the current line(s) for a date/time\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cDateTime\u003e) {\n        let mut dt = DateTime {\n            date: None,\n            time: None,\n        };\n        let mut line: Line;\n\n        line = Line::peek(\u0026mut buffer).unwrap();\n\n        if line.tag == \"DATE\" {\n            let parent_level = line.level;\n\n            // Consume the line\n            line = Line::parse(\u0026mut buffer).unwrap();\n            dt.date = Some(line.value.to_string());\n\n            // Check to see if we have time as a child of the date record\n            line = Line::peek(\u0026mut buffer).unwrap();\n            if line.level == parent_level + 1 \u0026\u0026 line.tag == \"TIME\" {\n                // Consume the line\n                line = Line::parse(\u0026mut buffer).unwrap();\n                dt.time = Some(line.value.to_string());\n            }\n        }\n\n        (buffer, Some(dt))\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","Users","adam","src","rust-gedcom","src","types","event.rs"],"content":"/// This is a template of a Type\nuse crate::parse;\nuse crate::types::{Address, Line, Object, Place, SourceCitation};\n\nuse winnow::prelude::*;\n\n// The GEDCOM specification of this type\n//\n// EVENT_DETAIL:=\n// n TYPE \u003cEVENT_OR_FACT_CLASSIFICATION\u003e {0:1} p.49\n// n DATE \u003cDATE_VALUE\u003e {0:1} p.47, 46\n// n \u003c\u003cPLACE_STRUCTURE\u003e\u003e {0:1} p.38\n// n \u003c\u003cADDRESS_STRUCTURE\u003e\u003e {0:1} p.31\n// n AGNC \u003cRESPONSIBLE_AGENCY\u003e {0:1} p.60\n// n RELI \u003cRELIGIOUS_AFFILIATION\u003e {0:1} p.60\n// n CAUS \u003cCAUSE_OF_EVENT\u003e {0:1} p.43\n// n RESN \u003cRESTRICTION_NOTICE\u003e {0:1} p.60\n// n \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// n \u003c\u003cSOURCE_CITATION\u003e\u003e {0:M} p.39\n// n \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n\n#[derive(Clone, Debug, Default)]\npub struct EventDetail {\n    pub r#type: Option\u003cString\u003e,\n    pub date: Option\u003cString\u003e,\n    pub place: Option\u003cPlace\u003e,\n    pub address: Option\u003cAddress\u003e,\n    pub agency: Option\u003cString\u003e,\n    pub religion: Option\u003cString\u003e,\n    pub cause: Option\u003cString\u003e,\n    pub restriction_notice: Option\u003cString\u003e,\n    pub note: Option\u003cString\u003e,\n    pub sources: Vec\u003cSourceCitation\u003e,\n    pub media: Vec\u003cObject\u003e,\n}\n\nimpl EventDetail {\n    /// Parse\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cEventDetail\u003e {\n        let mut event = EventDetail {\n            r#type: None,\n            date: None,\n            place: None,\n            address: None,\n            agency: None,\n            religion: None,\n            cause: None,\n            restriction_notice: None,\n            note: None,\n            sources: vec![],\n            media: vec![],\n        };\n\n        // Parse the first line, i.e., \"1 BAPM\",\n        let line = Line::parse(record).unwrap();\n        let level = line.level;\n\n        while !record.is_empty() {\n            let mut parse = true;\n            let line = Line::peek(record).unwrap();\n            if line.level \u003c= level {\n                break;\n            }\n\n            match line.tag {\n                \"ADDR\" =\u003e {\n                    event.address = Some(Address::parse(record).unwrap());\n                    parse = false;\n                }\n                \"AGNC\" =\u003e {\n                    event.agency = Some(line.value.to_string());\n                }\n                \"CAUS\" =\u003e {\n                    event.cause = Some(line.value.to_string());\n                }\n                \"DATE\" =\u003e {\n                    event.date = Some(line.value.to_string());\n                }\n                \"NOTE\" =\u003e {\n                    event.note = parse::get_tag_value(record).unwrap();\n                    parse = false;\n                }\n                \"OBJE\" =\u003e {\n                    let obj = Object {\n                        xref: line.value.to_string(),\n                    };\n                    event.media.push(obj);\n                }\n                \"PLAC\" =\u003e {\n                    event.place = Some(Place::parse(record).unwrap());\n                    parse = false;\n                }\n                \"RELI\" =\u003e {\n                    event.religion = Some(line.value.to_string());\n                }\n                \"SOUR\" =\u003e {\n                    let sc = SourceCitation::parse(record).unwrap();\n                    event.sources.push(sc);\n                    parse = false;\n                }\n                \"TYPE\" =\u003e {\n                    event.r#type = Some(line.value.to_string());\n                }\n                _ =\u003e {}\n            }\n\n            if parse {\n                Line::parse(record).unwrap();\n            }\n        }\n\n        Ok(event)\n    }\n}\n\n// +1 EVEN \u003cEVENT_TYPE_CITED_FROM\u003e\n// +2 ROLE \u003cROLE_IN_EVENT\u003e\n//\n// \"3 EVEN BIRT\",\n// \"4 ROLE CHIL\",\n\n#[derive(Clone, Debug, Default)]\npub struct EventTypeCitedFrom {\n    pub r#type: Option\u003cString\u003e,\n    pub role: Option\u003cString\u003e,\n}\n\nimpl EventTypeCitedFrom {\n    /// Parse\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cEventTypeCitedFrom\u003e {\n        let mut event = EventTypeCitedFrom {\n            r#type: None,\n            role: None,\n        };\n        let level = Line::peek(record).unwrap().level;\n\n        while !record.is_empty() {\n            let mut line = Line::parse(record).unwrap();\n            match line.tag {\n                \"EVEN\" =\u003e {\n                    event.r#type = Some(line.value.to_string());\n                }\n                \"ROLE\" =\u003e {\n                    event.role = Some(line.value.to_string());\n                }\n                _ =\u003e {}\n            }\n\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            line = Line::peek(record).unwrap();\n            if line.level == level {\n                break;\n            }\n        }\n\n        Ok(event)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_event_detail() {\n        let data = vec![\n            \"1 BAPM\",\n            \"2 DATE ABT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 AGE 3m\",\n            \"2 TYPE BAPM\",\n            \"2 ADDR\",\n            \"3 ADR1 Church Name\",\n            \"3 ADR2 Street Address\",\n            \"3 CITY City Name\",\n            \"3 POST zip\",\n            \"3 CTRY Country\",\n            \"2 CAUS Birth\",\n            \"2 AGNC The Church\",\n            \"2 OBJE @M8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample baptism Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A baptism source note.\",\n            \"2 NOTE A baptism event note (the event of baptism (not LDS), performed in infancy or later. See also BAPL and CHR).\",\n            \"1 CHR\",\n            \"2 DATE CAL 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample CHR Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening Source note.\",\n            \"2 NOTE Christening event note (the religious event (not LDS) of baptizing and/or naming a \",\n            \"3 CONC child).\",\n            \"2 FAMC @F3@\",\n        ].join(\"\\n\");\n        let mut record = data.as_str();\n        let detail = EventDetail::parse(\u0026mut record).unwrap();\n\n        assert!(detail.date.is_some());\n        assert!(detail.date.unwrap() == \"ABT 31 DEC 1997\");\n    }\n\n    #[test]\n    fn parse_event_type_cited_from() {\n        let data = vec![\"3 EVEN BIRT\", \"4 ROLE CHIL\"];\n\n        let input = data.join(\"\\n\");\n        let mut record = input.as_str();\n        let event_type = EventTypeCitedFrom::parse(\u0026mut record).unwrap();\n\n        assert!(event_type.r#type.is_some());\n        assert!(event_type.r#type.unwrap() == \"BIRT\");\n\n        assert!(event_type.role.is_some());\n        assert!(event_type.role.unwrap() == \"CHIL\");\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":241},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":199},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":199},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":199},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":209},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":188},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":207},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":146},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":107},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":77},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":307},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":109},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":54,"coverable":55},{"path":["/","Users","adam","src","rust-gedcom","src","types","family.rs"],"content":"use std::str::FromStr;\n\nuse crate::{\n    parse,\n    types::{AdoptedBy, Line, Note, Pedigree},\n};\n\n// use super::pedigree;\n\n// TODO: implement full parsing of the family record\n// TODO: Need to create a trait? to find_by_xref that can be used in these\n// types of structs, to find the type of object in a vec of the types.\n\n// FAM_RECORD:=\n// n @\u003cXREF:FAM\u003e@ FAM {1:1}\n// +1 RESN \u003cRESTRICTION_NOTICE\u003e {0:1) p.60\n// +1 \u003c\u003cFAMILY_EVENT_STRUCTURE\u003e\u003e {0:M} p.32\n// +1 HUSB @\u003cXREF:INDI\u003e@ {0:1} p.25\n// +1 WIFE @\u003cXREF:INDI\u003e@ {0:1} p.25\n// +1 CHIL @\u003cXREF:INDI\u003e@ {0:M} p.25\n// +1 NCHI \u003cCOUNT_OF_CHILDREN\u003e {0:1} p.44\n// +1 SUBM @\u003cXREF:SUBM\u003e@ {0:M} p.28\n// +1 \u003c\u003cLDS_SPOUSE_SEALING\u003e\u003e {0:M} p.36\n// +1 REFN \u003cUSER_REFERENCE_NUMBER\u003e {0:M} p.63, 64\n// 25\n// +2 TYPE \u003cUSER_REFERENCE_TYPE\u003e {0:1} p.64\n// +1 RIN \u003cAUTOMATED_RECORD_ID\u003e {0:1} p.43\n// +1 \u003c\u003cCHANGE_DATE\u003e\u003e {0:1} p.31\n// +1 \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// +1 \u003c\u003cSOURCE_CITATION\u003e\u003e {0:M} p.39\n// +1 \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n\n#[derive(Debug, Clone, PartialEq)]\n/// The Family structure\npub struct Family {\n    pub adopted_by: Option\u003cAdoptedBy\u003e,\n    pub xref: String,\n    pub notes: Vec\u003cNote\u003e,\n    pub pedigree: Option\u003cPedigree\u003e,\n}\n\nimpl Family {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e Family {\n        let mut family = Family {\n            adopted_by: None,\n            xref: \"\".to_string(),\n            notes: vec![],\n            pedigree: None,\n        };\n\n        let line = Line::peek(record).unwrap();\n        let level = line.level;\n        let tag = line.tag;\n\n        // If we're at the top of the record, consume the line\n        if tag == \"FAMC\" || tag == \"FAMS\" {\n            // Capture the xref\n            family.xref = line.value.to_string();\n            Line::parse(record).unwrap();\n        }\n\n        while !record.is_empty() {\n            let mut consume = true;\n            let line = Line::peek(record).unwrap();\n\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            if line.level \u003c= level {\n                break;\n            }\n\n            match line.tag {\n                \"NOTE\" =\u003e {\n                    if let Some(note) = parse::get_tag_value(record).unwrap() {\n                        family.notes.push(Note { note: Some(note) });\n                    }\n                    consume = false;\n                }\n                \"PEDI\" =\u003e {\n                    let pedigree = Pedigree::from_str(line.value).unwrap();\n                    family.pedigree = Some(pedigree);\n                }\n                \"ADOP\" =\u003e {\n                    let adopted_by = AdoptedBy::from_str(line.value).unwrap();\n                    family.adopted_by = Some(adopted_by);\n                }\n                _ =\u003e {}\n            }\n\n            if consume {\n                Line::parse(record).unwrap();\n            }\n        }\n\n        family\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    fn parse_family() {\n        let data = vec![\n            \"1 FAMS @F4@\",\n            \"1 FAMC @F2@\",\n            \"2 NOTE Note about this link to his parents family record.\",\n            \"2 NOTE Another note about this link to his parents family record\",\n            \"1 FAMC @F3@\",\n            \"2 PEDI adopted\",\n            \"2 NOTE Note about the link to his adoptive parents family record.\",\n        ]\n        .join(\"\\n\");\n        let mut record = data.as_str();\n\n        // First family\n        let family = Family::parse(\u0026mut record);\n        assert!(family.xref == \"@F4@\");\n\n        // Second family\n        let family = Family::parse(\u0026mut record);\n        assert!(family.xref == \"@F2@\");\n\n        let notes = family.notes;\n        assert!(\n            notes[0].note.as_ref().unwrap() == \"Note about this link to his parents family record.\"\n        );\n        assert!(\n            notes[1].note.as_ref().unwrap()\n                == \"Another note about this link to his parents family record\"\n        );\n\n        // Third family\n        let family = Family::parse(\u0026mut record);\n        assert!(family.xref == \"@F3@\");\n        assert!(family.pedigree.unwrap() == Pedigree::Adopted);\n\n        let notes = family.notes;\n        assert!(\n            notes[0].note.as_ref().unwrap()\n                == \"Note about the link to his adoptive parents family record.\"\n        );\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":27},"fn_name":null}],"covered":27,"coverable":28},{"path":["/","Users","adam","src","rust-gedcom","src","types","gedc.rs"],"content":"use super::Line;\n// use crate::parse;\n\n#[derive(Debug, Default, PartialEq)]\n// pub enum Form {\n//     LineageLinked,\n//     EventLineageLinked,\n//     Unknown,\n// }\npub struct Form {\n    pub name: Option\u003cString\u003e,\n    pub version: Option\u003cString\u003e,\n}\nimpl Form {\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cForm\u003e) {\n        let mut form = Form {\n            name: None,\n            version: None,\n        };\n\n        let mut line: Line;\n\n        line = Line::peek(\u0026mut buffer).unwrap();\n\n        if line.tag == \"FORM\" {\n            line = Line::parse(\u0026mut buffer).unwrap();\n\n            form.name = Some(line.value.to_string());\n\n            while !buffer.is_empty() {\n                // Peek the next line\n                line = Line::peek(\u0026mut buffer).unwrap();\n                match line.tag {\n                    \"VERS\" =\u003e {\n                        // consume the line\n                        line = Line::parse(\u0026mut buffer).unwrap();\n                        form.version = Some(line.value.to_string());\n                    }\n                    _ =\u003e {\n                        // panic!(\"Unknown tag: {}\", line.tag);\n                        break;\n                    }\n                }\n            }\n        }\n\n        (buffer, Some(form))\n    }\n}\n\n#[derive(Debug, Default, PartialEq)]\npub struct Gedc {\n    /// The version of this Gedcom file.\n    pub version: Option\u003cString\u003e,\n\n    /// The GEDCOM form used to construct this transmission.\n    pub form: Option\u003cForm\u003e,\n}\nimpl Gedc {\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cGedc\u003e) {\n        let mut gedc = Gedc {\n            version: None,\n            form: None,\n        };\n        let mut line: Line;\n\n        line = Line::peek(\u0026mut buffer).unwrap();\n\n        if line.tag == \"GEDC\" {\n            Line::parse(\u0026mut buffer).unwrap();\n\n            while !buffer.is_empty() {\n                // Peek the next line\n                line = Line::peek(\u0026mut buffer).unwrap();\n                match line.tag {\n                    \"FORM\" =\u003e {\n                        (buffer, gedc.form) = Form::parse(buffer);\n                    }\n                    \"VERS\" =\u003e {\n                        // consume the line\n                        line = Line::parse(\u0026mut buffer).unwrap();\n                        gedc.version = Some(line.value.to_string());\n                    }\n                    _ =\u003e {\n                        // panic!(\"Unknown tag: {}\", line.tag);\n                        break;\n                    }\n                }\n            }\n        }\n\n        (buffer, Some(gedc))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Gedc;\n\n    #[test]\n    fn parse() {\n        let data = vec![\n            \"1 GEDC\",\n            \"2 VERS 5.5.5\",\n            \"2 FORM LINEAGE-LINKED\",\n            \"3 VERS 5.5.5\",\n        ];\n\n        let (_data, _gedc) = Gedc::parse(\u0026data.join(\"\\n\"));\n        let gedc = _gedc.unwrap();\n        let form = gedc.form.unwrap();\n\n        assert!(gedc.version == Some(\"5.5.5\".to_string()));\n\n        assert!(form.name == Some(\"LINEAGE-LINKED\".to_string()));\n        assert!(form.version == Some(\"5.5.5\".to_string()));\n\n        // // verify that the entire buffer has been consumed\n        // assert!(_data.is_empty())\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":29,"coverable":29},{"path":["/","Users","adam","src","rust-gedcom","src","types","header.rs"],"content":"use crate::parse;\n// use crate::types::corporation;\n// use crate::types::Copyright;\n// use crate::types::Note;\nuse crate::types::{Source, Submitter};\n\nuse super::DateTime;\nuse super::Gedc;\nuse super::Line;\n\n/*\nHEADER:= n HEAD\n+1 SOUR \u003cAPPROVED_SYSTEM_ID\u003e\n    +2 VERS \u003cVERSION_NUMBER\u003e\n    +2 NAME \u003cNAME_OF_PRODUCT\u003e\n    +2 CORP \u003cNAME_OF_BUSINESS\u003e\n        +3 \u003c\u003cADDRESS_STRUCTURE\u003e\u003e\n    +2 DATA \u003cNAME_OF_SOURCE_DATA\u003e\n        +3 DATE \u003cPUBLICATION_DATE\u003e\n        +3 COPR \u003cCOPYRIGHT_SOURCE_DATA\u003e\n        +4 [CONT|CONC]\u003cCOPYRIGHT_SOURCE_DATA\u003e\n+1 DEST \u003cRECEIVING_SYSTEM_NAME\u003e\n+1 DATE \u003cTRANSMISSION_DATE\u003e\n    +2 TIME \u003cTIME_VALUE\u003e\n+1 SUBM @\u003cXREF:SUBM\u003e@\n+1 SUBN @\u003cXREF:SUBN\u003e@\n+1 FILE \u003cFILE_NAME\u003e\n+1 COPR \u003cCOPYRIGHT_GEDCOM_FILE\u003e +1 GEDC\n    +2 VERS \u003cVERSION_NUMBER\u003e\n    +2 FORM \u003cGEDCOM_FORM\u003e +1 CHAR \u003cCHARACTER_SET\u003e\n    +2 VERS \u003cVERSION_NUMBER\u003e +1 LANG \u003cLANGUAGE_OF_TEXT\u003e +1 PLAC\n    +2 FORM \u003cPLACE_HIERARCHY\u003e\n+1 NOTE \u003cGEDCOM_CONTENT_DESCRIPTION\u003e\n    +2 [CONC|CONT] \u003cGEDCOM_CONTENT_DESCRIPTION\u003e\n*/\n\n#[derive(Debug, Default)]\n#[cfg_attr(feature = \"json\", derive(Serialize, Deserialize))]\npub struct Header {\n    pub encoding: Option\u003cString\u003e,\n    pub copyright: Option\u003cString\u003e,\n    pub date: Option\u003cDateTime\u003e,\n    pub destination: Option\u003cString\u003e,\n    pub gedcom_version: Option\u003cGedc\u003e,\n    pub language: Option\u003cString\u003e,\n    pub filename: Option\u003cString\u003e,\n    pub note: Option\u003cString\u003e,\n    pub source: Option\u003cSource\u003e,\n    pub submitter: Option\u003cSubmitter\u003e,\n    pub submission: Option\u003cString\u003e,\n}\n\nimpl Header {\n    pub fn parse(mut record: String) -\u003e Header {\n        let mut header = Header {\n            encoding: None,\n            copyright: None,\n            // corporation: None,\n            date: None,\n            destination: None,\n            gedcom_version: None,\n            language: None,\n            filename: None,\n            note: None,\n            source: None,\n            submitter: None,\n            submission: None,\n        };\n\n        // do parser stuff here\n        while !record.is_empty() {\n            let mut buffer: \u0026str = record.as_str();\n            let line = Line::peek(\u0026mut buffer).unwrap();\n\n            // Inspect the top-level tags only.\n            if line.level == 0 \u0026\u0026 line.tag == \"HEAD\" {\n                // Consume the line\n                // println!(\"Consuming HEAD\");\n                // (buffer, _) = Line::parse(\u0026record).unwrap();\n                Line::parse(\u0026mut buffer).unwrap();\n            } else if line.level == 1 {\n                // println!(\"Found an inner tag: {}\", line.tag);\n                match line.tag {\n                    \"CHAR\" =\u003e {\n                        header.encoding = Some(line.value.to_string());\n                        // (buffer, _) = Line::parse(\u0026record).unwrap();\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"COPR\" =\u003e {\n                        // println!(\"Input before copyright: '{}'\", buffer);\n                        header.copyright = parse::get_tag_value(\u0026mut buffer).unwrap();\n                        // println!(\"Input after copyright: '{}'\", buffer);\n                        // (buffer, header.copyright) = parse::get_tag_value(\u0026record).unwrap();\n\n                        // header.copyright = Some(line.value.unwrap_or(\"\").to_string());\n                        // (buffer, _) = Line::parse(\u0026record).unwrap();\n                        // (buffer, header.copyright) = Copyright::parse(\u0026record);\n                    }\n                    // \"CORP\" =\u003e {\n                    //     println!(\"parsing CORP\");\n                    //     (buffer, header.corporation) = corporation::Corporation::parse(\u0026record);\n                    // }\n                    \"DATE\" =\u003e {\n                        // We're doing lazy parsing of the date, because parsing\n                        // date strings is hard. For now.\n                        (buffer, header.date) = DateTime::parse(\u0026record);\n                    }\n                    \"DEST\" =\u003e {\n                        header.destination = Some(line.value.to_string());\n                        // (buffer, _) = Line::parse(\u0026record).unwrap();\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"FILE\" =\u003e {\n                        header.filename = Some(line.value.to_string());\n                        // (buffer, _) = Line::parse(\u0026record).unwrap();\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"GEDC\" =\u003e {\n                        (buffer, header.gedcom_version) = Gedc::parse(\u0026record);\n                    }\n                    \"LANG\" =\u003e {\n                        header.language = Some(line.value.to_string());\n                        // (buffer, _) = Line::parse(\u0026record).unwrap();\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"NOTE\" =\u003e {\n                        // This is just parsing the value of a line, and any\n                        // CONC/CONT that follows. Rewrite\n                        header.note = parse::get_tag_value(\u0026mut buffer).unwrap();\n                        // (buffer, header.note) = parse::get_tag_value(\u0026record).unwrap();\n                        // let note: Option\u003cNote\u003e;\n                        // (buffer, note) = Note::parse(\u0026record);\n                        // header.note = note;\n                    }\n                    \"SOUR\" =\u003e {\n                        (buffer, header.source) = Source::parse(\u0026record);\n                    }\n                    \"SUBM\" =\u003e {\n                        (buffer, header.submitter) = Submitter::parse(\u0026record);\n                    }\n                    _ =\u003e {\n                        // println!(\"Unhandled header tag: {}\", line.tag);\n                        // (buffer, _) = Line::parse(\u0026record).unwrap();\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                };\n            } else {\n                // (buffer, _) = Line::parse(\u0026record).unwrap();\n                Line::parse(\u0026mut buffer).unwrap();\n            }\n\n            record = buffer.to_string();\n        }\n        header\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::types::{corporation::Corporation, Address, DateTime, Form};\n\n    use super::Header;\n\n    #[test]\n    fn parse_header() {\n        let data = vec![\n            \"0 HEAD\",\n            \"1 CHAR UTF-8\",\n            \"1 SOUR Ancestry.com Family Trees\",\n            \"2 DATA Name of source data\",\n            \"3 DATE 1 JAN 1998\",\n            \"3 COPR Copyright of source data\",\n            \"2 VERS (2010.3)\",\n            \"2 NAME Ancestry.com Family Trees\",\n            \"2 CORP Ancestry.com\",\n            \"3 ADDR\",\n            \"4 ADR1 Example Software\",\n            \"4 ADR2 123 Main Street\",\n            \"4 ADR3 Ste 1\",\n            \"4 CITY Anytown\",\n            \"4 STAE IL\",\n            \"4 POST 55555\",\n            \"4 CTRY USA\",\n            \"3 PHON +1-800-555-1111\",\n            \"3 PHON +1-800-555-1212\",\n            \"3 PHON +1-800-555-1313\",\n            \"3 EMAIL a@example.com\",\n            \"3 EMAIL b@example.com\",\n            \"3 EMAIL c@example.com\",\n            \"3 FAX +1-800-555-1414\",\n            \"3 FAX +1-800-555-1515\",\n            \"3 FAX +1-800-555-1616\",\n            \"3 WWW https://www.example.com\",\n            \"3 WWW https://www.example.org\",\n            \"3 WWW https://www.example.net\",\n            \"1 SUBM @U1@\",\n            \"1 GEDC\",\n            \"2 VERS 5.5\",\n            \"2 FORM LINEAGE-LINKED\",\n            \"3 VERS 5.5\",\n            \"1 COPR A copyright statement\",\n            \"1 LANG English\",\n            \"1 DATE 1 JAN 2023\",\n            \"2 TIME 12:13:14.15\",\n            // The submitter record\n            \"0 @U1@ SUBM\",\n            \"1 NAME Adam Israel\",\n            \"1 ADDR\",\n            \"2 ADR1 Example Software\",\n            \"2 ADR2 123 Main Street\",\n            \"2 ADR3 Ste 1\",\n            \"2 CITY Anytown\",\n            \"2 STAE IL \",\n            \"2 POST 55555\",\n            \"2 CTRY USA\",\n            \"1 PHON +1-800-555-1111\",\n            \"1 PHON +1-800-555-1212\",\n            \"1 PHON +1-800-555-1313\",\n            \"1 EMAIL a@@example.com\",\n            \"1 EMAIL b@@example.com\",\n            \"1 EMAIL c@@example.com\",\n            \"1 FAX +1-800-555-1414\",\n            \"1 FAX +1-800-555-1515\",\n            \"1 FAX +1-800-555-1616\",\n            \"1 WWW https://www.example.com\",\n            \"1 WWW https://www.example.org\",\n            \"1 WWW https://www.example.net\",\n            \"1 OBJE @M1@\",\n            \"1 RIN 1\",\n            \"1 CHAN\",\n            \"2 DATE 7 SEP 2000\",\n            \"3 TIME 8:35:36\",\n        ];\n\n        let header = Header::parse(data.join(\"\\n\"));\n\n        // encoding\n        assert!(header.encoding.is_some());\n        assert!(header.encoding == Some(\"UTF-8\".to_string()));\n\n        // copyright\n        assert!(header.copyright.is_some());\n        assert!(header.copyright == Some(\"A copyright statement\".to_string()));\n\n        // source\n        assert!(header.source.is_some());\n        assert!(header.source.as_ref().unwrap().source == \"Ancestry.com Family Trees\".to_string());\n        assert!(header.source.as_ref().unwrap().version == Some(\"(2010.3)\".to_string()));\n\n        assert!(\n            header\n                .source\n                .as_ref()\n                .unwrap()\n                .data\n                .as_ref()\n                .unwrap()\n                .copyright\n                == Some(\"Copyright of source data\".to_string())\n        );\n        assert!(\n            header.source.as_ref().unwrap().data.as_ref().unwrap().date\n                == Some(DateTime {\n                    date: Some(\"1 JAN 1998\".to_string()),\n                    time: None,\n                })\n        );\n        assert!(\n            header.source.as_ref().unwrap().data.as_ref().unwrap().name\n                == Some(\"Name of source data\".to_string())\n        );\n\n        assert!(\n            header.source.as_ref().unwrap().name == Some(\"Ancestry.com Family Trees\".to_string())\n        );\n        assert!(\n            header.source.as_ref().unwrap().corporation\n                == Some(Corporation {\n                    name: Some(\"Ancestry.com\".to_string()),\n                    address: Some(Address {\n                        addr1: Some(\"Example Software\".to_string()),\n                        addr2: Some(\"123 Main Street\".to_string()),\n                        addr3: Some(\"Ste 1\".to_string()),\n                        city: Some(\"Anytown\".to_string()),\n                        state: Some(\"IL\".to_string()),\n                        postal_code: Some(\"55555\".to_string()),\n                        country: Some(\"USA\".to_string()),\n                        phone: vec![\n                            \"+1-800-555-1111\".to_string(),\n                            \"+1-800-555-1212\".to_string(),\n                            \"+1-800-555-1313\".to_string(),\n                        ],\n                        email: vec![\n                            \"a@example.com\".to_string(),\n                            \"b@example.com\".to_string(),\n                            \"c@example.com\".to_string(),\n                        ],\n                        fax: vec![\n                            \"+1-800-555-1414\".to_string(),\n                            \"+1-800-555-1515\".to_string(),\n                            \"+1-800-555-1616\".to_string(),\n                        ],\n                        www: vec![\n                            \"https://www.example.com\".to_string(),\n                            \"https://www.example.org\".to_string(),\n                            \"https://www.example.net\".to_string(),\n                        ],\n                    })\n                })\n        );\n\n        // Version\n        assert!(\n            header.gedcom_version.as_ref().unwrap().form\n                == Some(Form {\n                    name: Some(\"LINEAGE-LINKED\".to_string()),\n                    version: Some(\"5.5\".to_string()),\n                })\n        );\n        assert!(header.gedcom_version.as_ref().unwrap().version == Some(\"5.5\".to_string()));\n\n        // language\n        assert!(header.language.is_some());\n        assert!(header.language == Some(\"English\".to_string()));\n\n        // datetime\n        assert!(header.date.is_some());\n        assert!(\n            header.date\n                == Some(DateTime {\n                    date: Some(\"1 JAN 2023\".to_string()),\n                    time: Some(\"12:13:14.15\".to_string())\n                })\n        );\n\n        // submitter\n        assert!(header.submitter.is_some());\n    }\n}\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":37,"coverable":37},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","adoption.rs"],"content":"use crate::types::{Family, Line};\n\nuse winnow::prelude::*;\n\nuse super::IndividualEventDetail;\n\n// n ADOP {1:1}\n// +1 \u003c\u003cINDIVIDUAL_EVENT_DETAIL\u003e\u003e {0:1}* p.34\n// +1 FAMC @\u003cXREF:FAM\u003e@ {0:1} p.24\n//    +2 ADOP \u003cADOPTED_BY_WHICH_PARENT\u003e {0:1} p.42\n\n#[derive(Clone, Debug, Default)]\npub struct Adoption {\n    pub event: IndividualEventDetail,\n    pub family: Option\u003cFamily\u003e,\n}\n\nimpl Adoption {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cAdoption\u003e {\n        let mut adoption = Adoption {\n            event: IndividualEventDetail::new(),\n            family: None,\n        };\n\n        let line = Line::parse(record).unwrap();\n        let level = line.level;\n        let mut events: Vec\u003cString\u003e = vec![];\n\n        // Add the first line so EventDetails will parse cleanly\n        events.push(line.to_string());\n\n        while !record.is_empty() {\n            let line = Line::peek(record).unwrap();\n            if line.level \u003c= level {\n                break;\n            }\n            let mut consume = true;\n            match line.tag {\n                \"FAMC\" =\u003e {\n                    let famc = Family::parse(record);\n                    adoption.family = Some(famc);\n                    consume = false;\n                }\n                _ =\u003e {\n                    // This works right now, in this use-case, but what if a struct\n                    // composites more than one structure?\n\n                    // add the line to events, so we can parse them all at once\n                    // as part of the Event Detail\n                    events.push(line.to_string());\n                }\n            }\n            // line = Line::parse(record).unwrap();\n            if consume {\n                Line::parse(record).unwrap();\n            }\n        }\n\n        // Now parse the events\n        if !events.is_empty() {\n            // Remove the last line; it belongs to the next record\n            // println!(\"DELETE: {:?}\", events.pop());\n            let event = events.join(\"\\n\");\n            let mut event_str = event.as_str();\n            // println!(\"parsing --\\n{}\", event_str);\n            adoption.event = IndividualEventDetail::parse(\u0026mut event_str).unwrap();\n        }\n\n        Ok(adoption)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    fn parse_adoption() {\n        let data = vec![\n            \"1 BIRT\",\n            \"2 TYPE Normal\",\n            \"2 DATE 31 DEC 1965\",\n            \"2 PLAC Salt Lake City, UT, USA\",\n            \"3 FONE Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 ROMN Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 MAP\",\n            \"4 LATI N0\",\n            \"4 LONG E0\",\n            \"3 NOTE Some place notes.\",\n            \"2 ADDR\",\n            \"3 ADR1 St. Marks Hospital\",\n            \"3 CITY Salt Lake City\",\n            \"3 STAE UT\",\n            \"3 POST 84121\",\n            \"3 CTRY USA\",\n            \"2 AGNC none\",\n            \"2 RELI Religion\",\n            \"2 CAUS Conception\",\n            \"2 NOTE Some notes.\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE Some notes about this adoption source citation which are embedded in the citation \",\n            \"4 CONC structure itself.\",\n            \"3 QUAY 2\",\n            \"2 OBJE @M15@\",\n            \"2 AGE 0y\",\n            \"2 FAMC @F2@\",\n        ].join(\"\\n\");\n\n        let mut record = data.as_str();\n        let adoption = Adoption::parse(\u0026mut record).unwrap();\n\n        let mut event = adoption.event;\n        assert!(event.detail.date.is_some());\n        assert!(event.detail.r#type.is_some());\n\n        let place = event.detail.place.unwrap();\n        assert!(place.name.is_some());\n        assert!(place.note.is_some());\n        assert!(place.note.unwrap().note.unwrap() == \"Some place notes.\");\n\n        let addr = event.detail.address.unwrap();\n        assert!(addr.addr1.is_some());\n        assert!(addr.city.is_some());\n        assert!(addr.state.is_some());\n\n        assert!(event.detail.agency.is_some());\n        assert!(event.detail.agency.unwrap() == \"none\");\n\n        assert!(event.detail.religion.is_some());\n        assert!(event.detail.religion.unwrap() == \"Religion\");\n\n        assert!(event.detail.cause.is_some());\n        assert!(event.detail.cause.unwrap() == \"Conception\");\n\n        // assert!(adoption.event_type_cited_from.is_some());\n        // let event_type = adoption.event_type_cited_from.unwrap();\n        // assert!(event_type.r#type.unwrap() == \"BIRT\");\n        // assert!(event_type.role.unwrap() == \"CHIL\");\n\n        assert!(event.detail.note.is_some());\n        assert!(event.detail.note.unwrap() == \"Some notes.\");\n\n        // assert!(place.name.unwrap() == \"\");\n\n        assert!(event.detail.media.len() == 1);\n        let obje = event.detail.media.pop().unwrap();\n        assert!(obje.xref == \"@M15@\");\n\n        assert!(event.age.unwrap() == \"0y\");\n\n        assert!(adoption.family.unwrap().xref == \"@F2@\");\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":65},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":123},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":25,"coverable":25},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","birth.rs"],"content":"use crate::types::{Family, Line};\n\nuse winnow::prelude::*;\n\nuse super::IndividualEventDetail;\n\n// n [ BIRT | CHR ] [Y|\u003cNULL\u003e] {1:1}\n// +1 \u003c\u003cINDIVIDUAL_EVENT_DETAIL\u003e\u003e {0:1}* p.34\n// +1 FAMC @\u003cXREF:FAM\u003e@\n\n// EVENT_DETAIL:=\n// n TYPE \u003cEVENT_OR_FACT_CLASSIFICATION\u003e {0:1} p.49\n// n DATE \u003cDATE_VALUE\u003e {0:1} p.47, 46\n// n \u003c\u003cPLACE_STRUCTURE\u003e\u003e {0:1} p.38\n// n \u003c\u003cADDRESS_STRUCTURE\u003e\u003e {0:1} p.31\n// n AGNC \u003cRESPONSIBLE_AGENCY\u003e {0:1} p.60\n// n RELI \u003cRELIGIOUS_AFFILIATION\u003e {0:1} p.60\n// n CAUS \u003cCAUSE_OF_EVENT\u003e {0:1} p.43\n// n RESN \u003cRESTRICTION_NOTICE\u003e {0:1} p.60\n// n \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// n \u003c\u003cSOURCE_CITATION\u003e\u003e {0:M} p.39\n// n \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n// FAMILY\n\n#[derive(Clone, Debug, Default)]\npub struct Birth {\n    pub event: IndividualEventDetail,\n    // pub event_type_cited_from: Option\u003cEventTypeCitedFrom\u003e,\n    pub family: Option\u003cFamily\u003e,\n    pub preferred: bool,\n}\n\nimpl Birth {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cBirth\u003e {\n        let mut birth = Birth {\n            event: IndividualEventDetail::new(),\n            // event_type_cited_from: None,\n            family: None,\n            preferred: false,\n        };\n\n        let line = Line::parse(record).unwrap();\n        let level = line.level;\n        let mut events: Vec\u003cString\u003e = vec![];\n\n        // Add the first line so EventDetails will parse cleanly\n        events.push(line.to_string());\n\n        while !record.is_empty() {\n            let line = Line::peek(record).unwrap();\n            if line.level \u003c= level {\n                break;\n            }\n\n            match line.tag {\n                // \"AGE\" =\u003e {\n                //     birth.age = Some(line.value.to_string());\n                // }\n                \"FAMC\" =\u003e {\n                    let famc = Family {\n                        adopted_by: None,\n                        xref: line.value.to_string(),\n                        notes: vec![],\n                        pedigree: None,\n                    };\n                    birth.family = Some(famc);\n                }\n                _ =\u003e {\n                    // This works right now, in this use-case, but what if a struct\n                    // composites more than one structure?\n\n                    // add the line to events, so we can parse them all at once\n                    // as part of the Event Detail\n                    events.push(line.to_string());\n                }\n            }\n            // line = Line::parse(record).unwrap();\n\n            Line::parse(record).unwrap();\n        }\n\n        // Now parse the events\n        if !events.is_empty() {\n            // Remove the last line; it belongs to the next record\n            // println!(\"DELETE: {:?}\", events.pop());\n            let event = events.join(\"\\n\");\n            let mut event_str = event.as_str();\n            // println!(\"parsing --\\n{}\", event_str);\n            birth.event = IndividualEventDetail::parse(\u0026mut event_str).unwrap();\n        }\n\n        Ok(birth)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    fn parse_birth() {\n        let data = vec![\n            \"1 BIRT\",\n            \"2 TYPE Normal\",\n            \"2 DATE 31 DEC 1965\",\n            \"2 PLAC Salt Lake City, UT, USA\",\n            \"3 FONE Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 ROMN Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 MAP\",\n            \"4 LATI N0\",\n            \"4 LONG E0\",\n            \"3 NOTE Some place notes.\",\n            \"2 ADDR\",\n            \"3 ADR1 St. Marks Hospital\",\n            \"3 CITY Salt Lake City\",\n            \"3 STAE UT\",\n            \"3 POST 84121\",\n            \"3 CTRY USA\",\n            \"2 AGNC none\",\n            \"2 RELI Religion\",\n            \"2 CAUS Conception\",\n            \"2 NOTE Some notes.\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE Some notes about this birth source citation which are embedded in the citation \",\n            \"4 CONC structure itself.\",\n            \"3 QUAY 2\",\n            \"2 OBJE @M15@\",\n            \"2 AGE 0y\",\n            \"2 FAMC @F2@\",\n        ].join(\"\\n\");\n\n        let mut record = data.as_str();\n        let birth = Birth::parse(\u0026mut record).unwrap();\n\n        let mut event = birth.event;\n        assert!(event.detail.date.is_some());\n        assert!(event.detail.r#type.is_some());\n\n        let place = event.detail.place.unwrap();\n        assert!(place.name.is_some());\n        assert!(place.note.is_some());\n        assert!(place.note.unwrap().note.unwrap() == \"Some place notes.\");\n\n        let addr = event.detail.address.unwrap();\n        assert!(addr.addr1.is_some());\n        assert!(addr.city.is_some());\n        assert!(addr.state.is_some());\n\n        assert!(event.detail.agency.is_some());\n        assert!(event.detail.agency.unwrap() == \"none\");\n\n        assert!(event.detail.religion.is_some());\n        assert!(event.detail.religion.unwrap() == \"Religion\");\n\n        assert!(event.detail.cause.is_some());\n        assert!(event.detail.cause.unwrap() == \"Conception\");\n\n        // assert!(birth.event_type_cited_from.is_some());\n        // let event_type = birth.event_type_cited_from.unwrap();\n        // assert!(event_type.r#type.unwrap() == \"BIRT\");\n        // assert!(event_type.role.unwrap() == \"CHIL\");\n\n        assert!(event.detail.note.is_some());\n        assert!(event.detail.note.unwrap() == \"Some notes.\");\n\n        // assert!(place.name.unwrap() == \"\");\n\n        assert!(event.detail.media.len() == 1);\n        let obje = event.detail.media.pop().unwrap();\n        assert!(obje.xref == \"@M15@\");\n\n        assert!(event.age.unwrap() == \"0y\");\n\n        assert!(birth.family.unwrap().xref == \"@F2@\");\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":141},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":141},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":130},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":124},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":124},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":15},"fn_name":null}],"covered":23,"coverable":23},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","christening.rs"],"content":"use crate::types::{Family, Line};\n\nuse winnow::prelude::*;\n\nuse super::IndividualEventDetail;\n\n// n [ BIRT | CHR ] [Y|\u003cNULL\u003e] {1:1}\n// +1 \u003c\u003cINDIVIDUAL_EVENT_DETAIL\u003e\u003e {0:1}* p.34\n// +1 FAMC @\u003cXREF:FAM\u003e@\n\n#[derive(Clone, Debug, Default)]\npub struct Christening {\n    pub event: IndividualEventDetail,\n    pub family: Option\u003cFamily\u003e,\n}\n\nimpl Christening {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cChristening\u003e {\n        let mut christening = Christening {\n            event: IndividualEventDetail::new(),\n            family: None,\n        };\n\n        let line = Line::parse(record).unwrap();\n        let level = line.level;\n        let mut events: Vec\u003cString\u003e = vec![];\n\n        // Add the first line so EventDetails will parse cleanly\n        events.push(line.to_string());\n\n        while !record.is_empty() {\n            let line = Line::peek(record).unwrap();\n            if line.level \u003c= level {\n                break;\n            }\n\n            match line.tag {\n                \"FAMC\" =\u003e {\n                    let famc = Family {\n                        adopted_by: None,\n                        xref: line.value.to_string(),\n                        notes: vec![],\n                        pedigree: None,\n                    };\n                    christening.family = Some(famc);\n                }\n                _ =\u003e {\n                    // This works right now, in this use-case, but what if a struct\n                    // composites more than one structure?\n\n                    // add the line to events, so we can parse them all at once\n                    // as part of the Event Detail\n                    events.push(line.to_string());\n                }\n            }\n            // line = Line::parse(record).unwrap();\n\n            Line::parse(record).unwrap();\n        }\n\n        // Now parse the events\n        if !events.is_empty() {\n            // Remove the last line; it belongs to the next record\n            // println!(\"DELETE: {:?}\", events.pop());\n            let event = events.join(\"\\n\");\n            let mut event_str = event.as_str();\n            // println!(\"parsing --\\n{}\", event_str);\n            christening.event = IndividualEventDetail::parse(\u0026mut event_str).unwrap();\n        }\n\n        Ok(christening)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    fn parse_christening() {\n        let data = vec![\n            \"1 BIRT\",\n            \"2 TYPE Normal\",\n            \"2 DATE 31 DEC 1965\",\n            \"2 PLAC Salt Lake City, UT, USA\",\n            \"3 FONE Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 ROMN Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 MAP\",\n            \"4 LATI N0\",\n            \"4 LONG E0\",\n            \"3 NOTE Some place notes.\",\n            \"2 ADDR\",\n            \"3 ADR1 St. Marks Hospital\",\n            \"3 CITY Salt Lake City\",\n            \"3 STAE UT\",\n            \"3 POST 84121\",\n            \"3 CTRY USA\",\n            \"2 AGNC none\",\n            \"2 RELI Religion\",\n            \"2 CAUS Conception\",\n            \"2 NOTE Some notes.\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE Some notes about this christening source citation which are embedded in the citation \",\n            \"4 CONC structure itself.\",\n            \"3 QUAY 2\",\n            \"2 OBJE @M15@\",\n            \"2 AGE 0y\",\n            \"2 FAMC @F2@\",\n        ].join(\"\\n\");\n\n        let mut record = data.as_str();\n        let christening = Christening::parse(\u0026mut record).unwrap();\n\n        let mut event = christening.event;\n        assert!(event.detail.date.is_some());\n        assert!(event.detail.r#type.is_some());\n\n        let place = event.detail.place.unwrap();\n        assert!(place.name.is_some());\n        assert!(place.note.is_some());\n        assert!(place.note.unwrap().note.unwrap() == \"Some place notes.\");\n\n        let addr = event.detail.address.unwrap();\n        assert!(addr.addr1.is_some());\n        assert!(addr.city.is_some());\n        assert!(addr.state.is_some());\n\n        assert!(event.detail.agency.is_some());\n        assert!(event.detail.agency.unwrap() == \"none\");\n\n        assert!(event.detail.religion.is_some());\n        assert!(event.detail.religion.unwrap() == \"Religion\");\n\n        assert!(event.detail.cause.is_some());\n        assert!(event.detail.cause.unwrap() == \"Conception\");\n\n        // assert!(christening.event_type_cited_from.is_some());\n        // let event_type = christening.event_type_cited_from.unwrap();\n        // assert!(event_type.r#type.unwrap() == \"BIRT\");\n        // assert!(event_type.role.unwrap() == \"CHIL\");\n\n        assert!(event.detail.note.is_some());\n        assert!(event.detail.note.unwrap() == \"Some notes.\");\n\n        // assert!(place.name.unwrap() == \"\");\n\n        assert!(event.detail.media.len() == 1);\n        let obje = event.detail.media.pop().unwrap();\n        assert!(obje.xref == \"@M15@\");\n\n        assert!(event.age.unwrap() == \"0y\");\n\n        assert!(christening.family.unwrap().xref == \"@F2@\");\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":119},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":23,"coverable":23},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","death.rs"],"content":"use crate::types::{EventDetail, EventTypeCitedFrom, Family, Line};\n\nuse winnow::prelude::*;\n\n// n [ BIRT | CHR ] [Y|\u003cNULL\u003e] {1:1}\n// +1 \u003c\u003cINDIVIDUAL_EVENT_DETAIL\u003e\u003e {0:1}* p.34\n// +1 FAMC @\u003cXREF:FAM\u003e@\n\n// EVENT_DETAIL:=\n// n TYPE \u003cEVENT_OR_FACT_CLASSIFICATION\u003e {0:1} p.49\n// n DATE \u003cDATE_VALUE\u003e {0:1} p.47, 46\n// n \u003c\u003cPLACE_STRUCTURE\u003e\u003e {0:1} p.38\n// n \u003c\u003cADDRESS_STRUCTURE\u003e\u003e {0:1} p.31\n// n AGNC \u003cRESPONSIBLE_AGENCY\u003e {0:1} p.60\n// n RELI \u003cRELIGIOUS_AFFILIATION\u003e {0:1} p.60\n// n CAUS \u003cCAUSE_OF_EVENT\u003e {0:1} p.43\n// n RESN \u003cRESTRICTION_NOTICE\u003e {0:1} p.60\n// n \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// n \u003c\u003cSOURCE_CITATION\u003e\u003e {0:M} p.39\n// n \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n// FAMILY\n\n#[derive(Debug, Default)]\npub struct Death {\n    pub age: Option\u003cString\u003e,\n    pub event: Option\u003cEventDetail\u003e,\n    pub event_type_cited_from: Option\u003cEventTypeCitedFrom\u003e,\n    pub family: Option\u003cFamily\u003e,\n    pub preferred: bool,\n}\n\nimpl Death {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cDeath\u003e {\n        let mut death = Death {\n            age: None,\n            event: None,\n            event_type_cited_from: None,\n            family: None,\n            preferred: false,\n        };\n\n        let line = Line::parse(record).unwrap();\n        // TODO: This implies a death is known but the date is not.\n        // Is this effective as-is? It'll create an empty death record, so\n        // we have Some() in place, where if there is no death tag we would\n        // have None()\n        // 1 DEAT Y\n        let mut events: Vec\u003cString\u003e = vec![];\n\n        // Add the first line so EventDetails will parse cleanly\n        events.push(line.to_string());\n\n        while !record.is_empty() {\n            let line = Line::peek(record).unwrap();\n            if line.level == 1 {\n                break;\n            }\n            match line.tag {\n                \"AGE\" =\u003e {\n                    death.age = Some(line.value.to_string());\n                }\n                _ =\u003e {\n                    // This works right now, in this use-case, but what if a struct\n                    // composites more than one structure?\n\n                    // add the line to events, so we can parse them all at once\n                    // as part of the Event Detail\n                    events.push(line.to_string());\n                }\n            }\n\n            Line::parse(record).unwrap();\n        }\n\n        // Now parse the events\n        if !events.is_empty() {\n            let event = events.join(\"\\n\");\n            let mut event_str = event.as_str();\n            death.event = Some(EventDetail::parse(\u0026mut event_str).unwrap());\n        }\n\n        Ok(death)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    fn parse_death() {\n        let data = vec![\n            \"1 DEAT\",\n            \"2 DATE ABT 15 JAN 2001\",\n            \"2 PLAC New York, New York, USA\",\n            \"3 NOTE The place structure has more detail than usually used for places\",\n            \"2 AGE 76y\",\n            \"2 TYPE slow\",\n            \"2 ADDR\",\n            \"3 ADR1 at Home\",\n            \"2 CAUS Cancer\",\n            \"2 AGNC none\",\n            \"2 OBJE @M8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some death source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A death source note.\",\n            \"2 NOTE A death event note.\",\n        ]\n        .join(\"\\n\");\n\n        let mut record = data.as_str();\n        let death = Death::parse(\u0026mut record).unwrap();\n\n        let mut event = death.event.unwrap();\n        assert!(event.date.is_some());\n        assert!(event.r#type.is_some());\n\n        let place = event.place.unwrap();\n        assert!(place.name.is_some());\n        assert!(place.note.is_some());\n        assert!(\n            place.note.unwrap().note.unwrap()\n                == \"The place structure has more detail than usually used for places\"\n        );\n\n        let addr = event.address.unwrap();\n        assert!(addr.addr1.is_some());\n        assert!(addr.city.is_none());\n        assert!(addr.state.is_none());\n\n        assert!(event.agency.is_some());\n        assert!(event.agency.unwrap() == \"none\");\n\n        assert!(event.religion.is_none());\n\n        assert!(event.cause.is_some());\n        assert!(event.cause.unwrap() == \"Cancer\");\n\n        assert!(event.note.is_some());\n        assert!(event.note.unwrap() == \"A death event note.\");\n\n        assert!(event.media.len() == 1);\n        let obje = event.media.pop().unwrap();\n        assert!(obje.xref == \"@M8@\");\n\n        assert!(death.age.unwrap() == \"76y\");\n\n        assert!(death.family.is_none());\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":62},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":9},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","event.rs"],"content":"// Individual Event Detail\n// This is specific to Individual-related events such as birth or death,\n// building off of types.EventDetail\n\nuse winnow::prelude::*;\n\nuse crate::types::{EventDetail, Line};\n\n// INDIVIDUAL_EVENT_DETAIL:=\n// n \u003c\u003cEVENT_DETAIL\u003e\u003e {1:1} p.32\n// n AGE \u003cAGE_AT_EVENT\u003e {0:1} p.42\n\n#[derive(Clone, Debug, Default)]\npub struct IndividualEventDetail {\n    pub age: Option\u003cString\u003e,\n    pub detail: EventDetail,\n}\n\nimpl IndividualEventDetail {\n    /// Initialize an empty Individual Event Detail\n    pub fn new() -\u003e IndividualEventDetail {\n        IndividualEventDetail {\n            age: None,\n            detail: EventDetail {\n                r#type: None,\n                date: None,\n                place: None,\n                address: None,\n                agency: None,\n                religion: None,\n                cause: None,\n                restriction_notice: None,\n                note: None,\n                sources: vec![],\n                media: vec![],\n            },\n        }\n    }\n\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cIndividualEventDetail\u003e {\n        let mut event = IndividualEventDetail {\n            age: None,\n            detail: EventDetail {\n                r#type: None,\n                date: None,\n                place: None,\n                address: None,\n                agency: None,\n                religion: None,\n                cause: None,\n                restriction_notice: None,\n                note: None,\n                sources: vec![],\n                media: vec![],\n            },\n        };\n\n        let line = Line::parse(record).unwrap();\n        let level = line.level;\n        // [ ADOP | BIRT | BAPM | BARM | BASM |\n        // BLES | BURI | CENS | CHR | CHRA |\n        // CONF | CREM | DEAT | EMIG | FCOM |\n        // GRAD | IMMI | NATU | ORDN |\n        // RETI | PROB | WILL | EVEN ]\n        // if line.tag == \"BIRT\" || line.tag == \"BAPM\" {\n        //     Line::parse(record).unwrap();\n        // }\n        let mut events: Vec\u003cString\u003e = vec![];\n\n        // Add the first line so EventDetails will parse cleanly\n        events.push(line.to_string());\n\n        while !record.is_empty() {\n            let line = Line::peek(record).unwrap();\n            if line.level \u003c= level {\n                break;\n            }\n\n            match line.tag {\n                \"AGE\" =\u003e {\n                    event.age = Some(line.value.to_string());\n                }\n                _ =\u003e {\n                    // This works right now, in this use-case, but what if a struct\n                    // composites more than one structure?\n\n                    // add the line to events, so we can parse them all at once\n                    // as part of the Event Detail\n                    events.push(line.to_string());\n                }\n            }\n            Line::parse(record).unwrap();\n        }\n\n        // Now parse the events\n        if !events.is_empty() {\n            // Remove the last line; it belongs to the next record\n            // println!(\"DELETE: {:?}\", events.pop());\n            let event_s = events.join(\"\\n\");\n            let mut event_str = event_s.as_str();\n            // println!(\"parsing --\\n{}\", event_str);\n            event.detail = EventDetail::parse(\u0026mut event_str).unwrap();\n        }\n\n        Ok(event)\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":439},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":414},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":414},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":406},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":413},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":399},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":399},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":406},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":33},"fn_name":null}],"covered":23,"coverable":23},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","gender.rs"],"content":"use std::str::FromStr;\n\n#[derive(Default, Debug, PartialEq)]\n/// The Gender of the Individual\npub enum Gender {\n    Male,\n    Female,\n    Nonbinary,\n    #[default]\n    Unknown,\n}\n\nimpl FromStr for Gender {\n    type Err = ();\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cGender, Self::Err\u003e {\n        match input {\n            \"M\" =\u003e Ok(Gender::Male),\n            \"F\" =\u003e Ok(Gender::Female),\n            \"N\" =\u003e Ok(Gender::Nonbinary),\n            \"U\" =\u003e Ok(Gender::Unknown),\n            _ =\u003e Err(()),\n        }\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":7},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","individual.rs"],"content":"// use std::num::ParseIntError;\nuse std::str::FromStr;\n\nuse crate::types::individual::name::*;\nuse crate::types::{Family, Line};\n\nuse super::{Adoption, Birth, Christening, Death, IndividualEventDetail, Residence};\n// use super::SourceCitation;\n\n// n @XREF:INDI@ INDI\n// +1 RESN \u003cRESTRICTION_NOTICE\u003e\n// +1 \u003c\u003cPERSONAL_NAME_STRUCTURE\u003e\u003e\n// +1 SEX \u003cSEX_VALUE\u003e\n// +1 \u003c\u003cINDIVIDUAL_EVENT_STRUCTURE\u003e\u003e\n// +1 \u003c\u003cINDIVIDUAL_ATTRIBUTE_STRUCTURE\u003e\u003e +1 \u003c\u003cLDS_INDIVIDUAL_ORDINANCE\u003e\u003e\n// +1 \u003c\u003cCHILD_TO_FAMILY_LINK\u003e\u003e\n// +1 \u003c\u003cSPOUSE_TO_FAMILY_LINK\u003e\u003e\n// +1 SUBM @\u003cXREF:SUBM\u003e@\n// +1 \u003c\u003cASSOCIATION_STRUCTURE\u003e\u003e\n// +1 ALIA @\u003cXREF:INDI\u003e@\n// +1 ANCI @\u003cXREF:SUBM\u003e@\n// +1 DESI @\u003cXREF:SUBM\u003e@\n// +1 RFN \u003cPERMANENT_RECORD_FILE_NUMBER\u003e +1 AFN \u003cANCESTRAL_FILE_NUMBER\u003e\n// +1 REFN \u003cUSER_REFERENCE_NUMBER\u003e\n// +2 TYPE \u003cUSER_REFERENCE_TYPE\u003e +1 RIN \u003cAUTOMATED_RECORD_ID\u003e\n// +1 \u003c\u003cCHANGE_DATE\u003e\u003e\n// +1 \u003c\u003cNOTE_STRUCTURE\u003e\u003e\n// +1 \u003c\u003cSOURCE_CITATION\u003e\u003e +1 \u003c\u003cMULTIMEDIA_LINK\u003e\u003e\n#[derive(Debug, Default)]\npub struct Individual {\n    pub adoption: Vec\u003cAdoption\u003e,\n\n    pub birth: Vec\u003cBirth\u003e,\n    pub death: Vec\u003cDeath\u003e,\n\n    // Baptism-related fields\n    /// The event of baptism (not LDS), performed in infancy or later.\n    pub baptism: Vec\u003cIndividualEventDetail\u003e,\n    /// The ceremonial event held when a Jewish boy reaches age 13.\n    pub barmitzvah: Vec\u003cIndividualEventDetail\u003e,\n    /// The ceremonial event held when a Jewish girl reaches age 13.\n    pub basmitzvah: Vec\u003cIndividualEventDetail\u003e,\n    /// A religious event of bestowing divine care or intercession. Sometimes given in connection with anaming ceremony.\n    pub blessing: Vec\u003cIndividualEventDetail\u003e,\n\n    pub burial: Vec\u003cIndividualEventDetail\u003e,\n\n    /// The religious event (not LDS) of baptizing and/or naming a child.\n    pub christening: Vec\u003cChristening\u003e,\n\n    /// The religious event (not LDS) of baptizing and/or naming an adult person.\n    pub christening_adult: Vec\u003cChristening\u003e,\n\n    /// The religious event (not LDS) of conferring the gift of the Holy Ghost and, among protestants, full church membership.\n    pub confirmation: Vec\u003cIndividualEventDetail\u003e,\n\n    pub cremation: Vec\u003cIndividualEventDetail\u003e,\n\n    pub emigration: Vec\u003cIndividualEventDetail\u003e,\n\n    /// Generic events not covered by a specific type\n    pub events: Vec\u003cIndividualEventDetail\u003e,\n\n    pub gender: super::Gender,\n\n    pub graduation: Vec\u003cIndividualEventDetail\u003e,\n\n    pub immigration: Vec\u003cIndividualEventDetail\u003e,\n\n    pub residences: Vec\u003cResidence\u003e,\n    pub famc: Vec\u003cFamily\u003e,\n    pub fams: Vec\u003cFamily\u003e,\n\n    pub names: Vec\u003cPersonalName\u003e,\n\n    pub naturalization: Vec\u003cIndividualEventDetail\u003e,\n\n    pub probate: Vec\u003cIndividualEventDetail\u003e,\n\n    pub will: Vec\u003cIndividualEventDetail\u003e,\n\n    /// The XRef pointer associated with this individual\n    pub xref: Option\u003cString\u003e,\n}\n\n// impl\u003c'a\u003e Individual\u003c'a\u003e {\nimpl Individual {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e Individual {\n        // pub fn parse(mut record: String) -\u003e Individual {\n        let mut individual = Individual {\n            // sources: vec![],\n            adoption: vec![],\n            birth: vec![],\n            burial: vec![],\n            death: vec![],\n            baptism: vec![],\n            barmitzvah: vec![],\n            basmitzvah: vec![],\n            blessing: vec![],\n            christening: vec![],\n            christening_adult: vec![],\n            confirmation: vec![],\n            cremation: vec![],\n            emigration: vec![],\n            events: vec![],\n            famc: vec![],\n            fams: vec![],\n            gender: super::Gender::Unknown,\n            graduation: vec![],\n            immigration: vec![],\n            names: vec![],\n\n            naturalization: vec![],\n            probate: vec![],\n            residences: vec![],\n            will: vec![],\n\n            xref: None,\n        };\n\n        while !record.is_empty() {\n            let line = Line::peek(record).unwrap();\n\n            // Flag to track if we should consume the next line in record\n            let mut parse = true;\n\n            match line.level {\n                0 =\u003e {\n                    individual.xref = Some(line.xref.to_string());\n                }\n                1 =\u003e {\n                    // println!(\"TAG: {}\", line.tag);\n                    match line.tag {\n                        \"NAME\" =\u003e {\n                            let pn = PersonalName::parse(record).unwrap();\n                            individual.names.push(pn);\n                            parse = false;\n                        }\n                        \"SEX\" =\u003e {\n                            // individual.gender =\n                            //     super::Gender::from_str(line.value.unwrap_or(\"U\")).unwrap();\n                            individual.gender = super::Gender::from_str(line.value).unwrap();\n                            // println!(\"Next line: {:?}\", Line::peek(record).unwrap());\n                        }\n                        \"BIRT\" =\u003e {\n                            let mut birth = Birth::parse(record).unwrap();\n                            // The first record found is the preferred record\n                            if individual.birth.is_empty() {\n                                birth.preferred = true;\n                            }\n                            individual.birth.push(birth);\n                            parse = false;\n                        }\n                        \"DEAT\" =\u003e {\n                            // TODO: Support 1 DEAT Y\n                            let mut death = Death::parse(record).unwrap();\n                            if individual.death.is_empty() {\n                                death.preferred = true;\n                            }\n                            individual.death.push(death);\n                            parse = false;\n                        }\n                        \"FAMS\" =\u003e {\n                            let fam = Family::parse(record);\n                            individual.fams.push(fam);\n                            parse = false;\n                        }\n                        \"FAMC\" =\u003e {\n                            let fam = Family::parse(record);\n                            individual.famc.push(fam);\n                            parse = false;\n                        }\n                        // baptism\n                        \"BAPM\" =\u003e {\n                            let baptism = IndividualEventDetail::parse(record).unwrap();\n                            individual.baptism.push(baptism);\n                            parse = false;\n                        }\n                        // christening\n                        \"CHR\" =\u003e {\n                            let christening = Christening::parse(record).unwrap();\n                            individual.christening.push(christening);\n                            parse = false;\n                        }\n                        // bar mitzvah\n                        \"BARM\" =\u003e {\n                            let bar = IndividualEventDetail::parse(record).unwrap();\n                            individual.barmitzvah.push(bar);\n                            parse = false;\n                        }\n                        // bas mitzvah\n                        \"BASM\" =\u003e {\n                            let bar = IndividualEventDetail::parse(record).unwrap();\n                            individual.basmitzvah.push(bar);\n                            parse = false;\n                        }\n                        // blessing\n                        \"BLES\" =\u003e {\n                            // TODO: Need to add tests for this\n                            let blessing = IndividualEventDetail::parse(record).unwrap();\n                            individual.blessing.push(blessing);\n                            parse = false;\n                        }\n                        // Adoption\n                        \"ADOP\" =\u003e {\n                            let adoption = Adoption::parse(record).unwrap();\n                            individual.adoption.push(adoption);\n                            parse = false;\n                        }\n                        // Adult Christening\n                        \"CHRA\" =\u003e {\n                            let christening = Christening::parse(record).unwrap();\n                            individual.christening_adult.push(christening);\n                            parse = false;\n                        }\n                        // Confirmation\n                        \"CONF\" =\u003e {\n                            let confirmation = IndividualEventDetail::parse(record).unwrap();\n                            individual.confirmation.push(confirmation);\n                            parse = false;\n                        }\n                        \"FCOM\" =\u003e {}\n                        \"GRAD\" =\u003e {}\n                        \"EMIG\" =\u003e {}\n                        \"IMMI\" =\u003e {}\n                        \"NATU\" =\u003e {}\n                        \"CENS\" =\u003e {}\n                        \"RETI\" =\u003e {}\n                        // probate\n                        \"PROB\" =\u003e {}\n                        \"BURI\" =\u003e {}\n                        \"WILL\" =\u003e {}\n                        \"CREM\" =\u003e {}\n                        // generic event\n                        \"EVEN\" =\u003e {}\n                        // residence\n                        \"RESI\" =\u003e {}\n                        // occupation\n                        \"OCCU\" =\u003e {}\n                        \"EDUC\" =\u003e {}\n                        // physical description\n                        \"DSCR\" =\u003e {}\n                        // religion\n                        \"RELI\" =\u003e {}\n                        // national identification number\n                        \"IDNO\" =\u003e {}\n                        // property/possessions\n                        \"PROP\" =\u003e {}\n                        // cast(e) name?\n                        \"CAST\" =\u003e {}\n                        // number of children\n                        \"NCHI\" =\u003e {}\n                        // number of marriages\n                        \"NMR\" =\u003e {}\n                        // nobility title\n                        \"TITL\" =\u003e {}\n                        // national or tribe origin\n                        \"NATI\" =\u003e {}\n                        \"NOTE\" =\u003e {}\n                        // source records\n                        \"SOUR\" =\u003e {}\n                        // multimedia links\n                        \"OBJE\" =\u003e {}\n                        \"ASSO\" =\u003e {}\n                        \"REFN\" =\u003e {}\n                        \"RIN\" =\u003e {}\n                        \"CHAN\" =\u003e {}\n                        _ =\u003e {\n                            println!(\"Unknown Individual tag: {:?}\", line.tag);\n                        }\n                    }\n                }\n                _ =\u003e {\n                    // println!(\"Skipping line: {:?}\", line);\n                }\n            }\n            // Consume the line\n            if parse {\n                Line::parse(record).unwrap();\n            }\n        }\n\n        individual\n    }\n}\n\n#[derive(Debug)]\n/// The type of the name.\n///\n/// Not sure when/where to use this yet but I wanted to capture it from the spec.\npub enum NameType {\n    Alias,\n    Birth,\n    Immigrant,\n    Maiden,\n    Married,\n    Other,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::types::{AdoptedBy, Quay};\n\n    #[test]\n    fn parse_indi_complete() {\n        let data = vec![\n            \"0 @I1@ INDI\",\n            \"1 NAME Joseph Tag /Torture/\",\n            \"2 TYPE birth\",\n            \"2 NPFX Prof.\",\n            \"2 GIVN Joseph\",\n            \"2 NICK Joe\",\n            \"2 SPFX Le\",\n            \"2 SURN Torture\",\n            \"2 NSFX Jr.\",\n            \"2 NOTE These are notes about the first NAME structure in this record. These notes are \",\n            \"3 CONC embedded in the INDIVIDUAL record itself.\",\n            \"3 CONT \",\n            \"3 CONT This name structure uses all possible tags for a personal name structure.\",\n            \"3 CONT \",\n            \"3 CONT NOTE: many applications are confused by two NAME structures.\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 55\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE @N7@\",\n            \"3 QUAY 0\",\n            \"2 FONE Joseph Tag /Torture/\",\n            \"3 TYPE user defined\",\n            \"3 NPFX Prof.\",\n            \"3 GIVN Joseph\",\n            \"3 NICK Joe\",\n            \"3 SPFX Le\",\n            \"3 SURN Torture\",\n            \"3 NSFX Jr.\",\n            \"3 NOTE Phonetisation\",\n            \"3 SOUR @S1@\",\n            \"4 PAGE 55\",\n            \"4 EVEN BIRT\",\n            \"5 ROLE CHIL\",\n            \"4 DATA\",\n            \"5 DATE 1 JAN 1900\",\n            \"5 TEXT Here is some text from the source specific to this source \",\n            \"6 CONC citation.\",\n            \"6 CONT Here is more text but on a new line.\",\n            \"4 OBJE @M8@\",\n            \"4 NOTE @N7@\",\n            \"4 QUAY 0\",\n            \"2 ROMN Joseph Tag /Torture/\",\n            \"3 TYPE user defined\",\n            \"3 NPFX Prof.\",\n            \"3 GIVN Joseph\",\n            \"3 NICK Joe\",\n            \"3 SPFX Le\",\n            \"3 SURN Torture\",\n            \"3 NSFX Jr.\",\n            \"3 NOTE Romanisation\",\n            \"3 SOUR @S1@\",\n            \"4 PAGE 55\",\n            \"4 EVEN BIRT\",\n            \"5 ROLE CHIL\",\n            \"4 DATA\",\n            \"5 DATE 1 JAN 1900\",\n            \"5 TEXT Here is some text from the source specific to this source \",\n            \"6 CONC citation.\",\n            \"6 CONT Here is more text but on a new line.\",\n            \"4 OBJE @M8@\",\n            \"4 NOTE @N7@\",\n            \"4 QUAY 0\",\n            \"1 NAME William John /Smith/\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"2 NOTE This is a second personal NAME structure in a single INDIVIDUAL record \",\n            \"3 CONC which is allowed in GEDCOM.\",\n            \"3 CONT \",\n            \"3 CONT These notes are embedded in the INDIVIDUAL record.\",\n            \"1 SEX M\",\n            \"1 BIRT\",\n            \"2 TYPE Normal\",\n            \"2 DATE 31 DEC 1965\",\n            \"2 PLAC Salt Lake City, UT, USA\",\n            \"3 FONE Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 ROMN Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 MAP\",\n            \"4 LATI N0\",\n            \"4 LONG E0\",\n            \"3 NOTE Place note\",\n            \"2 ADDR\",\n            \"3 ADR1 St. Marks Hospital\",\n            \"3 CITY Salt Lake City\",\n            \"3 STAE UT\",\n            \"3 POST 84121\",\n            \"3 CTRY USA\",\n            \"2 AGNC none\",\n            \"2 RELI Religion\",\n            \"2 CAUS Conception\",\n            \"2 NOTE @N8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE Some notes about this birth source citation which are embedded in the citation \",\n            \"4 CONC structure itself.\",\n            \"3 QUAY 2\",\n            \"2 OBJE @M15@\",\n            \"2 AGE 0y\",\n            \"2 FAMC @F2@\",\n            \"1 BIRT\",\n            \"2 TYPE Normal\",\n            \"2 DATE ABT. DEC 1965\",\n            \"1 DEAT\",\n            \"2 DATE ABT 15 JAN 2001\",\n            \"2 PLAC New York, New York, USA\",\n            \"3 NOTE The place structure has more detail than usually used for places\",\n            \"2 AGE 76y\",\n            \"2 TYPE slow\",\n            \"2 ADDR\",\n            \"3 ADR1 at Home\",\n            \"2 CAUS Cancer\",\n            \"2 AGNC none\",\n            \"2 OBJE @M8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some death source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A death source note.\",\n            \"2 NOTE A death event note.\",\n            \"1 FAMS @F1@\",\n            \"2 NOTE Note about the link to the family record with his first spouse.\",\n            \"2 NOTE Another note about the link to the family record with his first spouse.\",\n            \"1 FAMS @F4@\",\n            \"1 FAMC @F2@\",\n            \"2 NOTE Note about this link to his parents family record.\",\n            \"2 NOTE Another note about this link to his parents family record\",\n            \"1 FAMC @F3@\",\n            \"2 PEDI adopted\",\n            \"2 NOTE Note about the link to his adoptive parents family record.\",\n            \"1 BAPM\",\n            \"2 DATE ABT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 AGE 3m\",\n            \"2 TYPE BAPM\",\n            \"2 ADDR\",\n            \"3 ADR1 Church Name\",\n            \"3 ADR2 Street Address\",\n            \"3 CITY City Name\",\n            \"3 POST zip\",\n            \"3 CTRY Country\",\n            \"2 CAUS Birth\",\n            \"2 AGNC The Church\",\n            \"2 OBJE @M8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample baptism Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A baptism source note.\",\n            \"2 NOTE A baptism event note (the event of baptism (not LDS), performed in infancy or later. See also BAPL and CHR).\",\n            \"1 CHR\",\n            \"2 DATE CAL 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample CHR Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening Source note.\",\n            \"2 NOTE Christening event note (the religious event (not LDS) of baptizing and/or naming a \",\n            \"3 CONC child).\",\n            \"2 FAMC @F3@\",\n            \"1 CHR\",\n            \"2 DATE EST 30 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some christening source text.\",\n            \"5 CONT This is the second christening structure.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening Source note.\",\n            \"2 NOTE Alternative christening event note. GEDOM allows more than one of the same type \",\n            \"3 CONC of event.\",\n            \"1 BARM\",\n            \"2 DATE AFT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE BARM\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some Bar Mitzvah source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A Bar Mitzvah source note.\",\n            \"2 NOTE Bar Mitzvah event note (the ceremonial event held when a Jewish boy reaches age \",\n            \"3 CONC 13).\",\n            \"1 BASM\",\n            \"2 DATE AFT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE BASM\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some Bas Mitzvah source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A Bas Mitzvah source note.\",\n            \"2 NOTE Bas Mitzvah event note (the ceremonial event held when a Jewish girl reaches age 13, \",\n            \"3 CONC also known as \\\"Bat Mitzvah\\\").\",\n            \"1 ADOP\",\n            \"2 DATE BEF 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE ADOP\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some adoption source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An adoption source note.\",\n            \"2 NOTE Adoption event note (pertaining to creation of a child-parent relationship that does \",\n            \"3 CONC not exist biologically).\",\n            \"2 FAMC @F3@\",\n            \"3 ADOP BOTH\",\n            \"1 CHRA\",\n            \"2 DATE BET 31 DEC 1997 AND 1 FEB 1998\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHRA\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some christening source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening source note.\",\n            \"2 NOTE Adult christening event note (the religious event (not LDS) of baptizing and/or \",\n            \"3 CONC naming an adult person).\",\n            \"1 CONF\",\n            \"2 DATE BET 31 DEC 1997 AND 2 JAN 1998\",\n            \"2 PLAC The place\",\n            \"2 TYPE CONF\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some CONF Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A CONF Source note.\",\n            \"2 NOTE CONFIRMATION event note (the religious event (not LDS) of conferring the gift of the Holy Ghost and, among protestants, full church membership).\",\n            \"1 FCOM\",\n            \"2 DATE INT 31 DEC 1997 (a test)\",\n            \"2 PLAC The place\",\n            \"2 TYPE FCOM\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some first communion source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An first communion source note.\",\n            \"2 NOTE First communion event note (a religious rite, the first act of sharing in the Lord's \",\n            \"3 CONC supper as part of church worship).\",\n            \"1 GRAD\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE GRAD\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some graduation source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A graduation source note.\",\n            \"2 NOTE Graduation event note (an event of awarding educational diplomas or degrees to \",\n            \"3 CONC individuals).\",\n            \"1 EMIG\",\n            \"2 DATE 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE EMIG\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some emigration source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An emigration source note.\",\n            \"2 NOTE Emigration event note (an event of leaving one's homeland with the intent of residing \",\n            \"3 CONC elsewhere).\",\n            \"1 IMMI\",\n            \"2 DATE DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE IMMI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some immigration source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An immigration source note.\",\n            \"2 NOTE Immigration event note (an event of entering into a new locality with the intent of \",\n            \"3 CONC residing there).\",\n            \"1 NATU\",\n            \"2 DATE 1100 BCE\",\n            \"2 PLAC The place\",\n            \"2 TYPE NATU\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some naturalization source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A naturalization source note.\",\n            \"2 NOTE Naturalization event note (the event of obtaining citizenship).\",\n            \"1 CENS\",\n            \"2 DATE @#DHEBREW@ 2 TVT 5758\",\n            \"2 PLAC The place\",\n            \"2 TYPE CENS\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some census source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A census source note.\",\n            \"2 NOTE Census event note (the event of the periodic count of the population for a designated \",\n            \"3 CONC locality, such as a national or state Census).\",\n            \"1 RETI\",\n            \"2 DATE @#DFRENCH R@ 11 NIVO 0006\",\n            \"2 PLAC The place\",\n            \"2 TYPE RETI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some retirement source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A retirement source note.\",\n            \"2 NOTE Retirement event note (an event of exiting an occupational relationship with an \",\n            \"3 CONC employer after a qualifying time period).\",\n            \"1 PROB\",\n            \"2 DATE FROM @#DHEBREW@ 25 SVN 5757 TO @#DHEBREW@ 26 IYR 5757\",\n            \"2 PLAC The place\",\n            \"2 TYPE PROB\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some probate source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A probate source note.\",\n            \"2 NOTE Probate event note (an event of judicial determination of the validity of a will. May \",\n            \"3 CONC indicate several related court activities over several dates).\",\n            \"1 BURI\",\n            \"2 DATE @#DFRENCH R@ 5 VEND 0010\",\n            \"2 PLAC The place\",\n            \"2 TYPE BURI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some burial source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A burial source note.\",\n            \"2 NOTE Burial event note (the event of the proper disposing of the mortal remains of a \",\n            \"3 CONC deceased person).\",\n            \"1 WILL\",\n            \"2 DATE INT @#DHEBREW@ 2 TVT 5758 (interpreted)\",\n            \"2 PLAC The place\",\n            \"2 TYPE WILL\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some will source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A will source note.\",\n            \"2 NOTE Will event note (a legal document treated as an event, by which a person disposes of \",\n            \"3 CONC his or her estate, to take effect after death. The event date is the date the will was \",\n            \"3 CONC signed while the person was alive. See also Probate).\",\n            \"1 CREM\",\n            \"2 DATE AFT 15 JAN 2001\",\n            \"1 EVEN\",\n            \"2 DATE 5 MAY 0005\",\n            \"2 PLAC The place\",\n            \"2 TYPE EVEN\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some generic event source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A generic event source note.\",\n            \"2 NOTE Generic event note (a noteworthy happening related to an individual, a group, or an \",\n            \"3 CONC organization). The TYPE tag specifies the type of event.\",\n            \"1 RESI\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 AGE 35y\",\n            \"2 TYPE RESI\",\n            \"2 ADDR\",\n            \"3 ADR1 Special Address Line 1\",\n            \"3 ADR2 Special Address Line 2\",\n            \"3 ADR3 Special Address Line 3\",\n            \"3 CITY City Name\",\n            \"3 STAE State name\",\n            \"3 POST 0123456789\",\n            \"3 CTRY USA\",\n            \"2 PHON +1-800-555-5555\",\n            \"2 CAUS Needed housing\",\n            \"2 AGNC None\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some residence source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A residence source note.\",\n            \"2 NOTE Residence attribute note (the act of dwelling at an address for a period of time).\",\n            \"1 OCCU Occupation\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 AGE 40y\",\n            \"2 PLAC The place\",\n            \"2 TYPE OCCU\",\n            \"2 ADDR\",\n            \"3 ADR1 Work address line 1\",\n            \"3 ADR2 Work address line 2\",\n            \"3 ADR3 Work address line 3\",\n            \"3 CITY Work city\",\n            \"3 STAE Work state\",\n            \"3 POST Work post\",\n            \"3 CTRY Work country\",\n            \"2 CAUS Need for money\",\n            \"2 AGNC Employer\",\n            \"2 OBJE @M7@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some occupation source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An occupation source note.\",\n            \"2 NOTE Occupation attribute note (the type of work or profession of an individual).\",\n            \"1 OCCU Another occupation\",\n            \"2 DATE 31 DEC 1998\",\n            \"2 PLAC The place\",\n            \"2 TYPE OCCU\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some occupation source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An occupation source note.\",\n            \"2 NOTE Occupation attribute note. This is the second occupation attribute in the record.\",\n            \"1 EDUC Education\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE EDUC\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some education source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An education source note.\",\n            \"2 NOTE Education attribute note (indicator of a level of education attained).\",\n            \"1 DSCR Physical description\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE PHYS\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some physical description source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A physical description source note.\",\n            \"2 NOTE Physical description attribute note (the physical characteristics of a person, place, or \",\n            \"3 CONC thing).\",\n            \"1 RELI Religion\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE RELI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some religion source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A religion source note.\",\n            \"2 NOTE Religion attribute note (a religious denomination to which a person is affiliated or for \",\n            \"3 CONC which a record applies).\",\n            \"1 IDNO 6942\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE IDNO\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some national identification number source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An national identification number source note.\",\n            \"2 NOTE National identification number attribute note (a number assigned to identify a person \",\n            \"3 CONC within some significant external system).\",\n            \"1 PROP Possessions\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE PROP\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some possessions source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE @N11@\",\n            \"2 NOTE Possessions or property attribute note (pertaining to possessions such as real estate \",\n            \"3 CONC or other property of interest).\",\n            \"1 CAST Cast name\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CAST\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some caste name source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A caste name source note.\",\n            \"2 NOTE Caste name attribute note (the name of an individual's rank or status in society, based \",\n            \"3 CONC on racial or religious differences, or differences in wealth, inherited rank, profession, \",\n            \"3 CONC occupation, etc).\",\n            \"1 NCHI 42\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE NCHI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some number of children source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE Am number of children source note.\",\n            \"2 NOTE Number of children attribute note.\",\n            \"1 NMR 42\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE NMR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some number of marriages source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An number of marriages source note.\",\n            \"2 NOTE Number of marriages attribute note.\",\n            \"1 TITL Nobility title\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE TITL\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some title source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A title source note.\",\n            \"2 NOTE Title attribute note (a description of a specific writing or other work, such as the title \",\n            \"3 CONC of a book when used in a source context, or a formal designation used by an \",\n            \"3 CONC individual in connection with positions of royalty or other social status, \",\n            \"3 CONT such as Grand Duke).\",\n            \"1 NATI National or tribe origin\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE NATI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some nationality source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An nationality source note.\",\n            \"2 NOTE Nationality attribute note (the national heritage of an individual).\",\n            \"1 NOTE @N4@\",\n            \"1 NOTE This is a second set of notes for this single individual record. It is embedded in the \",\n            \"2 CONC INDIVIDUAL record instead of being in a separate NOTE record.\",\n            \"2 CONT \",\n            \"2 CONT These notes also have a source citation to a SOURCE record. In GEDCOM \",\n            \"2 CONC this source can only be a single line and links to a SOURCE record.\",\n            \"1 SOUR @S1@\",\n            \"2 PAGE 42\",\n            \"2 DATA\",\n            \"3 DATE 31 DEC 1900\",\n            \"3 TEXT Some sample text from the first source on this record.\",\n            \"2 QUAY 0\",\n            \"2 NOTE A source note.\",\n            \"1 SOUR @S2@\",\n            \"2 NOTE @N12@\",\n            \"1 OBJE @M7@\",\n            \"1 ASSO @I9@\",\n            \"2 RELA Has multimedia links\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample text about this source on an association.\",\n            \"2 NOTE Note on association link.\",\n            \"1 ASSO @I5@\",\n            \"2 RELA Father\",\n            \"1 REFN 01234567890123456789\",\n            \"2 TYPE reference\",\n            \"1 RIN 12\",\n            \"1 CHAN\",\n            \"2 DATE 12 FEB 2001\",\n            \"3 TIME 19:16:42\",\n        ];\n\n        let buffer = data.join(\"\\n\");\n        let mut record = buffer.as_str();\n        let mut indi = Individual::parse(\u0026mut record);\n\n        // println!(\"Names: {}\", indi.names.len());\n\n        assert_eq!(2, indi.names.len());\n        assert_eq!(Some(\"@I1@\".to_string()), indi.xref);\n\n        // Check the name.name\n        assert_eq!(\n            Some(\"Joseph Tag /Torture/\"),\n            indi.names[0].name.value.as_deref()\n        );\n        assert_eq!(Some(\"Joseph\"), indi.names[0].name.given.as_deref());\n        assert_eq!(Some(\"Torture\"), indi.names[0].name.surname.as_deref());\n        assert_eq!(Some(\"Joe\"), indi.names[0].name.nickname.as_deref());\n        assert_eq!(Some(\"Prof.\"), indi.names[0].name.prefix.as_deref());\n        assert_eq!(Some(\"Le\"), indi.names[0].name.suffix.as_deref());\n        assert_eq!(Some(\"Jr.\"), indi.names[0].name.surname_prefix.as_deref());\n        assert_eq!(Some(\"birth\"), indi.names[0].name.r#type.as_deref());\n\n        // Check the indi.names[0].romanized\n        assert_eq!(\n            Some(\"Joseph Tag /Torture/\"),\n            indi.names[0].romanized.value.as_deref()\n        );\n        assert_eq!(Some(\"Joseph\"), indi.names[0].romanized.given.as_deref());\n        assert_eq!(Some(\"Torture\"), indi.names[0].romanized.surname.as_deref());\n        assert_eq!(Some(\"Joe\"), indi.names[0].romanized.nickname.as_deref());\n        assert_eq!(Some(\"Prof.\"), indi.names[0].romanized.prefix.as_deref());\n        assert_eq!(Some(\"Le\"), indi.names[0].romanized.suffix.as_deref());\n        assert_eq!(\n            Some(\"Jr.\"),\n            indi.names[0].romanized.surname_prefix.as_deref()\n        );\n        assert_eq!(\n            Some(\"user defined\"),\n            indi.names[0].romanized.r#type.as_deref()\n        );\n\n        // Check the indi.names[0].phonetic\n        assert_eq!(\n            Some(\"Joseph Tag /Torture/\"),\n            indi.names[0].phonetic.value.as_deref()\n        );\n        assert_eq!(Some(\"Joseph\"), indi.names[0].phonetic.given.as_deref());\n        assert_eq!(Some(\"Torture\"), indi.names[0].phonetic.surname.as_deref());\n        assert_eq!(Some(\"Joe\"), indi.names[0].phonetic.nickname.as_deref());\n        assert_eq!(Some(\"Prof.\"), indi.names[0].phonetic.prefix.as_deref());\n        assert_eq!(Some(\"Le\"), indi.names[0].phonetic.suffix.as_deref());\n        assert_eq!(\n            Some(\"Jr.\"),\n            indi.names[0].phonetic.surname_prefix.as_deref()\n        );\n        assert_eq!(\n            Some(\"user defined\"),\n            indi.names[0].phonetic.r#type.as_deref()\n        );\n\n        // Birth\n        let birth = indi.birth.first().unwrap();\n        assert!(birth.preferred);\n\n        let mut event = birth.event.clone();\n\n        assert!(event.detail.r#type.unwrap() == \"Normal\");\n        assert!(event.detail.date.unwrap() == \"31 DEC 1965\");\n\n        let place = event.detail.place.unwrap();\n        assert!(place.name.unwrap() == \"Salt Lake City, UT, USA\");\n        assert!(place.note.unwrap().note.unwrap() == \"Place note\");\n\n        let place_phonetic = place.phonetic.unwrap();\n        assert!(place_phonetic.name.unwrap() == \"Salt Lake City, UT, USA\");\n        assert!(place_phonetic.r#type.unwrap() == \"user defined\");\n        let place_roman = place.roman.unwrap();\n        assert!(place_roman.name.unwrap() == \"Salt Lake City, UT, USA\");\n        assert!(place_roman.r#type.unwrap() == \"user defined\");\n        let place_map = place.map.unwrap();\n        assert!(place_map.latitude == 0.0);\n        assert!(place_map.longitude == 0.0);\n\n        let addr = event.detail.address.unwrap();\n        assert!(addr.addr1.unwrap() == \"St. Marks Hospital\");\n        assert!(addr.city.unwrap() == \"Salt Lake City\");\n        assert!(addr.state.unwrap() == \"UT\");\n        assert!(addr.postal_code.unwrap() == \"84121\");\n        assert!(addr.country.unwrap() == \"USA\");\n\n        assert!(event.detail.agency.unwrap() == \"none\");\n        assert!(event.detail.religion.unwrap() == \"Religion\");\n        assert!(event.detail.cause.unwrap() == \"Conception\");\n\n        // Good to know: notes can be an xref that refer to a top-level note,\n        // i.e, @N8@ -\u003e '0 NOTE @N8@'.\n        // I need to write some kind of resolver\n        // TODO: Convert to a Note (and add xref to Note)\n        assert!(event.detail.note.unwrap() == \"@N8@\");\n\n        let mut source = event.detail.sources.pop().unwrap();\n        assert!(source.xref.unwrap() == \"@S1@\");\n        assert!(source.page.unwrap() == 42);\n\n        let sdata = source.data.unwrap();\n        assert!(sdata.date.unwrap() == \"1 JAN 1900\");\n        assert!(sdata.text.unwrap().note.unwrap() == \"Here is some text from the source specific to this source citation.\\nHere is more text but on a new line.\");\n\n        let sevent = source.event.unwrap();\n        assert!(sevent.role.unwrap() == \"CHIL\");\n        assert!(sevent.r#type.unwrap() == \"BIRT\");\n\n        assert!(source.media.len() == 1);\n        let media = source.media.pop().unwrap();\n        assert!(media.xref == \"@M8@\");\n\n        assert!(source.note.unwrap().note.unwrap() == \"Some notes about this birth source citation which are embedded in the citation structure itself.\");\n\n        assert!(source.quay.unwrap() == Quay::Secondary);\n\n        let obje = event.detail.media.pop().unwrap();\n        assert!(obje.xref == \"@M15@\");\n\n        assert!(event.age.unwrap() == \"0y\");\n\n        assert!(birth.family.clone().unwrap().xref == \"@F2@\");\n\n        // Death\n        // \"1 DEAT\",\n        let death = indi.death.first().unwrap();\n        assert!(death.preferred);\n\n        let mut devent = death.event.clone().unwrap();\n        // \"2 DATE ABT 15 JAN 2001\",\n        assert!(devent.date.is_some());\n        assert!(devent.date.unwrap() == \"ABT 15 JAN 2001\");\n\n        // \"2 PLAC New York, New York, USA\",\n        // \"3 NOTE The place structure has more detail than usually used for places\",\n        // \"2 AGE 76y\",\n        assert!(death.age.clone().unwrap() == \"76y\");\n        // \"2 TYPE slow\",\n        assert!(devent.r#type.unwrap() == \"slow\");\n\n        // \"2 ADDR\",\n        // \"3 ADR1 at Home\",\n        assert!(devent.address.is_some());\n        let addr = devent.address.unwrap();\n        assert!(addr.addr1.unwrap() == \"at Home\");\n\n        // \"2 CAUS Cancer\",\n        assert!(devent.cause.unwrap() == \"Cancer\");\n\n        // \"2 AGNC none\",\n        assert!(devent.agency.unwrap() == \"none\");\n\n        // \"2 OBJE @M8@\",\n        assert!(devent.media.len() == 1);\n        let obj = devent.media.pop().unwrap();\n        assert!(obj.xref == \"@M8@\".to_string());\n\n        // \"2 SOUR @S1@\",\n        assert!(devent.sources.len() == 1);\n        let source = devent.sources.pop().unwrap();\n        assert!(source.xref.unwrap() == \"@S1@\");\n\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let sdata = source.data.unwrap();\n\n        // \"4 DATE 31 DEC 1900\",\n        assert!(sdata.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Some death source text.\",\n        assert!(sdata.text.unwrap().note.unwrap() == \"Some death source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE A death source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A death source note.\");\n\n        // \"2 NOTE A death event note.\",\n        assert!(devent.note.unwrap() == \"A death event note.\");\n\n        // Family links\n        // FAMS\n        assert!(indi.fams.len() == 2);\n\n        // FAMC\n        assert!(indi.famc.len() == 2);\n\n        // Baptism\n        // \"1 BAPM\",\n        let bapm = indi.baptism.pop().unwrap();\n\n        // \"2 DATE ABT 31 DEC 1997\",\n        assert!(bapm.detail.date.unwrap() == \"ABT 31 DEC 1997\");\n\n        // \"2 PLAC The place\",\n        assert!(bapm.detail.place.unwrap().name.unwrap() == \"The place\");\n\n        // \"2 AGE 3m\",\n        assert!(bapm.age.unwrap() == \"3m\");\n\n        // \"2 TYPE BAPM\",\n        assert!(bapm.detail.r#type.unwrap() == \"BAPM\");\n\n        // \"2 ADDR\",\n        let addr = bapm.detail.address.unwrap();\n\n        // \"3 ADR1 Church Name\",\n        assert!(addr.addr1.unwrap() == \"Church Name\");\n\n        // \"3 ADR2 Street Address\",\n        assert!(addr.addr2.unwrap() == \"Street Address\");\n\n        // \"3 CITY City Name\",\n        assert!(addr.city.unwrap() == \"City Name\");\n\n        // \"3 POST zip\",\n        assert!(addr.postal_code.unwrap() == \"zip\");\n\n        // \"3 CTRY Country\",\n        assert!(addr.country.unwrap() == \"Country\");\n\n        // \"2 CAUS Birth\",\n        assert!(bapm.detail.cause.unwrap() == \"Birth\");\n\n        // \"2 AGNC The Church\",\n        assert!(bapm.detail.agency.unwrap() == \"The Church\");\n\n        // \"2 OBJE @M8@\",\n        let media = bapm.detail.media;\n        assert!(media[0].xref == \"@M8@\".to_string());\n\n        // Sources\n        let mut sources = bapm.detail.sources;\n        let source = sources.pop().unwrap();\n\n        // \"2 SOUR @S1@\",\n        assert!(source.xref.unwrap() == \"@S1@\".to_string());\n\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let sdata = source.data.unwrap();\n\n        // \"4 DATE 31 DEC 1900\",\n        assert!(sdata.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Sample baptism Source text.\",\n        assert!(sdata.text.unwrap().note.unwrap() == \"Sample baptism Source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE A baptism source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A baptism source note.\");\n\n        // \"2 NOTE A baptism event note (the event of baptism (not LDS), performed in infancy or later. See also BAPL and CHR).\",\n        assert!(bapm\n            .detail\n            .note\n            .unwrap()\n            .starts_with(\"A baptism event note\"));\n\n        // Christening\n\n        // \"1 CHR\",\n        let chr = indi.christening.first().unwrap().clone();\n\n        // \"2 DATE CAL 31 DEC 1997\",\n        assert!(chr.event.detail.date.unwrap() == \"CAL 31 DEC 1997\");\n\n        // \"2 PLAC The place\",\n        assert!(chr.event.detail.place.unwrap().name.unwrap() == \"The place\");\n\n        // \"2 TYPE CHR\",\n        assert!(chr.event.detail.r#type.unwrap() == \"CHR\");\n\n        let source = chr.event.detail.sources.first().unwrap().clone();\n\n        // \"2 SOUR @S1@\",\n        assert!(source.xref.unwrap() == \"@S1@\");\n\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let data = source.data.unwrap();\n        // \"4 DATE 31 DEC 1900\",\n        assert!(data.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Sample CHR Source text.\",\n        assert!(data.text.unwrap().note.unwrap() == \"Sample CHR Source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE A christening Source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A christening Source note.\");\n\n        // \"2 NOTE Christening event note (the religious event (not LDS) of baptizing and/or naming a \",\n        // \"3 CONC child).\",\n        assert!(chr.event.detail.note.unwrap() == \"Christening event note (the religious event (not LDS) of baptizing and/or naming a child).\");\n\n        // \"2 FAMC @F3@\",\n        assert!(chr.family.unwrap().xref == \"@F3@\".to_string());\n\n        // \"1 BARM\",\n        let barm = indi.barmitzvah.first().unwrap().clone();\n        // \"2 DATE AFT 31 DEC 1997\",\n        assert!(barm.detail.date.unwrap() == \"AFT 31 DEC 1997\");\n\n        // \"2 PLAC The place\",\n        assert!(barm.detail.place.unwrap().name.unwrap() == \"The place\");\n\n        // \"2 TYPE BARM\",\n        assert!(barm.detail.r#type.unwrap() == \"BARM\");\n\n        let source = barm.detail.sources.first().unwrap().clone();\n        // \"2 SOUR @S1@\",\n        assert!(source.xref.unwrap() == \"@S1@\");\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let sdata = source.data.unwrap();\n\n        // \"4 DATE 31 DEC 1900\",\n        assert!(sdata.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Some Bar Mitzvah source text.\",\n        assert!(sdata.text.unwrap().note.unwrap() == \"Some Bar Mitzvah source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE A Bar Mitzvah source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A Bar Mitzvah source note.\");\n\n        // \"2 NOTE Bar Mitzvah event note (the ceremonial event held when a Jewish boy reaches age \",\n        // \"3 CONC 13).\",\n        assert!(barm.detail.note.unwrap() == \"Bar Mitzvah event note (the ceremonial event held when a Jewish boy reaches age 13).\");\n\n        // Baz Mitzvah\n        // \"1 BASM\",\n        let basm = indi.basmitzvah.first().unwrap().clone();\n\n        // \"2 DATE AFT 31 DEC 1997\",\n        assert!(basm.detail.date.unwrap() == \"AFT 31 DEC 1997\");\n\n        // \"2 PLAC The place\",\n        assert!(basm.detail.place.unwrap().name.unwrap() == \"The place\");\n\n        // \"2 TYPE BARM\",\n        assert!(basm.detail.r#type.unwrap() == \"BASM\");\n\n        let source = basm.detail.sources.first().unwrap().clone();\n        // \"2 SOUR @S1@\",\n        assert!(source.xref.unwrap() == \"@S1@\");\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let sdata = source.data.unwrap();\n\n        // \"4 DATE 31 DEC 1900\",\n        assert!(sdata.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Some Bar Mitzvah source text.\",\n        assert!(sdata.text.unwrap().note.unwrap() == \"Some Bas Mitzvah source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE A Bar Mitzvah source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A Bas Mitzvah source note.\");\n\n        // \"2 NOTE Bas Mitzvah event note (the ceremonial event held when a Jewish girl reaches age 13, \",\n        // \"3 CONC also known as \\\"Bat Mitzvah\\\").\",\n        assert!(basm.detail.note.unwrap() == \"Bas Mitzvah event note (the ceremonial event held when a Jewish girl reaches age 13, also known as \\\"Bat Mitzvah\\\").\");\n\n        // \"1 ADOP\",\n        let mut adoption = indi.adoption.pop().unwrap().clone();\n\n        // \"2 DATE BEF 31 DEC 1997\",\n        assert!(adoption.event.detail.date.unwrap() == \"BEF 31 DEC 1997\");\n\n        // \"2 PLAC The place\",\n        assert!(adoption.event.detail.place.unwrap().name.unwrap() == \"The place\");\n\n        // \"2 TYPE ADOP\",\n        assert!(adoption.event.detail.r#type.unwrap() == \"ADOP\");\n\n        // \"2 SOUR @S1@\",\n        let source = adoption.event.detail.sources.pop().unwrap();\n        assert!(source.xref.unwrap() == \"@S1@\");\n\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let sdata = source.data.unwrap();\n\n        // \"4 DATE 31 DEC 1900\",\n        assert!(sdata.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Some adoption source text.\",\n        assert!(sdata.text.unwrap().note.unwrap() == \"Some adoption source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE An adoption source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"An adoption source note.\");\n\n        // \"2 NOTE Adoption event note (pertaining to creation of a child-parent relationship that does \",\n        // \"3 CONC not exist biologically).\",\n        assert!(adoption.event.detail.note.unwrap() == \"Adoption event note (pertaining to creation of a child-parent relationship that does not exist biologically).\");\n\n        // \"2 FAMC @F3@\",\n        let family = adoption.family.unwrap();\n        assert!(family.xref == \"@F3@\");\n        // \"3 ADOP BOTH\",\n        assert!(family.adopted_by.is_some());\n        assert!(family.adopted_by.unwrap() == AdoptedBy::Both);\n\n        // Adult Christening\n        // \"1 CHRA\",\n        let chr = indi.christening_adult.first().unwrap().clone();\n\n        // \"2 DATE BET 31 DEC 1997 AND 1 FEB 1998\",\n        assert!(chr.event.detail.date.unwrap() == \"BET 31 DEC 1997 AND 1 FEB 1998\");\n\n        // \"2 PLAC The place\",\n        assert!(chr.event.detail.place.unwrap().name.unwrap() == \"The place\");\n        // \"2 TYPE CHRA\",\n        assert!(chr.event.detail.r#type.unwrap() == \"CHRA\");\n\n        let source = chr.event.detail.sources.first().unwrap().clone();\n        // \"2 SOUR @S1@\",\n        assert!(source.xref.unwrap() == \"@S1@\");\n\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let data = source.data.unwrap();\n        // \"4 DATE 31 DEC 1900\",\n        assert!(data.date.unwrap() == \"31 DEC 1900\");\n        // \"4 TEXT Some christening source text.\",\n        assert!(data.text.unwrap().note.unwrap() == \"Some christening source text.\");\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n        // \"3 NOTE A christening source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A christening source note.\");\n\n        // \"2 NOTE Adult christening event note (the religious event (not LDS) of baptizing and/or \",\n        // \"3 CONC naming an adult person).\",\n        assert!(chr.event.detail.note.unwrap() == \"Adult christening event note (the religious event (not LDS) of baptizing and/or naming an adult person).\");\n\n        // CONFIRMATION\n        // \"1 CONF\",\n        assert!(indi.confirmation.len() == 1);\n        let confirmation = indi.confirmation.first().unwrap().clone();\n\n        // \"2 DATE BET 31 DEC 1997 AND 2 JAN 1998\",\n        assert!(confirmation.detail.date.unwrap() == \"BET 31 DEC 1997 AND 2 JAN 1998\");\n\n        // \"2 PLAC The place\",\n        assert!(confirmation.detail.place.unwrap().name.unwrap() == \"The place\");\n\n        // \"2 TYPE CONF\",\n        assert!(confirmation.detail.r#type.unwrap() == \"CONF\");\n\n        let source = confirmation.detail.sources.first().unwrap().clone();\n\n        // \"2 SOUR @S1@\",\n        assert!(source.xref.unwrap() == \"@S1@\");\n\n        // \"3 PAGE 42\",\n        assert!(source.page.unwrap() == 42);\n\n        // \"3 DATA\",\n        let sdata = source.data.unwrap();\n\n        // \"4 DATE 31 DEC 1900\",\n        assert!(sdata.date.unwrap() == \"31 DEC 1900\");\n\n        // \"4 TEXT Some CONF Source text.\",\n        assert!(sdata.text.unwrap().note.unwrap() == \"Some CONF Source text.\");\n\n        // \"3 QUAY 3\",\n        assert!(source.quay.unwrap() == Quay::Direct);\n\n        // \"3 NOTE A CONF Source note.\",\n        assert!(source.note.unwrap().note.unwrap() == \"A CONF Source note.\");\n\n        // \"2 NOTE CONFIRMATION event note (the religious event (not LDS) of conferring the gift of the Holy Ghost and, among protestants, full church membership).\",\n        assert!(confirmation.detail.note.unwrap() == \"CONFIRMATION event note (the religious event (not LDS) of conferring the gift of the Holy Ghost and, among protestants, full church membership).\");\n    }\n}\n","traces":[{"line":88,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":913},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":900},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":900},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":900},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":202},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":197},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":177},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":163},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":167},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":152},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":136},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":136},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":130},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":128},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":124},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":126},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":124},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":120},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":118},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":114},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":112},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":108},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":106},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":102},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":100},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":98},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":96},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":88},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":76},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":74},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":82},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":58},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":685},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1726},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":826},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":13},"fn_name":null}],"covered":121,"coverable":126},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","mod.rs"],"content":"// Allow inception for now, until this can be refactored. It's because the parent\n// and child modules (individual.Individual) have the same name.\n#![allow(clippy::module_inception)]\n\nmod adoption;\nmod birth;\nmod christening;\nmod death;\nmod event;\nmod gender;\nmod individual;\nmod name;\nmod note;\nmod residence;\nmod source;\n\npub use adoption::Adoption;\npub use birth::Birth;\npub use christening::Christening;\npub use death::Death;\npub use event::IndividualEventDetail;\npub use gender::*;\npub use individual::*;\npub use name::*;\npub use note::*;\npub use residence::Residence;\npub use source::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","name.rs"],"content":"// use crate::parse;\nuse crate::{parse, types::Line, types::Note};\n\nuse winnow::prelude::*;\n\n// PERSONAL_NAME_PIECES:=\n// n NPFX \u003cNAME_PIECE_PREFIX\u003e\n// n GIVN \u003cNAME_PIECE_GIVEN\u003e\n// n NICK \u003cNAME_PIECE_NICKNAME\u003e\n// n SPFX \u003cNAME_PIECE_SURNAME_PREFIX\n// n SURN \u003cNAME_PIECE_SURNAME\u003e\n// n NSFX \u003cNAME_PIECE_SUFFIX\u003e\n// n \u003c\u003cNOTE_STRUCTURE\u003e\u003e\n// n \u003c\u003cSOURCE_CITATION\u003e\u003e\n#[derive(Debug, Default)]\npub struct Name {\n    /// The value of the Name level\n    pub value: Option\u003cString\u003e,\n\n    /// GIVN\n    /// Given name or earned name. Different given names are separated by a comma.\n    pub given: Option\u003cString\u003e,\n\n    /// SURN\n    /// Surname or family name. Different surnames are separated by a comma.\n    pub surname: Option\u003cString\u003e,\n\n    /// NICK\n    /// A descriptive or familiar name used in connection with one's proper name.\n    pub nickname: Option\u003cString\u003e,\n\n    /// NPFX\n    /// Non indexing name piece that appears preceding the given name and surname\n    /// parts. Different name prefix parts are separated by a comma.\n    ///\n    /// Lt. Cmndr. Joseph /Allen/ jr.\n    /// In this example Lt. Cmndr. is considered as the name prefix portion.\n    pub prefix: Option\u003cString\u003e,\n\n    /// SPFX\n    /// Non-indexing name piece that appears after the given name and surname parts.\n    /// Different name suffix parts are separated by a comma.\n    ///\n    /// For example:\n    /// Lt. Cmndr. Joseph /Allen/ jr.\n    /// In this example jr. is considered as the name suffix portion.\n    pub suffix: Option\u003cString\u003e,\n\n    /// NSFX\n    /// Surname prefix or article used in a family name. Different surname articles\n    /// are separated by a comma, for example in the name \"de la Cruz\", this value\n    /// would be \"de, la\".\n    pub surname_prefix: Option\u003cString\u003e,\n\n    pub note: Option\u003ccrate::types::Note\u003e,\n\n    // TODO: do we need a specific struct for type or is it just a string?\n    pub r#type: Option\u003cString\u003e,\n}\nimpl Name {\n    fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cName\u003e {\n        let mut name = Name {\n            value: None,\n            given: None,\n            surname: None,\n            nickname: None,\n            prefix: None,\n            suffix: None,\n            surname_prefix: None,\n            note: None,\n            r#type: None,\n        };\n\n        // We're on level two, so parse until we hit another level two?\n        // let min_level: i32 = 2;\n\n        // let mut buffer: \u0026str = record;\n\n        // let mut _level: u8;\n        // let mut _xref: Option\u003c\u0026str\u003e;\n        // let mut tag: Option\u003c\u0026str\u003e;\n        // let mut value: Option\u003c\u0026str\u003e;\n        let mut line: Line;\n\n        while !record.is_empty() {\n            let mut consume = true;\n            // line = Line::parse(record).unwrap();\n            line = Line::peek(record).unwrap();\n\n            // (buffer, line) = Line::parse(buffer).unwrap();\n            // println!(\"Name::level = {}, tag = {:?}, value={:?}\", line.level, line.tag, line.value);\n\n            match line.tag {\n                \"NAME\" =\u003e {\n                    name.value = Some(line.value.to_string());\n                    // println!(\"name: {:?}\", name.value);\n                }\n                \"TYPE\" =\u003e {\n                    // type\n                    name.r#type = Some(line.value.to_string());\n                }\n                \"GIVN\" =\u003e {\n                    name.given = Some(line.value.to_string());\n                }\n                \"SURN\" =\u003e {\n                    name.surname = Some(line.value.to_string());\n                }\n                \"NICK\" =\u003e {\n                    name.nickname = Some(line.value.to_string());\n                }\n                \"NOTE\" =\u003e {\n                    let note = parse::get_tag_value(record).unwrap();\n                    name.note = Some(Note { note });\n                    consume = false;\n                }\n                \"NPFX\" =\u003e {\n                    name.prefix = Some(line.value.to_string());\n                }\n                \"SPFX\" =\u003e {\n                    name.suffix = Some(line.value.to_string());\n                }\n                \"NSFX\" =\u003e {\n                    name.surname_prefix = Some(line.value.to_string());\n                }\n                _ =\u003e {\n                    // println!(\"Unhandled name tag: {:?}\", tag.unwrap());\n                }\n            }\n\n            if consume {\n                Line::parse(record).unwrap();\n            }\n            // Check if the next line is a new NAME record\n            // TODO: a peek_line method so we can check level and tag in one call\n            // let (_, line) = Line::parse(buffer).unwrap();\n            line = Line::peek(record).unwrap();\n\n            // let level = parse::peek_level(buffer).unwrap_or((\"\", 0_u8)).1;\n            // // let tag = Some(parse::peek_tag(buffer).unwrap().1);\n            // let tag = parse::peek_tag(buffer).unwrap().1;\n\n            if line.level == 1 {\n                break;\n            }\n            // if line.level == 1 \u0026\u0026 line.tag == \"NAME\" {\n            //     break;\n            // }\n\n            if line.level == 2 \u0026\u0026 (line.tag == \"ROMN\" || line.tag == \"FONE\") {\n                break;\n            }\n            if line.tag == \"BIRT\" {\n                println!(\"DEBUG: {:?}\", line);\n            }\n        }\n\n        // println!(\"Name: {:?}\", name);\n        Ok(name)\n    }\n}\n\n// PERSONAL_NAME_STRUCTURE\n// n NAME \u003cNAME_PERSONAL\u003e\n// +1 TYPE \u003cNAME_TYPE\u003e\n// +1 \u003c\u003cPERSONAL_NAME_PIECES\u003e\u003e\n// +1 FONE \u003cNAME_PHONETIC_VARIATION\u003e\n// +2 TYPE \u003cPHONETIC_TYPE\u003e\n// +2 \u003c\u003cPERSONAL_NAME_PIECES\u003e\u003e\n// +1 ROMN \u003cNAME_ROMANIZED_VARIATION\u003e\n// +2 TYPE \u003cROMANIZED_TYPE\u003e\n// +2 \u003c\u003cPERSONAL_NAME_PIECES\u003e\u003e\n#[derive(Debug, Default)]\npub struct PersonalName {\n    /// The surname of an individual, if known, is enclosed between two slash (/)\n    /// characters. The order of the name parts should be the order that the person\n    /// would, by custom of their culture, have used when giving it to a recorder.\n    /// Early versions of Personal Ancestral File ® and other products did not use\n    /// the trailing slash when the surname was the last element of the name. If\n    /// part of name is illegible, that part is indicated by an ellipsis (...).\n    /// Capitalize the name of a person or place in the conventional manner—\n    /// capitalize the first letter of each part and lowercase the other letters,\n    /// unless conventional usage is otherwise. For example: McMurray.\n    ///\n    /// Examples:\n    /// William Lee (given name only or surname not known)\n    /// /Parry/ (surname only)\n    /// William Lee /Parry/\n    /// William Lee /Mac Parry/ (both parts (Mac and Parry) are surname parts William /Lee/ Parry (surname imbedded in the name string)\n    /// William Lee /Pa.../\n    ///\n    /// TODO: Can there be multiple names? The torture file seems to indicate so\n    pub name: Name,\n\n    // pub pieces: PersonalNamePieces,\n    pub r#type: Option\u003cString\u003e,\n\n    // The romanized variation of the name is written in the same form prescribed\n    /// for the name used in the superior \u003cNAME_PERSONAL\u003e context. The method used\n    /// to romanize the name is indicated by the line_value of the subordinate\n    /// \u003cROMANIZED_TYPE\u003e, for example if romaji was used to provide a reading of\n    /// a name written in kanji, then the ROMANIZED_TYPE subordinate to the ROMN\n    /// tag would indicate romaji.\n    pub romanized: Name,\n\n    /// FONE\n    /// The phonetic variation of the name is written in the same form as the was\n    /// the name used in the superior \u003cNAME_PERSONAL\u003e primitive, but phonetically\n    /// written using the method indicated by the subordinate \u003cPHONETIC_TYPE\u003e value,\n    /// for example if hiragana was used to provide a reading of a name written\n    /// in kanji, then the \u003cPHONETIC_TYPE\u003e value would indicate ‘kana’.\n    pub phonetic: Name,\n}\n// impl AsRef\u003cPersonalNamePieces\u003e for PersonalName {\n//     fn as_ref(\u0026self) -\u003e \u0026PersonalNamePieces {\n//         \u0026self.pieces\n//     }\n// }\n\nimpl PersonalName {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cPersonalName\u003e {\n        let mut pn = PersonalName {\n            name: Name {\n                value: None,\n                given: None,\n                surname: None,\n                nickname: None,\n                prefix: None,\n                suffix: None,\n                surname_prefix: None,\n                note: None,\n                r#type: None,\n            },\n            romanized: Name {\n                value: None,\n                given: None,\n                surname: None,\n                nickname: None,\n                prefix: None,\n                suffix: None,\n                surname_prefix: None,\n                note: None,\n                r#type: None,\n            },\n            phonetic: Name {\n                value: None,\n                given: None,\n                surname: None,\n                nickname: None,\n                prefix: None,\n                suffix: None,\n                surname_prefix: None,\n                note: None,\n                r#type: None,\n            },\n            r#type: None,\n        };\n\n        // We're on level one, so parse until we hit another level one?\n        let level = Line::peek(record).unwrap().level;\n\n        // Parse the name out of the record, and switch to a buffer\n        pn.name = Name::parse(record).unwrap();\n\n        // let mut line = Line::parse(\u0026mut buffer).unwrap();\n        let mut line = Line::peek(record).unwrap();\n\n        // let (mut buffer, mut line) = Line::parse(buffer).unwrap();\n\n        // while line.level \u003e 1 \u0026\u0026 !buffer.is_empty() {\n        // println!(\"1 Line: {:?}\", line);\n        while line.level \u003e level \u0026\u0026 !record.is_empty() {\n            if line.level == level + 1 {\n                match line.tag {\n                    \"ROMN\" =\u003e {\n                        pn.romanized = Name::parse(record).unwrap();\n                        if !line.value.is_empty() {\n                            pn.romanized.value = Some(line.value.to_string());\n                        } else {\n                            println!(\n                                \"Romanized value is missing; Level={}, tag={}\",\n                                line.level, line.tag\n                            );\n                        }\n                    }\n                    \"FONE\" =\u003e {\n                        pn.phonetic = Name::parse(record).unwrap();\n                        if !line.value.is_empty() {\n                            pn.phonetic.value = Some(line.value.to_string());\n                        } else {\n                            println!(\n                                \"Phonetic value is missing; Level={}, tag={}\",\n                                line.level, line.tag\n                            );\n                        }\n                    }\n                    _ =\u003e {\n                        println!(\"skipping PersonalName tag {:?}\", line.tag);\n                    }\n                }\n            }\n            if line.level == level {\n                break;\n            } else {\n                // (buffer, line) = Line::parse(buffer).unwrap();\n                // line = Line::parse(record).unwrap();\n                line = Line::peek(record).unwrap();\n            }\n        }\n\n        Ok(pn)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    /// Tests a possible bug in Ancestry's format, if a line break is embedded within the content of a note\n    /// As far as I can tell, it's a \\n embedded into the note, at least, from a hex dump of that content.\n    fn parse_indi() {\n        let data = vec![\n            // \"0 @I1@ INDI\",\n            \"1 NAME Joseph Tag /Torture/\",\n            \"2 TYPE birth\",\n            \"2 NPFX Prof.\",\n            \"2 GIVN Joseph\",\n            \"2 NICK Joe\",\n            \"2 SPFX Le\",\n            \"2 SURN Torture\",\n            \"2 NSFX Jr.\",\n            \"2 NOTE These are notes about the first NAME structure in this record. These notes are \",\n            \"3 CONC embedded in the INDIVIDUAL record itself.\",\n            \"3 CONT \",\n            \"3 CONT This name structure uses all possible tags for a personal name structure.\",\n            \"3 CONT \",\n            \"3 CONT NOTE: many applications are confused by two NAME structures.\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 55\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE @N7@\",\n            \"3 QUAY 0\",\n            \"2 FONE Joseph Tag /Torture/\",\n            \"3 TYPE user defined\",\n            \"3 NPFX Prof.\",\n            \"3 GIVN Joseph\",\n            \"3 NICK Joe\",\n            \"3 SPFX Le\",\n            \"3 SURN Torture\",\n            \"3 NSFX Jr.\",\n            \"3 NOTE Phonetisation\",\n            \"3 SOUR @S1@\",\n            \"4 PAGE 55\",\n            \"4 EVEN BIRT\",\n            \"5 ROLE CHIL\",\n            \"4 DATA\",\n            \"5 DATE 1 JAN 1900\",\n            \"5 TEXT Here is some text from the source specific to this source \",\n            \"6 CONC citation.\",\n            \"6 CONT Here is more text but on a new line.\",\n            \"4 OBJE @M8@\",\n            \"4 NOTE @N7@\",\n            \"4 QUAY 0\",\n            \"2 ROMN Joseph Tag /Torture/\",\n            \"3 TYPE user defined\",\n            \"3 NPFX Prof.\",\n            \"3 GIVN Joseph\",\n            \"3 NICK Joe\",\n            \"3 SPFX Le\",\n            \"3 SURN Torture\",\n            \"3 NSFX Jr.\",\n            \"3 NOTE Romanisation\",\n            \"3 SOUR @S1@\",\n            \"4 PAGE 55\",\n            \"4 EVEN BIRT\",\n            \"5 ROLE CHIL\",\n            \"4 DATA\",\n            \"5 DATE 1 JAN 1900\",\n            \"5 TEXT Here is some text from the source specific to this source \",\n            \"6 CONC citation.\",\n            \"6 CONT Here is more text but on a new line.\",\n            \"4 OBJE @M8@\",\n            \"4 NOTE @N7@\",\n            \"4 QUAY 0\",\n            \"1 NAME William John /Smith/\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"2 NOTE This is a second personal NAME structure in a single INDIVIDUAL record \",\n            \"3 CONC which is allowed in GEDCOM.\",\n            \"3 CONT \",\n            \"3 CONT These notes are embedded in the INDIVIDUAL record.\",\n            \"1 SEX M\",\n            \"1 BIRT\",\n            \"2 TYPE Normal\",\n            \"2 DATE 31 DEC 1965\",\n            \"2 PLAC Salt Lake City, UT, USA\",\n            \"3 FONE Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 ROMN Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 MAP\",\n            \"4 LATI N0\",\n            \"4 LONG E0\",\n            \"3 NOTE Place note\",\n            \"2 ADDR\",\n            \"3 ADR1 St. Marks Hospital\",\n            \"3 CITY Salt Lake City\",\n            \"3 STAE UT\",\n            \"3 POST 84121\",\n            \"3 CTRY USA\",\n            \"2 AGNC none\",\n            \"2 RELI Religion\",\n            \"2 CAUS Conception\",\n            \"2 NOTE @N8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE Some notes about this birth source citation which are embedded in the citation \",\n            \"4 CONC structure itself.\",\n            \"3 QUAY 2\",\n            \"2 OBJE @M15@\",\n            \"2 AGE 0y\",\n            \"2 FAMC @F2@\",\n            \"1 DEAT\",\n            \"2 DATE ABT 15 JAN 2001\",\n            \"2 PLAC New York, New York, USA\",\n            \"3 NOTE The place structure has more detail than usually used for places\",\n            \"2 AGE 76y\",\n            \"2 TYPE slow\",\n            \"2 ADDR\",\n            \"3 ADR1 at Home\",\n            \"2 CAUS Cancer\",\n            \"2 AGNC none\",\n            \"2 OBJE @M8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some death source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A death source note.\",\n            \"2 NOTE A death event note.\",\n            \"1 FAMS @F1@\",\n            \"2 NOTE Note about the link to the family record with his first spouse.\",\n            \"2 NOTE Another note about the link to the family record with his first spouse.\",\n            \"1 FAMS @F4@\",\n            \"1 FAMC @F2@\",\n            \"2 NOTE Note about this link to his parents family record.\",\n            \"2 NOTE Another note about this link to his parents family record\",\n            \"1 FAMC @F3@\",\n            \"2 PEDI adopted\",\n            \"2 NOTE Note about the link to his adoptive parents family record.\",\n            \"1 BAPM\",\n            \"2 DATE ABT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 AGE 3m\",\n            \"2 TYPE BAPM\",\n            \"2 ADDR\",\n            \"3 ADR1 Church Name\",\n            \"3 ADR2 Street Address\",\n            \"3 CITY City Name\",\n            \"3 POST zip\",\n            \"3 CTRY Country\",\n            \"2 CAUS Birth\",\n            \"2 AGNC The Church\",\n            \"2 OBJE @M8@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample baptism Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A baptism source note.\",\n            \"2 NOTE A baptism event note (the event of baptism (not LDS), performed in infancy or later. See also BAPL and CHR).\",\n            \"1 CHR\",\n            \"2 DATE CAL 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample CHR Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening Source note.\",\n            \"2 NOTE Christening event note (the religious event (not LDS) of baptizing and/or naming a \",\n            \"3 CONC child).\",\n            \"2 FAMC @F3@\",\n            \"1 CHR\",\n            \"2 DATE EST 30 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some christening source text.\",\n            \"5 CONT This is the second christening structure.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening Source note.\",\n            \"2 NOTE Alternative christening event note. GEDOM allows more than one of the same type \",\n            \"3 CONC of event.\",\n            \"1 BARM\",\n            \"2 DATE AFT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE BARM\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some Bar Mitzvah source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A Bar Mitzvah source note.\",\n            \"2 NOTE Bar Mitzvah event note (the ceremonial event held when a Jewish boy reaches age \",\n            \"3 CONC 13).\",\n            \"1 BASM\",\n            \"2 DATE AFT 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE BASM\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some Bas Mitzvah source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A Bas Mitzvah source note.\",\n            \"2 NOTE Bas Mitzvah event note (the ceremonial event held when a Jewish girl reaches age 13, \",\n            \"3 CONC also known as \\\"Bat Mitzvah\\\").\",\n            \"1 ADOP\",\n            \"2 DATE BEF 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE ADOP\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some adoption source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An adoption source note.\",\n            \"2 NOTE Adoption event note (pertaining to creation of a child-parent relationship that does \",\n            \"3 CONC not exist biologically).\",\n            \"2 FAMC @F3@\",\n            \"3 ADOP BOTH\",\n            \"1 CHRA\",\n            \"2 DATE BET 31 DEC 1997 AND 1 FEB 1998\",\n            \"2 PLAC The place\",\n            \"2 TYPE CHRA\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some christening source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A christening source note.\",\n            \"2 NOTE Adult christening event note (the religious event (not LDS) of baptizing and/or \",\n            \"3 CONC naming an adult person).\",\n            \"1 CONF\",\n            \"2 DATE BET 31 DEC 1997 AND 2 JAN 1998\",\n            \"2 PLAC The place\",\n            \"2 TYPE CONF\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some CONF Source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A CONF Source note.\",\n            \"2 NOTE CONFIRMATION event note (the religious event (not LDS) of conferring the gift of the Holy Ghost and, among protestants, full church membership).\",\n            \"1 FCOM\",\n            \"2 DATE INT 31 DEC 1997 (a test)\",\n            \"2 PLAC The place\",\n            \"2 TYPE FCOM\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some first communion source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An first communion source note.\",\n            \"2 NOTE First communion event note (a religious rite, the first act of sharing in the Lord's \",\n            \"3 CONC supper as part of church worship).\",\n            \"1 GRAD\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE GRAD\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some graduation source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A graduation source note.\",\n            \"2 NOTE Graduation event note (an event of awarding educational diplomas or degrees to \",\n            \"3 CONC individuals).\",\n            \"1 EMIG\",\n            \"2 DATE 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE EMIG\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some emigration source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An emigration source note.\",\n            \"2 NOTE Emigration event note (an event of leaving one's homeland with the intent of residing \",\n            \"3 CONC elsewhere).\",\n            \"1 IMMI\",\n            \"2 DATE DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE IMMI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some immigration source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An immigration source note.\",\n            \"2 NOTE Immigration event note (an event of entering into a new locality with the intent of \",\n            \"3 CONC residing there).\",\n            \"1 NATU\",\n            \"2 DATE 1100 BCE\",\n            \"2 PLAC The place\",\n            \"2 TYPE NATU\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some naturalization source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A naturalization source note.\",\n            \"2 NOTE Naturalization event note (the event of obtaining citizenship).\",\n            \"1 CENS\",\n            \"2 DATE @#DHEBREW@ 2 TVT 5758\",\n            \"2 PLAC The place\",\n            \"2 TYPE CENS\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some census source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A census source note.\",\n            \"2 NOTE Census event note (the event of the periodic count of the population for a designated \",\n            \"3 CONC locality, such as a national or state Census).\",\n            \"1 RETI\",\n            \"2 DATE @#DFRENCH R@ 11 NIVO 0006\",\n            \"2 PLAC The place\",\n            \"2 TYPE RETI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some retirement source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A retirement source note.\",\n            \"2 NOTE Retirement event note (an event of exiting an occupational relationship with an \",\n            \"3 CONC employer after a qualifying time period).\",\n            \"1 PROB\",\n            \"2 DATE FROM @#DHEBREW@ 25 SVN 5757 TO @#DHEBREW@ 26 IYR 5757\",\n            \"2 PLAC The place\",\n            \"2 TYPE PROB\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some probate source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A probate source note.\",\n            \"2 NOTE Probate event note (an event of judicial determination of the validity of a will. May \",\n            \"3 CONC indicate several related court activities over several dates).\",\n            \"1 BURI\",\n            \"2 DATE @#DFRENCH R@ 5 VEND 0010\",\n            \"2 PLAC The place\",\n            \"2 TYPE BURI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some burial source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A burial source note.\",\n            \"2 NOTE Burial event note (the event of the proper disposing of the mortal remains of a \",\n            \"3 CONC deceased person).\",\n            \"1 WILL\",\n            \"2 DATE INT @#DHEBREW@ 2 TVT 5758 (interpreted)\",\n            \"2 PLAC The place\",\n            \"2 TYPE WILL\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some will source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A will source note.\",\n            \"2 NOTE Will event note (a legal document treated as an event, by which a person disposes of \",\n            \"3 CONC his or her estate, to take effect after death. The event date is the date the will was \",\n            \"3 CONC signed while the person was alive. See also Probate).\",\n            \"1 CREM\",\n            \"2 DATE AFT 15 JAN 2001\",\n            \"1 EVEN\",\n            \"2 DATE 5 MAY 0005\",\n            \"2 PLAC The place\",\n            \"2 TYPE EVEN\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some generic event source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A generic event source note.\",\n            \"2 NOTE Generic event note (a noteworthy happening related to an individual, a group, or an \",\n            \"3 CONC organization). The TYPE tag specifies the type of event.\",\n            \"1 RESI\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 AGE 35y\",\n            \"2 TYPE RESI\",\n            \"2 ADDR\",\n            \"3 ADR1 Special Address Line 1\",\n            \"3 ADR2 Special Address Line 2\",\n            \"3 ADR3 Special Address Line 3\",\n            \"3 CITY City Name\",\n            \"3 STAE State name\",\n            \"3 POST 0123456789\",\n            \"3 CTRY USA\",\n            \"2 PHON +1-800-555-5555\",\n            \"2 CAUS Needed housing\",\n            \"2 AGNC None\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some residence source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A residence source note.\",\n            \"2 NOTE Residence attribute note (the act of dwelling at an address for a period of time).\",\n            \"1 OCCU Occupation\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 AGE 40y\",\n            \"2 PLAC The place\",\n            \"2 TYPE OCCU\",\n            \"2 ADDR\",\n            \"3 ADR1 Work address line 1\",\n            \"3 ADR2 Work address line 2\",\n            \"3 ADR3 Work address line 3\",\n            \"3 CITY Work city\",\n            \"3 STAE Work state\",\n            \"3 POST Work post\",\n            \"3 CTRY Work country\",\n            \"2 CAUS Need for money\",\n            \"2 AGNC Employer\",\n            \"2 OBJE @M7@\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some occupation source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An occupation source note.\",\n            \"2 NOTE Occupation attribute note (the type of work or profession of an individual).\",\n            \"1 OCCU Another occupation\",\n            \"2 DATE 31 DEC 1998\",\n            \"2 PLAC The place\",\n            \"2 TYPE OCCU\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some occupation source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An occupation source note.\",\n            \"2 NOTE Occupation attribute note. This is the second occupation attribute in the record.\",\n            \"1 EDUC Education\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE EDUC\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some education source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An education source note.\",\n            \"2 NOTE Education attribute note (indicator of a level of education attained).\",\n            \"1 DSCR Physical description\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE PHYS\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some physical description source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A physical description source note.\",\n            \"2 NOTE Physical description attribute note (the physical characteristics of a person, place, or \",\n            \"3 CONC thing).\",\n            \"1 RELI Religion\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE RELI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some religion source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A religion source note.\",\n            \"2 NOTE Religion attribute note (a religious denomination to which a person is affiliated or for \",\n            \"3 CONC which a record applies).\",\n            \"1 IDNO 6942\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE IDNO\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some national identification number source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An national identification number source note.\",\n            \"2 NOTE National identification number attribute note (a number assigned to identify a person \",\n            \"3 CONC within some significant external system).\",\n            \"1 PROP Possessions\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE PROP\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some possessions source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE @N11@\",\n            \"2 NOTE Possessions or property attribute note (pertaining to possessions such as real estate \",\n            \"3 CONC or other property of interest).\",\n            \"1 CAST Cast name\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE CAST\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some caste name source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A caste name source note.\",\n            \"2 NOTE Caste name attribute note (the name of an individual's rank or status in society, based \",\n            \"3 CONC on racial or religious differences, or differences in wealth, inherited rank, profession, \",\n            \"3 CONC occupation, etc).\",\n            \"1 NCHI 42\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE NCHI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some number of children source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE Am number of children source note.\",\n            \"2 NOTE Number of children attribute note.\",\n            \"1 NMR 42\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE NMR\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some number of marriages source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An number of marriages source note.\",\n            \"2 NOTE Number of marriages attribute note.\",\n            \"1 TITL Nobility title\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE TITL\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some title source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE A title source note.\",\n            \"2 NOTE Title attribute note (a description of a specific writing or other work, such as the title \",\n            \"3 CONC of a book when used in a source context, or a formal designation used by an \",\n            \"3 CONC individual in connection with positions of royalty or other social status, \",\n            \"3 CONT such as Grand Duke).\",\n            \"1 NATI National or tribe origin\",\n            \"2 DATE 31 DEC 1997\",\n            \"2 PLAC The place\",\n            \"2 TYPE NATI\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Some nationality source text.\",\n            \"3 QUAY 3\",\n            \"3 NOTE An nationality source note.\",\n            \"2 NOTE Nationality attribute note (the national heritage of an individual).\",\n            \"1 NOTE @N4@\",\n            \"1 NOTE This is a second set of notes for this single individual record. It is embedded in the \",\n            \"2 CONC INDIVIDUAL record instead of being in a separate NOTE record.\",\n            \"2 CONT \",\n            \"2 CONT These notes also have a source citation to a SOURCE record. In GEDCOM \",\n            \"2 CONC this source can only be a single line and links to a SOURCE record.\",\n            \"1 SOUR @S1@\",\n            \"2 PAGE 42\",\n            \"2 DATA\",\n            \"3 DATE 31 DEC 1900\",\n            \"3 TEXT Some sample text from the first source on this record.\",\n            \"2 QUAY 0\",\n            \"2 NOTE A source note.\",\n            \"1 SOUR @S2@\",\n            \"2 NOTE @N12@\",\n            \"1 OBJE @M7@\",\n            \"1 ASSO @I9@\",\n            \"2 RELA Has multimedia links\",\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 DATA\",\n            \"4 DATE 31 DEC 1900\",\n            \"4 TEXT Sample text about this source on an association.\",\n            \"2 NOTE Note on association link.\",\n            \"1 ASSO @I5@\",\n            \"2 RELA Father\",\n            \"1 REFN 01234567890123456789\",\n            \"2 TYPE reference\",\n            \"1 RIN 12\",\n            \"1 CHAN\",\n            \"2 DATE 12 FEB 2001\",\n            \"3 TIME 19:16:42\",\n        ];\n\n        let buffer = data.join(\"\\n\");\n        let mut record = buffer.as_str();\n        // println!(\"A Record: {}\", record.len());\n        let name = PersonalName::parse(\u0026mut record).unwrap();\n        // println!(\"B Record: {}\", record.len());\n        // println!(\"{name:#?}\");\n\n        // Check the name.name\n        assert_eq!(Some(\"Joseph Tag /Torture/\"), name.name.value.as_deref());\n        assert_eq!(Some(\"Joseph\"), name.name.given.as_deref());\n        assert_eq!(Some(\"Torture\"), name.name.surname.as_deref());\n        assert_eq!(Some(\"Joe\"), name.name.nickname.as_deref());\n        assert_eq!(Some(\"Prof.\"), name.name.prefix.as_deref());\n        assert_eq!(Some(\"Le\"), name.name.suffix.as_deref());\n        assert_eq!(Some(\"Jr.\"), name.name.surname_prefix.as_deref());\n        assert_eq!(Some(\"birth\"), name.name.r#type.as_deref());\n\n        // Check the name.romanized\n        assert_eq!(\n            Some(\"Joseph Tag /Torture/\"),\n            name.romanized.value.as_deref()\n        );\n        assert_eq!(Some(\"Joseph\"), name.romanized.given.as_deref());\n        assert_eq!(Some(\"Torture\"), name.romanized.surname.as_deref());\n        assert_eq!(Some(\"Joe\"), name.romanized.nickname.as_deref());\n        assert_eq!(Some(\"Prof.\"), name.romanized.prefix.as_deref());\n        assert_eq!(Some(\"Le\"), name.romanized.suffix.as_deref());\n        assert_eq!(Some(\"Jr.\"), name.romanized.surname_prefix.as_deref());\n        assert_eq!(Some(\"user defined\"), name.romanized.r#type.as_deref());\n\n        // Check the name.phonetic\n        assert_eq!(Some(\"Joseph Tag /Torture/\"), name.phonetic.value.as_deref());\n        assert_eq!(Some(\"Joseph\"), name.phonetic.given.as_deref());\n        assert_eq!(Some(\"Torture\"), name.phonetic.surname.as_deref());\n        assert_eq!(Some(\"Joe\"), name.phonetic.nickname.as_deref());\n        assert_eq!(Some(\"Prof.\"), name.phonetic.prefix.as_deref());\n        assert_eq!(Some(\"Le\"), name.phonetic.suffix.as_deref());\n        assert_eq!(Some(\"Jr.\"), name.phonetic.surname_prefix.as_deref());\n        assert_eq!(Some(\"user defined\"), name.phonetic.r#type.as_deref());\n    }\n}\n","traces":[{"line":61,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":208},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":208},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":208},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":208},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":201},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":192},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":183},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":174},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":176},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":145},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":136},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":127},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":109},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":396},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":188},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":208},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":208},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":263},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":186},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":16},"fn_name":null}],"covered":56,"coverable":66},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","note.rs"],"content":"#[derive(Debug, Default)]\npub struct NoteStructure {\n    pub note: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","residence.rs"],"content":"#[derive(Debug, Default)]\npub struct Residence {\n    pub place: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","types","individual","source.rs"],"content":"// #[derive(Debug, Default)]\n// pub struct SourceCitation {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","types","line.rs"],"content":"// use std::str::FromStr;\nuse std::fmt;\n\nuse winnow::ascii::{alphanumeric1, digit1, line_ending, not_line_ending, space0};\nuse winnow::combinator::{opt, preceded, separated_pair};\nuse winnow::error::StrContext;\nuse winnow::prelude::*;\nuse winnow::stream::Stream;\nuse winnow::token::{tag, take_till};\n\n/// A GEDCOM line\n/// level + delim (space) + [optional_xref_ID] + tag + [optional_line_value] + terminator\n#[derive(Debug, Eq, PartialEq, Clone, Copy)]\npub struct Line\u003c'a\u003e {\n    pub level: u8,\n    pub xref: \u0026'a str,\n    pub tag: \u0026'a str,\n    pub value: \u0026'a str,\n}\n\nimpl\u003c'b\u003e fmt::Display for Line\u003c'b\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        if !self.xref.is_empty() {\n            write!(\n                f,\n                \"{} {} {} {}\",\n                self.level, self.xref, self.tag, self.value\n            )\n        } else {\n            write!(f, \"{} {} {}\", self.level, self.tag, self.value)\n        }\n    }\n}\nimpl\u003c'b\u003e Line\u003c'b\u003e {\n    pub fn parse(input: \u0026mut \u0026'b str) -\u003e PResult\u003cLine\u003c'b\u003e\u003e {\n        let mut line = Line {\n            level: 0,\n            xref: \"\",\n            tag: \"\",\n            value: \"\",\n        };\n        // println!(\"Parsing line...\");\n        // println!(\"Starting input: '{}'\", input);\n        if !input.is_empty() {\n            // We could rewrite this into a sequence of parsers, something like this:\n            // let (level, _, xref, _, tag, delim, value) = (\n            //     Self::level,\n            //     Self::delim,\n            //     Self::xref,\n            //     Self::delim,\n            //     Self::tag,\n            //     Self::delim,\n            //     Self::value,\n            // )\n            //     .parse_next(input).unwrap();\n\n            let level = Self::level(input);\n            match level {\n                Ok(lvl) =\u003e {\n                    line.level = lvl;\n                    let _ = Self::delim(input);\n                    match Self::xref(input) {\n                        Ok(xref) =\u003e {\n                            line.xref = xref;\n                        }\n                        Err(_e) =\u003e {\n                            todo!();\n                        }\n                    }\n                    if !line.xref.is_empty() {\n                        let _ = Self::delim(input);\n                    }\n                    line.tag = Self::tag(input)?;\n                    let _ = Self::delim(input);\n\n                    let is_eol = Self::peek_eol(input)?;\n                    if is_eol {\n                        Self::eol(input).unwrap();\n                    } else {\n                        Self::delim(input).unwrap();\n                        line.value = Self::value(input)?;\n\n                        let is_eol = Self::peek_eol(input)?;\n                        if is_eol {\n                            Self::eol(input).unwrap();\n                        }\n                    }\n                }\n                Err(e) =\u003e {\n                    println!(\"Err: {}\", e);\n                    println!(\"Error parsing line: '{}'\", input);\n                    Self::eol(input).unwrap();\n                    /*\n                    There's a case where a line is simply the extension of the\n                    previous line because of an embedded newline. This is common\n                    in Ancestry source data, IME. Technically, it's incorrect\n                    according to spec; the data should use a CONC/CONT to indicate\n                    a break on a new line.\n\n                    What we can attempt to do is parse the line as the value, as\n                    if it were a CONCatonation. We don't have a line level, nor\n                    do we know what the previous line is, so we'll set it to\n                    u8::MAX, I guess, and add a special use-case for that.\n                     */\n\n                    // line.level = u8::MAX;\n                    // line.tag = \"CONC\";\n                    // line.value = Self::value(input)?;\n                    // println!(\"New value: '{:?}'\", line);\n\n                    // there's a case where the value of a line contains a newline,\n                    // breaking it into its own line. I think it's techically\n                    // invalid, according to spec; it should use CONC/CONT.\n                    // It's common in Ancestry source data so may as well work\n                    // to handle it.\n                }\n            }\n        } else {\n            // There's a few instances where we're passed an empty input.\n            // This might be a parsing error, but might not be. More testing!\n            // println!(\"Empty input\");\n        }\n        Ok(line)\n    }\n\n    /// Peek ahead at the next line without consuming it.\n    pub fn peek(input: \u0026mut \u0026'b str) -\u003e PResult\u003cLine\u003c'b\u003e\u003e {\n        let start = input.checkpoint();\n        let line = Line::parse(input).unwrap();\n\n        input.reset(start);\n        Ok(line)\n    }\n\n    /// Parse a number from the string, but return it as an actual Rust number, not a string.\n    fn level(input: \u0026mut \u0026str) -\u003e PResult\u003cu8\u003e {\n        // parse_to works because it uses FromStr, which is effectively\n        // a convienence function around try_map\n        // digit1.try_map(str::parse).parse_next(input)\n        digit1\n            .context(StrContext::Label(\"level\"))\n            .parse_to()\n            .parse_next(input)\n    }\n\n    /// Parse a number from the string, but return it as an actual Rust number, not a string.\n    // fn peek_level\u003c's\u003e(input: \u0026mut \u0026's str) -\u003e PResult\u003cu8\u003e {\n    //     let start = input.checkpoint();\n\n    //     let level = Self::level(input).unwrap();\n    //     input.reset(start);\n    //     Ok(level)\n    // }\n\n    /// Parse the delimiter\n    fn delim(input: \u0026mut \u0026'b str) -\u003e PResult\u003c\u0026'b str\u003e {\n        space0.context(StrContext::Label(\"delim\")).parse_next(input)\n    }\n\n    fn eol(input: \u0026mut \u0026'b str) -\u003e PResult\u003c\u0026'b str\u003e {\n        // multispace0.context(StrContext::Label(\"eol2\")).parse_next(input)\n        line_ending\n            .context(StrContext::Label(\"eol\"))\n            .parse_next(input)\n\n        // println!(\"EOL start input: '{}'\", input);\n        // let res = line_ending.context(StrContext::Label(\"eol\")).parse_next(input);\n        // println!(\"EOL end input: '{}'\", input);\n\n        // res\n    }\n\n    /// Peek at the next character to see if it's a newline\n    fn peek_eol(input: \u0026mut \u0026'b str) -\u003e PResult\u003cbool\u003e {\n        if input.starts_with('\\n') || input.starts_with(\"\\r\\n\") {\n            return Ok(true);\n        }\n\n        // let start = input.checkpoint();\n        // let res = Self::eol(input);\n        // input.reset(start);\n\n        // if !res.is_err() {\n        //     let is_eol = res.unwrap();\n        //     return Ok(!is_eol.is_empty());\n        // }\n        Ok(false)\n        // let is_eol = Self::eol(input).unwrap();\n\n        // input.reset(start);\n        // Ok(!is_eol.is_empty())\n    }\n\n    fn tag(input: \u0026mut \u0026'b str) -\u003e PResult\u003c\u0026'b str\u003e {\n        // one of: a-zA-Z_\n        let parser = preceded(opt(tag(\"_\")), alphanumeric1)\n            .recognize()\n            .verify(|o: \u0026str| o.len() \u003c= 31);\n\n        parser.context(StrContext::Label(\"tag\")).parse_next(input)\n    }\n\n    fn value(input: \u0026mut \u0026'b str) -\u003e PResult\u003c\u0026'b str\u003e {\n        not_line_ending\n            .context(StrContext::Label(\"value\"))\n            .parse_next(input)\n    }\n\n    /// Parse the xref, if present\n    ///\n    /// TODO: Return the leading/trailing @ portion of the xref\n    fn xref(input: \u0026mut \u0026'b str) -\u003e PResult\u003c\u0026'b str\u003e {\n        if input.starts_with('@') {\n            let mut parser =\n                separated_pair(tag(\"@\"), take_till(0.., |c| c == '@'), tag(\"@\")).recognize();\n            return parser.parse_next(input);\n\n            // println!(\"Parsing xref: '{}'\", input);\n            // let mut parser = delimited(tag(\"@\"), take_till(0.., |c| c == '@'), tag(\"@\"));\n            // let res = parser.context(StrContext::Label(\"xref\")).parse_next(input);\n\n            // if !res.is_err() {\n            //     let mut xref = res.unwrap();\n            //     xref += \"@\";\n            //     return Ok(\"@1@\");\n            // }\n            // take_till(1.., |c| c == '@').parse_next(input)\n            // let mut parser = delimited(\n            //     tag(\"@\"),\n            //     is_not(\"@\"),\n            //     tag(\"@\"),\n            // );\n\n            // parser(input)\n        }\n        Ok(\"\")\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_lines() {\n        let mut data = vec![\n            \"0 HEAD\",\n            \"1 CHAR UTF-8\",\n            \"1 SOUR Ancestry.com Family Trees\",\n            \"2 DATA Name of source data\",\n            \"3 DATE 1 JAN 1998\",\n            \"3 COPR Copyright of source data\",\n            \"1 SUBM @U1@\",\n            \"0 @U1@ SUBM\",\n        ];\n\n        let line = Line::parse(\u0026mut data[0]).unwrap();\n        assert!(line.level == 0 \u0026\u0026 line.tag == \"HEAD\");\n\n        let line = Line::parse(\u0026mut data[1]).unwrap();\n        assert!(line.level == 1 \u0026\u0026 line.tag == \"CHAR\" \u0026\u0026 line.value == \"UTF-8\");\n\n        let line = Line::parse(\u0026mut data[2]).unwrap();\n        assert!(line.level == 1 \u0026\u0026 line.tag == \"SOUR\" \u0026\u0026 line.value == \"Ancestry.com Family Trees\");\n\n        let line = Line::parse(\u0026mut data[3]).unwrap();\n        assert!(line.level == 2 \u0026\u0026 line.tag == \"DATA\" \u0026\u0026 line.value == \"Name of source data\");\n\n        let line = Line::parse(\u0026mut data[4]).unwrap();\n        assert!(line.level == 3 \u0026\u0026 line.tag == \"DATE\" \u0026\u0026 line.value == \"1 JAN 1998\");\n\n        let line = Line::parse(\u0026mut data[5]).unwrap();\n        assert!(line.level == 3 \u0026\u0026 line.tag == \"COPR\" \u0026\u0026 line.value == \"Copyright of source data\");\n\n        let line = Line::parse(\u0026mut data[6]).unwrap();\n        assert!(line.level == 1 \u0026\u0026 line.tag == \"SUBM\" \u0026\u0026 line.value == \"@U1@\");\n\n        let line = Line::parse(\u0026mut data[7]).unwrap();\n        // TODO: Update this to include the wrapping @ when I figure out how to make nom do that.\n        assert!(line.level == 0 \u0026\u0026 line.tag == \"SUBM\" \u0026\u0026 line.value == \"\" \u0026\u0026 line.xref == \"@U1@\");\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":818},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":818},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":818},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6807},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6807},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":905},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":905},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":5862},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":5862},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":11724},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":5639},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":5639},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":6807},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":3948},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3948},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":3948},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":3948},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":3948},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":19491},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":19491},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":12629},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":18714},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":6544},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":6085},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":20301},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":5862},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":5862},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":5862},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":5862},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":6767},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":512},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":6672},"fn_name":null}],"covered":59,"coverable":78},{"path":["/","Users","adam","src","rust-gedcom","src","types","map.rs"],"content":"use crate::types::Line;\n\nuse std::str::FromStr;\n\nuse winnow::prelude::*;\n\n// The GEDCOM specification of this type\n//\n// +1 MAP {0:1}\n// +2 LATI \u003cPLACE_LATITUDE\u003e {1:1} p.58\n// +2 LONG \u003cPLACE_LONGITUDE\u003e\n\n#[derive(Clone, Debug, Default)]\npub struct Map {\n    pub latitude: f64,\n    pub longitude: f64,\n}\n\nimpl Map {\n    /// Parse a map record\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cMap\u003e {\n        let mut map = Map {\n            latitude: 0.0,\n            longitude: 0.0,\n        };\n        let level = Line::peek(record).unwrap().level;\n\n        while !record.is_empty() {\n            let mut line = Line::parse(record).unwrap();\n            match line.tag {\n                \"LATI\" =\u003e {\n                    // Need to map this:\n                    // N41.913744 -\u003e 41.913744\n                    // S41.913744 -\u003e -41.913744\n                    map.latitude = f64::from_str(\u0026line.value[1..line.value.len()]).unwrap();\n                    if line.value.chars().nth(0) == Some('S') {\n                        map.latitude *= -1.0;\n                    }\n                }\n                \"LONG\" =\u003e {\n                    // Need to map this:\n                    // W88.31085 -\u003e -88.31085\n                    // E88.31085 -\u003e 88.31085\n                    map.longitude = f64::from_str(\u0026line.value[1..line.value.len()]).unwrap();\n                    if line.value.chars().nth(0) == Some('W') {\n                        map.longitude *= -1.0;\n                    }\n                }\n                _ =\u003e {}\n            }\n\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            line = Line::peek(record).unwrap();\n            if line.level == level {\n                break;\n            }\n        }\n\n        Ok(map)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_map() {\n        let data = vec![\"3 MAP\", \"4 LATI N41.913744\", \"4 LONG W88.31085\"];\n\n        let input = data.join(\"\\n\");\n        let mut record = input.as_str();\n        let map = Map::parse(\u0026mut record).unwrap();\n\n        assert!(map.latitude == 41.913744);\n        assert!(map.longitude == -88.31085);\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":17,"coverable":18},{"path":["/","Users","adam","src","rust-gedcom","src","types","mod.rs"],"content":"/// mod.rs\n// top-level record types\nmod address;\nmod adopted_by;\nmod corporation;\nmod datetime;\nmod event;\nmod family;\nmod gedc;\nmod header;\nmod individual;\nmod line;\nmod map;\nmod note;\nmod object;\nmod pedigree;\nmod place;\nmod quay;\nmod source;\nmod source_citation;\nmod sourcedata;\nmod submitter;\n\npub use address::*;\npub use adopted_by::AdoptedBy;\npub use datetime::DateTime;\npub use event::{EventDetail, EventTypeCitedFrom};\npub use family::Family;\npub use gedc::{Form, Gedc};\npub use header::Header;\npub use individual::*;\npub use line::Line;\npub use map::Map;\npub use note::Note;\npub use object::Object;\npub use pedigree::Pedigree;\npub use place::Place;\npub use quay::Quay;\npub use source::Source;\npub use source_citation::SourceCitation;\npub use sourcedata::SourceData;\npub use submitter::Submitter;\n\n#[derive(Debug, Default)]\npub struct Gedcom {\n    pub header: Header,\n    pub individuals: Vec\u003cIndividual\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adam","src","rust-gedcom","src","types","note.rs"],"content":"/// Parse a Note structure\n// use super::Line;\nuse crate::parse;\n\nuse winnow::prelude::*;\n\n#[derive(Debug, Default, PartialEq, Clone)]\npub struct Note {\n    /// The note\n    pub note: Option\u003cString\u003e,\n}\n\nimpl Note {\n    pub fn parse(buffer: \u0026mut \u0026str) -\u003e PResult\u003cNote\u003e {\n        let mut note = Note { note: None };\n\n        note.note = parse::get_tag_value(buffer).unwrap();\n\n        Ok(note)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Note;\n\n    #[test]\n    fn parse_note() {\n        // 1 NOTE This file demonstrates all tags that are allowed in GEDCOM 5.5. Here are some comments about the HEADER record\n        // 2 CONC and comments about where to look for information on the other 9 types of GEDCOM records. Most other records will\n        // 2 CONC have their own notes that describe what to look for in that record and what to hope the importing software will find.\n        // 2 CONT\n        // 2 CONT Many applications will fail to import these notes. The notes are therefore also provided with the files as a plain-text\n        // 2 CONC \"Read-Me\" file.\n\n        let data = vec![\n            \"1 NOTE This is the first line of a note.\",\n            \"2 CONT This is the second line of a note. \",\n            \"2 CONC This is also on the second line.\",\n            \"2 CONT This line should be the last line.\",\n        ];\n\n        let input = data.join(\"\\n\");\n        let mut record = input.as_str();\n        let note = Note::parse(\u0026mut record);\n        let n = note.unwrap().note.unwrap();\n\n        assert!(n.starts_with(\"This is the first line of a note.\\n\"));\n        assert!(n.ends_with(\"the last line.\"));\n        assert!(n == \"This is the first line of a note.\\nThis is the second line of a note. This is also on the second line.\\nThis line should be the last line.\");\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":11},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","Users","adam","src","rust-gedcom","src","types","object.rs"],"content":"// use crate::types::Line;\n\n// use nom::{bytes::complete::is_not, IResult};\n\n// 0 @M1@ OBJE\n// 1 FILE photo.jpeg\n// 2 FORM JPEG\n// 3 TYPE photo\n// 2 TITL Picture of the book cover\n// 1 REFN 01234567890123456789\n// 2 TYPE reference\n// 1 RIN 1\n// 1 NOTE Here are some notes on this multimedia object.\n// 2 CONT If decoded it should be an image of a flower.\n// 1 NOTE @N1@\n// 1 CHAN\n// 2 DATE 14 JAN 2001\n// 3 TIME 14:10:31\n\n#[derive(Debug, Eq, PartialEq, Clone)]\npub struct Object {\n    pub xref: String,\n}\n\nimpl Object {\n    pub fn parse(_record: \u0026str) -\u003e Object {\n        // let mut object = Object { xref: \"\" };\n\n        // while !record.is_empty() {\n        //     let (buffer, line) = Line::parse(\u0026record).unwrap();\n\n        //     // If we're at the top of the record, get the xref\n        //     // \u0026\u0026 level == 0\n        //     match line.level {\n        //         0 =\u003e {\n        //             object.xref = line.xref;\n        //         }\n        //         _ =\u003e {\n        //         }\n        //     }\n        // }\n        // object\n        Object {\n            xref: \"\".to_string(),\n        }\n    }\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","Users","adam","src","rust-gedcom","src","types","pedigree.rs"],"content":"use std::str::FromStr;\n\n// PEDIGREE_LINKAGE_TYPE:= {Size=5:7}\n// [ adopted | birth | foster | sealing ]\n// A code used to indicate the child to family relationship for pedigree navigation purposes.\n// Where:\n// adopted = indicates adoptive parents.\n// birth = indicates birth parents.\n// foster = indicates child was included in a foster or guardian family.\n// sealing = indicates child was sealed to parents other than birth parents.\n\n#[derive(Default, Debug, PartialEq, Clone)]\n/// The quantitative eveluation of the credibility of a piece of information\n/// based upon its supporting evidence.\npub enum Pedigree {\n    /// Adoptive parents\n    Adopted,\n    #[default]\n    /// Birth parents\n    Birth,\n    /// Foster parents\n    Foster,\n    // Sealed to parents other than birth parents\n    Sealing,\n}\n\nimpl FromStr for Pedigree {\n    type Err = ();\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cPedigree, Self::Err\u003e {\n        match input {\n            \"adopted\" =\u003e Ok(Pedigree::Adopted),\n            \"birth\" =\u003e Ok(Pedigree::Birth),\n            \"foster\" =\u003e Ok(Pedigree::Foster),\n            \"sealing\" =\u003e Ok(Pedigree::Sealing),\n            _ =\u003e Err(()),\n        }\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":7},{"path":["/","Users","adam","src","rust-gedcom","src","types","place.rs"],"content":"/// The Place structure\nuse crate::types::{Line, Map, Note};\n\nuse winnow::prelude::*;\n\n// PLACE_STRUCTURE:=\n// n PLAC \u003cPLACE_NAME\u003e {1:1} p.58\n// +1 FORM \u003cPLACE_HIERARCHY\u003e {0:1} p.58\n// 39\n// +1 FONE \u003cPLACE_PHONETIC_VARIATION\u003e {0:M} p.59\n// +2 TYPE \u003cPHONETIC_TYPE\u003e {1:1} p.57\n// +1 ROMN \u003cPLACE_ROMANIZED_VARIATION\u003e {0:M} p.59\n// +2 TYPE \u003cROMANIZED_TYPE\u003e {1:1} p.61\n// +1 MAP {0:1}\n// +2 LATI \u003cPLACE_LATITUDE\u003e {1:1} p.58\n// +2 LONG \u003cPLACE_LONGITUDE\u003e {1:1} p.58\n// +1 \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n\n#[derive(Clone, Debug, Default)]\npub struct Place {\n    pub name: Option\u003cString\u003e,\n    pub phonetic: Option\u003cPlaceVariation\u003e,\n    pub roman: Option\u003cPlaceVariation\u003e,\n    pub map: Option\u003cMap\u003e,\n    pub note: Option\u003cNote\u003e,\n}\n\nimpl Place {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cPlace\u003e {\n        let mut place = Place {\n            name: None,\n            phonetic: None,\n            roman: None,\n            map: None,\n            note: None,\n        };\n\n        let level = Line::peek(record).unwrap().level;\n        while !record.is_empty() {\n            let mut parse = true;\n            let mut line = Line::peek(record).unwrap();\n            match line.tag {\n                \"PLAC\" =\u003e {\n                    place.name = Some(line.value.to_string());\n                }\n                \"FONE\" =\u003e {\n                    place.phonetic = Some(PlaceVariation::parse(record).unwrap());\n                    parse = false;\n                }\n                \"ROMN\" =\u003e {\n                    place.roman = Some(PlaceVariation::parse(record).unwrap());\n                    parse = false;\n                }\n                \"MAP\" =\u003e {\n                    place.map = Some(Map::parse(record).unwrap());\n                    parse = false;\n                }\n                \"NOTE\" =\u003e {\n                    place.note = Some(Note::parse(record).unwrap());\n                    parse = false;\n                }\n                _ =\u003e {}\n            }\n\n            // If we need to, advance our position in the stream\n            if parse {\n                Line::parse(record).unwrap();\n            }\n\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            line = Line::peek(record).unwrap();\n            if line.level == level {\n                break;\n            }\n        }\n\n        Ok(place)\n    }\n}\n\n#[derive(Clone, Debug, Default)]\npub struct PlaceVariation {\n    pub name: Option\u003cString\u003e,\n    pub r#type: Option\u003cString\u003e,\n}\nimpl PlaceVariation {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cPlaceVariation\u003e {\n        let mut variation = PlaceVariation {\n            name: None,\n            r#type: None,\n        };\n        let level = Line::peek(record).unwrap().level;\n\n        while !record.is_empty() {\n            let mut line = Line::parse(record).unwrap();\n            match line.tag {\n                \"FONE\" =\u003e {\n                    variation.name = Some(line.value.to_string());\n                }\n                \"ROMN\" =\u003e {\n                    variation.name = Some(line.value.to_string());\n                }\n                \"TYPE\" =\u003e {\n                    variation.r#type = Some(line.value.to_string());\n                }\n                _ =\u003e {}\n            }\n\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            line = Line::peek(record).unwrap();\n            if line.level == level {\n                break;\n            }\n        }\n        Ok(variation)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_place() {\n        let data = vec![\n            \"2 PLAC Salt Lake City, UT, USA\",\n            \"3 FONE Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 ROMN Salt Lake City, UT, USA\",\n            \"4 TYPE user defined\",\n            \"3 MAP\",\n            \"4 LATI N0\",\n            \"4 LONG E0\",\n            \"3 NOTE Place note\",\n        ];\n\n        let input = data.join(\"\\n\");\n        let mut record = input.as_str();\n        let place = Place::parse(\u0026mut record).unwrap();\n\n        assert!(place.name.is_some());\n        assert!(place.name.unwrap() == \"Salt Lake City, UT, USA\");\n\n        let phonetic = place.phonetic.unwrap();\n        assert!(phonetic.name == Some(\"Salt Lake City, UT, USA\".to_string()));\n        assert!(phonetic.r#type == Some(\"user defined\".to_string()));\n\n        let roman = place.roman.unwrap();\n        assert!(roman.name == Some(\"Salt Lake City, UT, USA\".to_string()));\n        assert!(roman.r#type == Some(\"user defined\".to_string()));\n\n        assert!(place.map.is_some());\n        let map = place.map.unwrap();\n        assert!(map.latitude == 0.0);\n        assert!(map.longitude == 0.0);\n    }\n\n    #[test]\n    fn parse_variation() {\n        let data = vec![\"3 FONE Salt Lake City, UT, USA\", \"4 TYPE user defined\"];\n\n        let input = data.join(\"\\n\");\n        let mut record = input.as_str();\n        let variation = PlaceVariation::parse(\u0026mut record).unwrap();\n\n        assert!(variation.name.is_some());\n        assert!(variation.r#type.is_some());\n\n        assert!(variation.name.unwrap() == \"Salt Lake City, UT, USA\");\n        assert!(variation.r#type.unwrap() == \"user defined\");\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":85},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":85},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":13},"fn_name":null}],"covered":41,"coverable":43},{"path":["/","Users","adam","src","rust-gedcom","src","types","quay.rs"],"content":"use std::str::FromStr;\n\n// CERTAINTY_ASSESSMENT:= {Size=1:1}\n// [ 0 | 1 | 2 | 3 ]\n// The QUAY tag's value conveys the submitter's quantitative evaluation of the credibility of a piece of\n// information, based upon its supporting evidence. Some systems use this feature to rank multiple\n// conflicting opinions for display of most likely information first. It is not intended to eliminate the\n// receiver's need to evaluate the evidence for themselves.\n// 0 = Unreliable evidence or estimated data\n// 1 = Questionable reliability of evidence (interviews, census, oral genealogies, or potential for bias\n// for example, an autobiography)\n// 2 = Secondary evidence, data officially recorded sometime after event\n// 3 = Direct and primary evidence used, or by dominance of the evidence\n\n#[derive(Clone, Default, Debug, PartialEq)]\n/// The quantitative eveluation of the credibility of a piece of information\n/// based upon its supporting evidence.\npub enum Quay {\n    #[default]\n    Unreliable,\n    Questionable,\n    Secondary,\n    Direct,\n}\n\nimpl FromStr for Quay {\n    type Err = ();\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cQuay, Self::Err\u003e {\n        match input {\n            \"0\" =\u003e Ok(Quay::Unreliable),\n            \"1\" =\u003e Ok(Quay::Questionable),\n            \"2\" =\u003e Ok(Quay::Secondary),\n            \"3\" =\u003e Ok(Quay::Direct),\n            _ =\u003e Err(()),\n        }\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":7},{"path":["/","Users","adam","src","rust-gedcom","src","types","source.rs"],"content":"// use crate::parse;\n// use crate::types::corporation::Corporation;\n\nuse super::{corporation::Corporation, Line, SourceData};\n\n// +1 SOUR \u003cAPPROVED_SYSTEM_ID\u003e\n//     +2 VERS \u003cVERSION_NUMBER\u003e\n//     +2 NAME \u003cNAME_OF_PRODUCT\u003e\n//     +2 CORP \u003cNAME_OF_BUSINESS\u003e\n//         +3 \u003c\u003cADDRESS_STRUCTURE\u003e\u003e\n//     +2 DATA \u003cNAME_OF_SOURCE_DATA\u003e\n//         +3 DATE \u003cPUBLICATION_DATE\u003e\n//         +3 COPR \u003cCOPYRIGHT_SOURCE_DATA\u003e\n//         +4 [CONT|CONC]\u003cCOPYRIGHT_SOURCE_DATA\u003e\n\n// 1 SOUR Ancestry.com Family Trees\n// 2 NAME Ancestry.com Member Trees\n// 2 VERS 2021.07\n// 2 _TREE Ambrose Bierce Family Tree\n// 3 RIN 116823582\n// 3 _ENV prd\n// 2 CORP Ancestry.com\n// 3 PHON 801-705-7000\n// 3 WWW www.ancestry.com\n// 3 ADDR 1300 West Traverse Parkway\n// 4 CONT Lehi, UT  84043\n// 4 CONT USA\n\n#[derive(Clone, Debug, Default)]\npub struct Source {\n    /// A corporation tag contains the name of the corporation and its address.\n    pub corporation: Option\u003cCorporation\u003e,\n    // pub data: Option\u003cData\u003e,\n    pub name: Option\u003cString\u003e,\n    pub source: String,\n    pub data: Option\u003cSourceData\u003e,\n    // pub copyright: Option\u003cCopyright\u003e,\n    pub version: Option\u003cString\u003e,\n}\n\nimpl Source {\n    /// Parse a SOUR record\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cSource\u003e) {\n        let mut source = Source {\n            corporation: None,\n            data: None,\n            name: None,\n            source: \"\".to_string(),\n            version: None,\n        };\n        let mut line: Line;\n\n        line = Line::peek(\u0026mut buffer).unwrap();\n\n        // Verify we have a SOUR record\n        if line.level == 1 \u0026\u0026 line.tag == \"SOUR\" {\n            // Consume the first line\n            line = Line::parse(\u0026mut buffer).unwrap();\n\n            source.source = line.value.to_string();\n\n            let mut next = Line::peek(\u0026mut buffer).unwrap();\n\n            while next.level \u003e= line.level {\n                // We don't want to consume the line yet because we may need\n                // the original for a parser.\n                let inner_line: Line = Line::peek(\u0026mut buffer).unwrap();\n\n                // println!(\"Evaluating tag: {:?}\", inner_line.tag);\n                match inner_line.tag {\n                    // An ancestry-specific tag\n                    \"_TREE\" =\u003e {\n                        // The value of tree contains the tree name, which is useful,\n                        // but not a part of the GEDCOM spec.\n                        // The next level (3) may contain RIN, some sort of internal id\n                        // but is probably not useful for anything\n                        println!(\"Skipping _TREE\");\n                        // Consume the line\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"CORP\" =\u003e {\n                        (buffer, source.corporation) = Corporation::parse(buffer);\n                    }\n                    \"NAME\" =\u003e {\n                        source.name = Some(inner_line.value.to_string());\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"VERS\" =\u003e {\n                        source.version = Some(inner_line.value.to_string());\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                    \"DATA\" =\u003e {\n                        (buffer, source.data) = SourceData::parse(buffer);\n                    }\n                    _ =\u003e {\n                        println!(\"Unknown line: {:?}\", inner_line);\n\n                        // consume the line so we can parse the next\n                        Line::parse(\u0026mut buffer).unwrap();\n                    }\n                }\n\n                // Peek at the next level\n                if !buffer.is_empty() {\n                    next = Line::peek(\u0026mut buffer).unwrap();\n                    if next.level \u003c= 1 {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n\n        (buffer, Some(source))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::types::DateTime;\n\n    use super::{Source, SourceData};\n\n    #[test]\n    fn parse() {\n        let data = vec![\n            \"1 SOUR GEDitCOM\",\n            \"2 VERS 2.9.4\",\n            \"2 NAME GEDitCOM\",\n            \"2 CORP RSAC Software\",\n            \"3 ADDR\",\n            \"4 ADR1 RSAC Software\",\n            \"4 ADR2 7108 South Pine Cone Street\",\n            \"4 ADR3 Ste 1\",\n            \"4 CITY Salt Lake City\",\n            \"4 STAE UT\",\n            \"4 POST 84121\",\n            \"4 CTRY USA\",\n            \"3 PHON +1-801-942-7768\",\n            \"3 PHON +1-801-555-1212\",\n            \"3 PHON +1-801-942-1148\",\n            \"3 EMAIL a@@example.com\",\n            \"3 EMAIL b@@example.com\",\n            \"3 EMAIL c@@example.com\",\n            \"3 FAX +1-801-942-7768\",\n            \"3 FAX +1-801-555-1212\",\n            \"3 FAX +1-801-942-1148\",\n            \"3 WWW https://www.example.com\",\n            \"3 WWW https://www.example.org\",\n            \"3 WWW https://www.example.net\",\n            \"2 DATA Name of source data\",\n            \"3 DATE 1 JAN 1998\",\n            \"3 COPR Copyright of source data\",\n        ];\n\n        let (_data, source) = Source::parse(\u0026data.join(\"\\n\"));\n        let sour = source.unwrap();\n\n        assert_eq!(sour.source, \"GEDitCOM\".to_string());\n        assert_eq!(sour.name, Some(\"GEDitCOM\".to_string()));\n        assert_eq!(sour.version, Some(\"2.9.4\".to_string()));\n        assert_eq!(\n            sour.data,\n            Some(SourceData {\n                name: Some(\"Name of source data\".to_string()),\n                date: Some(DateTime {\n                    date: Some(\"1 JAN 1998\".to_string()),\n                    time: None\n                }),\n                copyright: Some(\"Copyright of source data\".to_string()),\n            })\n        );\n        let corp = sour.corporation.unwrap();\n\n        assert_eq!(corp.name, Some(\"RSAC Software\".to_string()));\n\n        let corp_address: crate::types::Address = corp.address.unwrap();\n        assert_eq!(corp_address.addr1, Some(\"RSAC Software\".to_string()));\n        assert_eq!(\n            corp_address.addr2,\n            Some(\"7108 South Pine Cone Street\".to_string())\n        );\n        assert_eq!(corp_address.addr3, Some(\"Ste 1\".to_string()));\n        assert_eq!(corp_address.city, Some(\"Salt Lake City\".to_string()));\n        assert_eq!(corp_address.state, Some(\"UT\".to_string()));\n        assert_eq!(corp_address.postal_code, Some(\"84121\".to_string()));\n        assert_eq!(corp_address.country, Some(\"USA\".to_string()));\n\n        assert!(corp_address.phone.contains(\u0026\"+1-801-942-7768\".to_string()));\n        assert!(corp_address.phone.contains(\u0026\"+1-801-555-1212\".to_string()));\n        assert!(corp_address.phone.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(corp_address.email.contains(\u0026\"a@@example.com\".to_string()));\n        assert!(corp_address.email.contains(\u0026\"b@@example.com\".to_string()));\n        assert!(corp_address.email.contains(\u0026\"c@@example.com\".to_string()));\n        assert!(corp_address.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(corp_address.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(corp_address.fax.contains(\u0026\"+1-801-942-1148\".to_string()));\n        assert!(corp_address\n            .www\n            .contains(\u0026\"https://www.example.com\".to_string()));\n        assert!(corp_address\n            .www\n            .contains(\u0026\"https://www.example.org\".to_string()));\n        assert!(corp_address\n            .www\n            .contains(\u0026\"https://www.example.net\".to_string()));\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":28,"coverable":33},{"path":["/","Users","adam","src","rust-gedcom","src","types","source_citation.rs"],"content":"use std::str::FromStr;\n\nuse crate::parse;\n\nuse super::{EventTypeCitedFrom, Line, Note, Object, Quay};\n\nuse winnow::prelude::*;\n\n// [ /* pointer to source record (preferred)*/\n// n SOUR @\u003cXREF:SOUR\u003e@ {1:1} p.27\n// +1 PAGE \u003cWHERE_WITHIN_SOURCE\u003e {0:1} p.64\n// +1 EVEN \u003cEVENT_TYPE_CITED_FROM\u003e {0:1} p.49\n// +2 ROLE \u003cROLE_IN_EVENT\u003e {0:1} p.61\n// +1 DATA {0:1}\n// +2 DATE \u003cENTRY_RECORDING_DATE\u003e {0:1} p.48\n// +2 TEXT \u003cTEXT_FROM_SOURCE\u003e {0:M} p.63\n// +3 [CONC|CONT] \u003cTEXT_FROM_SOURCE\u003e {0:M}\n// +1 \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n// +1 \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// +1 QUAY \u003cCERTAINTY_ASSESSMENT\u003e {0:1} p.43\n\n// | /* Systems not using source records */\n// n SOUR \u003cSOURCE_DESCRIPTION\u003e {1:1} p.61\n// +1 [CONC|CONT] \u003cSOURCE_DESCRIPTION\u003e {0:M}\n// +1 TEXT \u003cTEXT_FROM_SOURCE\u003e {0:M} p.63\n// +2 [CONC|CONT] \u003cTEXT_FROM_SOURCE\u003e {0:M}\n// +1 \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n// +1 \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// +1 QUAY \u003cCERTAINTY_ASSESSMENT\u003e {0:1} p.43\n// ]\n\n#[derive(Clone, Debug, Default)]\npub struct SourceCitation {\n    pub xref: Option\u003cString\u003e,\n    pub page: Option\u003ci32\u003e,\n    pub event: Option\u003cEventTypeCitedFrom\u003e,\n    pub data: Option\u003cSourceCitationData\u003e,\n    pub media: Vec\u003cObject\u003e,\n    pub note: Option\u003cNote\u003e,\n    pub quay: Option\u003cQuay\u003e,\n}\n\nimpl SourceCitation {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cSourceCitation\u003e {\n        let mut sc = SourceCitation {\n            xref: None,\n            page: None,\n            event: None,\n            data: None,\n            media: vec![],\n            note: None,\n            quay: None,\n        };\n\n        let level = Line::peek(record).unwrap().level;\n        let mut line = Line::peek(record).unwrap();\n\n        while !record.is_empty() {\n            let mut consume = true;\n            match line.tag {\n                \"DATA\" =\u003e {\n                    sc.data = Some(SourceCitationData::parse(record).unwrap());\n                    consume = false;\n                }\n                \"EVEN\" =\u003e {\n                    sc.event = Some(EventTypeCitedFrom::parse(record).unwrap());\n                    consume = false;\n                }\n                \"NOTE\" =\u003e {\n                    let note = parse::get_tag_value(record).unwrap();\n                    sc.note = Some(Note { note });\n                    consume = false;\n                }\n                \"OBJE\" =\u003e {\n                    let obj = Object {\n                        xref: line.value.to_string(),\n                    };\n                    sc.media.push(obj);\n                }\n                \"PAGE\" =\u003e {\n                    sc.page = Some(line.value.parse().unwrap());\n                }\n                \"QUAY\" =\u003e {\n                    let quay = Quay::from_str(line.value).unwrap();\n                    sc.quay = Some(quay);\n                }\n                \"SOUR\" =\u003e {\n                    sc.xref = Some(line.value.to_string());\n                }\n                _ =\u003e {}\n            }\n\n            if consume {\n                Line::parse(record).unwrap();\n            }\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            line = Line::peek(record).unwrap();\n            if line.level == level {\n                break;\n            }\n        }\n\n        Ok(sc)\n    }\n}\n\n#[derive(Clone, Debug, Default)]\npub struct SourceCitationData {\n    pub date: Option\u003cString\u003e,\n    pub text: Option\u003cNote\u003e,\n}\nimpl SourceCitationData {\n    pub fn parse(record: \u0026mut \u0026str) -\u003e PResult\u003cSourceCitationData\u003e {\n        let mut data = SourceCitationData {\n            date: None,\n            text: None,\n        };\n\n        let level = Line::peek(record).unwrap().level;\n        let mut line = Line::peek(record).unwrap();\n\n        while !record.is_empty() {\n            let mut consume = true;\n            match line.tag {\n                \"DATE\" =\u003e {\n                    data.date = Some(line.value.to_string());\n                }\n                \"TEXT\" =\u003e {\n                    let text = parse::get_tag_value(record).unwrap();\n                    let note = Note { note: text };\n                    data.text = Some(note);\n                    consume = false;\n                }\n                _ =\u003e {}\n            }\n\n            if consume {\n                Line::parse(record).unwrap();\n            }\n            // If the next level matches our initial level, we're done parsing\n            // this structure.\n            line = Line::peek(record).unwrap();\n            if line.level == level {\n                break;\n            }\n        }\n        Ok(data)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_source_citation() {\n        let data = vec![\n            \"2 SOUR @S1@\",\n            \"3 PAGE 42\",\n            \"3 EVEN BIRT\",\n            \"4 ROLE CHIL\",\n            \"3 DATA\",\n            \"4 DATE 1 JAN 1900\",\n            \"4 TEXT Here is some text from the source specific to this source \",\n            \"5 CONC citation.\",\n            \"5 CONT Here is more text but on a new line.\",\n            \"3 OBJE @M8@\",\n            \"3 NOTE Some notes about this birth source citation which are embedded in the citation \",\n            \"4 CONC structure itself.\",\n            \"3 QUAY 2\",\n        ].join(\"\\n\");\n\n        let mut record = data.as_str();\n        let detail = SourceCitation::parse(\u0026mut record).unwrap();\n\n        assert!(detail.data.is_some());\n        let sc = detail.data.unwrap();\n        assert!(sc.date.unwrap() == \"1 JAN 1900\");\n        assert!(sc.text.unwrap().note.unwrap() == \"Here is some text from the source specific to this source citation.\\nHere is more text but on a new line.\");\n\n        assert!(detail.xref.is_some());\n        assert!(detail.xref.unwrap() == \"@S1@\");\n\n        assert!(detail.event.is_some());\n        let event = detail.event.unwrap();\n        assert!(event.r#type.unwrap() == \"BIRT\");\n        assert!(event.role.unwrap() == \"CHIL\");\n\n        assert!(detail.page.is_some());\n        assert!(detail.page.unwrap() == 42);\n    }\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":143},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":168},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":122},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":136},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":226},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":142},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":104},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":130},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":52},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":26},"fn_name":null}],"covered":53,"coverable":54},{"path":["/","Users","adam","src","rust-gedcom","src","types","sourcedata.rs"],"content":"use super::{DateTime, Line};\nuse crate::parse;\n\n//     +2 DATA \u003cNAME_OF_SOURCE_DATA\u003e\n//         +3 DATE \u003cPUBLICATION_DATE\u003e\n//         +3 COPR \u003cCOPYRIGHT_SOURCE_DATA\u003e\n//         +4 [CONT|CONC]\u003cCOPYRIGHT_SOURCE_DATA\u003e\n#[derive(Clone, Debug, Default, PartialEq)]\npub struct SourceData {\n    pub name: Option\u003cString\u003e,\n    pub date: Option\u003cDateTime\u003e,\n    pub copyright: Option\u003cString\u003e,\n}\n\nimpl SourceData {\n    /// Parse a SOUR record\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cSourceData\u003e) {\n        let mut data = SourceData {\n            name: None,\n            date: None,\n            copyright: None,\n        };\n        let mut line: Line;\n\n        line = Line::peek(\u0026mut buffer).unwrap();\n        if line.tag == \"DATA\" {\n            let lvl = line.level;\n\n            // consume the line\n            line = Line::parse(\u0026mut buffer).unwrap();\n            data.name = Some(line.value.to_string());\n\n            while line.level \u003e= lvl {\n                if buffer.is_empty() {\n                    break;\n                }\n\n                line = Line::peek(\u0026mut buffer).unwrap();\n                if line.level == 1 {\n                    // abort\n                    break;\n                }\n                match line.tag {\n                    \"DATE\" =\u003e {\n                        (buffer, data.date) = DateTime::parse(buffer);\n                    }\n                    \"COPR\" =\u003e {\n                        // Consume the line and get the value\n                        data.copyright = parse::get_tag_value(\u0026mut buffer).unwrap();\n                    }\n                    _ =\u003e {\n                        break;\n                    }\n                }\n            }\n        }\n\n        (buffer, Some(data))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::SourceData;\n    use crate::types::DateTime;\n\n    #[test]\n    fn parse() {\n        let data = vec![\n            \"2 DATA Name of source data\",\n            \"3 DATE 1 JAN 1998\",\n            \"3 COPR Copyright of source data\",\n        ];\n\n        let (_data, _sourcedata) = SourceData::parse(\u0026data.join(\"\\n\"));\n        let sourcedata = _sourcedata.unwrap();\n\n        assert_eq!(\n            Some(sourcedata),\n            Some(SourceData {\n                name: Some(\"Name of source data\".to_string()),\n                date: Some(DateTime {\n                    date: Some(\"1 JAN 1998\".to_string()),\n                    time: None\n                }),\n                copyright: Some(\"Copyright of source data\".to_string()),\n            })\n        );\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":20,"coverable":20},{"path":["/","Users","adam","src","rust-gedcom","src","types","submitter.rs"],"content":"use crate::types::{Address, DateTime, Line, Note};\n\n// n @\u003cXREF:SUBM\u003e@ SUBM {1:1}\n// +1 NAME \u003cSUBMITTER_NAME\u003e {1:1} p.63\n// +1 \u003c\u003cADDRESS_STRUCTURE\u003e\u003e {0:1}* p.31\n// +1 \u003c\u003cMULTIMEDIA_LINK\u003e\u003e {0:M} p.37, 26\n// +1 LANG \u003cLANGUAGE_PREFERENCE\u003e {0:3} p.51\n// +1 RFN \u003cSUBMITTER_REGISTERED_RFN\u003e {0:1} p.63\n// +1 RIN \u003cAUTOMATED_RECORD_ID\u003e {0:1} p.43\n// +1 \u003c\u003cNOTE_STRUCTURE\u003e\u003e {0:M} p.37\n// +1 \u003c\u003cCHANGE_DATE\u003e\u003e\n\n#[derive(Clone, Debug, Default, PartialEq)]\npub struct Submitter {\n    /// The pointer to the SUBM record\n    pub xref: Option\u003cString\u003e,\n    pub name: Option\u003cString\u003e,\n    pub address: Option\u003cAddress\u003e,\n    pub media: Vec\u003cString\u003e,\n    /// A list of languages in which the submitter prefers to communicate\n    /// listed in order of priority.\n    pub lang: Vec\u003cString\u003e,\n    pub rfn: Option\u003cString\u003e,\n    pub rin: Option\u003cString\u003e,\n    pub note: Option\u003cNote\u003e,\n    pub change_date: Option\u003cDateTime\u003e,\n}\n\nimpl Submitter {\n    pub fn find_by_xref(mut buffer: \u0026str, xref: String) -\u003e Option\u003cSubmitter\u003e {\n        // println!(\"find_by_xref::buffer: {:?}\", buffer);\n        let mut submitter = Submitter {\n            xref: Some(xref),\n            name: None,\n            address: None,\n            media: vec![],\n            lang: vec![],\n            rfn: None,\n            rin: None,\n            note: None,\n            change_date: None,\n        };\n        let mut line = Line::peek(\u0026mut buffer).unwrap();\n\n        while !buffer.is_empty() {\n            // this is only going to match one line. We want to skip forward\n            // until we reach this line, and then process until we hit either EOF or a new 0 level\n            // if line.level == 0 \u0026\u0026 xref == line.xref.unwrap() {\n            if line.level == 0 {\n                // Peek at the next line so we know how to parse it.\n                line = Line::peek(\u0026mut buffer).unwrap();\n\n                // Loop through the rest of the record\n                while line.level \u003e 0 || !buffer.is_empty() {\n                    match line.tag {\n                        \"NAME\" =\u003e {\n                            submitter.name = Some(line.value.to_string());\n                            Line::parse(\u0026mut buffer).unwrap();\n                        }\n                        \"ADDR\" =\u003e {\n                            submitter.address = Some(Address::parse(\u0026mut buffer).unwrap());\n                        }\n                        \"OBJE\" =\u003e {\n                            // Parse the object id and add it to the list\n                            let media_xref = line.value;\n                            submitter.media.push(media_xref.to_string());\n                            Line::parse(\u0026mut buffer).unwrap();\n                            // TODO: find the media object and parse it\n                        }\n                        \"RIN\" =\u003e {\n                            line = Line::parse(\u0026mut buffer).unwrap();\n                            submitter.rin = Some(line.value.to_string());\n                            // println!(\"!! {:}\", line.tag);\n                        }\n                        \"CHAN\" =\u003e {\n                            // Parse the date/time\n                            Line::parse(\u0026mut buffer).unwrap();\n                            (buffer, submitter.change_date) = DateTime::parse(buffer);\n                        }\n                        \"LANG\" =\u003e {\n                            let lang = line.value;\n                            submitter.lang.push(lang.to_string());\n                            Line::parse(\u0026mut buffer).unwrap();\n                        }\n                        \"NOTE\" =\u003e {\n                            submitter.note = Some(Note::parse(\u0026mut buffer).unwrap());\n                        }\n                        \"RFN\" =\u003e {\n                            let rfn = line.value;\n                            submitter.rfn = Some(rfn.to_string());\n                            Line::parse(\u0026mut buffer).unwrap();\n                        }\n                        _ =\u003e {\n                            // Advance the buffer past the unknown line\n                            Line::parse(\u0026mut buffer).unwrap();\n                        }\n                    }\n                    line = Line::peek(\u0026mut buffer).unwrap();\n                }\n            } else {\n                line = Line::parse(\u0026mut buffer).unwrap();\n            }\n        }\n\n        Some(submitter)\n    }\n\n    /// Parses a SUBM block\n    pub fn parse(mut buffer: \u0026str) -\u003e (\u0026str, Option\u003cSubmitter\u003e) {\n        let mut submitter = Submitter {\n            xref: None,\n            name: None,\n            address: None,\n            media: vec![],\n            lang: vec![],\n            rfn: None,\n            rin: None,\n            note: None,\n            change_date: None,\n        };\n        let mut line = Line::peek(\u0026mut buffer).unwrap();\n        if line.level == 1 \u0026\u0026 line.tag == \"SUBM\" {\n            // advance our position in the buffer\n            line = Line::parse(\u0026mut buffer).unwrap();\n            // This is a temporary hack, because parse::xref strips @ from the id\n            let xref = line.value;\n            submitter.xref = Some(xref.to_owned());\n        }\n\n        (buffer, Some(submitter))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Submitter;\n\n    #[test]\n    fn parse_submitter() {\n        let data = vec![\n            \"1 SUBM @U1@\",\n            // other records that we need to skip over\n            \"1 FILE TGC55C.ged\",\n            \"1 COPR © 1997 by H. Eichmann, parts © 1999-2000 by J. A. Nairn.\",\n            // The submitter record\n            \"0 @U1@ SUBM\",\n            \"1 NAME Adam Israel\",\n            \"1 ADDR\",\n            \"2 ADR1 Example Software\",\n            \"2 ADR2 123 Main Street\",\n            \"2 ADR3 Ste 1\",\n            \"2 CITY Anytown\",\n            \"2 STAE IL\",\n            \"2 POST 55555\",\n            \"2 CTRY USA\",\n            \"1 PHON +1-800-555-1111\",\n            \"1 PHON +1-800-555-1212\",\n            \"1 PHON +1-800-555-1313\",\n            \"1 EMAIL a@@example.com\",\n            \"1 EMAIL b@@example.com\",\n            \"1 EMAIL c@@example.com\",\n            \"1 FAX +1-800-555-1414\",\n            \"1 FAX +1-800-555-1515\",\n            \"1 FAX +1-800-555-1616\",\n            \"1 WWW https://www.example.com\",\n            \"1 WWW https://www.example.org\",\n            \"1 WWW https://www.example.net\",\n            \"1 OBJE @M1@\",\n            \"1 RFN 123456789\",\n            \"1 RIN 1\",\n            \"1 NOTE This is a test note.\",\n            \"2 CONT And so is this.\",\n            \"1 CHAN\",\n            \"2 DATE 7 SEP 2000\",\n            \"3 TIME 8:35:36\",\n            \"1 LANG English\",\n            \"1 LANG German\",\n        ];\n\n        let (_, mut submitter) = Submitter::parse(data.join(\"\\n\").as_str());\n        let xref = submitter.unwrap().xref;\n\n        // Now, find the xref\n        submitter = Submitter::find_by_xref(data.join(\"\\n\").as_str(), xref.unwrap());\n        let s = submitter.unwrap();\n\n        assert!(s.xref == Some(\"@U1@\".to_string()));\n        assert!(s.name == Some(\"Adam Israel\".to_string()));\n\n        let addr = s.address.unwrap();\n\n        assert!(addr.addr1 == Some(\"Example Software\".to_string()));\n        assert!(addr.addr2 == Some(\"123 Main Street\".to_string()));\n        assert!(addr.addr3 == Some(\"Ste 1\".to_string()));\n        assert!(addr.city == Some(\"Anytown\".to_string()));\n        assert!(addr.state == Some(\"IL\".to_string()));\n        assert!(addr.postal_code == Some(\"55555\".to_string()));\n        assert!(addr.country == Some(\"USA\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-800-555-1111\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-800-555-1212\".to_string()));\n        assert!(addr.phone.contains(\u0026\"+1-800-555-1313\".to_string()));\n        assert!(addr.email.contains(\u0026\"a@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"b@@example.com\".to_string()));\n        assert!(addr.email.contains(\u0026\"c@@example.com\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-800-555-1414\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-800-555-1515\".to_string()));\n        assert!(addr.fax.contains(\u0026\"+1-800-555-1616\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.com\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.org\".to_string()));\n        assert!(addr.www.contains(\u0026\"https://www.example.net\".to_string()));\n\n        // TODO: Make sure this resolves to a Media record\n        assert!(s.media.contains(\u0026\"@M1@\".to_string()));\n\n        assert!(s.lang.contains(\u0026\"English\".to_string()));\n        assert!(s.lang.contains(\u0026\"German\".to_string()));\n\n        assert!(s.rin == Some(\"1\".to_string()));\n\n        let date = s.change_date.unwrap();\n        assert!(date.date == Some(\"7 SEP 2000\".to_string()));\n        assert!(date.time == Some(\"8:35:36\".to_string()));\n\n        // TODO: Implement these once the fields are implemented.\n        assert!(s.rfn == Some(\"123456789\".to_string()));\n\n        let note = s.note.unwrap().note.unwrap();\n        assert!(note.starts_with(\"This is a test note.\"));\n        assert!(note.ends_with(\"And so is this.\"));\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":47,"coverable":49}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>